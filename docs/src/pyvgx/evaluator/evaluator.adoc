[[evaluator]]
= VGX Expression Language <<../reference.adoc#, icon:arrow-circle-up[title="pyvgx Reference"]>> <<selectEvaluator.adoc#, icon:arrow-circle-right[title="Select Evaluator"]>> <<theend, icon:chevron-circle-down[title="Bottom of page"]>>
:toc: left
:encoding: utf-8
:toclevels: 4
:sectnums:
:sectnumlevels: 4
:imagesdir: ../images/
:stem:
:source-highlighter: highlightjs

include::../common/_copyable.adoc[]

// cspell:ignore latexmath arcsinh arccosh arctanh
[latexmath]
++++
\DeclareMathOperator\arcsinh{arcsinh}
\DeclareMathOperator\arccosh{arcsinh}
\DeclareMathOperator\arctanh{arcsinh}
\DeclareMathOperator\sgn{sgn}
++++

[[evaluatorquickstart]]
== Quick Start

Expressions can be used in query filters, for result sorting, and to select result fields. Below are three examples showing each case.

[[quickfilter]]
=== filter

This filter requires the value of the arc from "A" to its neighbor to be greater than 10 and the neighbor id must equal "B" or start with "C" or end with "d".

[source, python]
----
graph.Neighborhood( "A",
    filter=".arc.value > 10 && next.id in {'B', 'C*', '*d'}"
)
----

[[quickrank]]
=== rank

This custom ranking function will divide the neighbor's "score" property by the arc value and multiply the result by the anchor's "boost" property. The function's output value is used for sorting the query results.

[source, python]
----
graph.Neighborhood( "A",
    rank="vertex['boost'] * (next['score'] / .arc.value)"
    sortby=S_RANK
)
----

[[quickselect]]
=== select

This select statement formats the query result to include the neighbor's "score" property, the value of the arc from "A" to its neighbor, and a computed value with custom name "RATIO".

[source, python]
----
graph.Neighborhood( "Alice",
    select="score; .arc.value; RATIO: next['score'] / .arc.value"
)
----

See <<selectEvaluator.adoc#selectlabel, Select Evaluator>> for details.

[[operationreference]]
=== Quick Reference

[cols="1,1,10,16"]
|===
3+|Section |Description

3+|*<<evaluatordefine>>*
|Define an expression and assign it to a name

3+|*<<evaluate>>*
|Evaluate an expression

3+|*<<evaluatorsyntax>>*
|Expression syntax and operators

4+|*<<evaluatorattrprop>>*

|->
2+|<<arcattributes>>
|Arc attributes (relationship type, value, etc.)

|->
2+|<<vertexattributes>>
|Vertex attributes (id, degree, timestamps, etc.)

|->
2+|<<vertexproperties>>
|User defined vertex properties (key/value pairs)

3+|*<<evaluatorconstants>>*
|Pre-defined numeric constants for use in expressions

3+|*<<evaluatorenvironment>>*
|Variables derived from current execution environment

4+|*<<evaluatorfunctions>>*

|->
2+|<<mathfunctions>>
|Basic math functions (`log`, `sqrt`, `sin`, etc.)

|->
2+|<<castandcheckfunctions>>
|Check and convert data types (`int`, `isstr`, `len`, etc.)

|->
2+|<<stringfunctions>>
|Basic string operations (`join`, `replace`, etc.)

|->
2+|<<proplookupfunctions>>
|Retrieve vertex property by key

|->
2+|<<enumfunctions>>
|Encode or decode enumerations (`relenc`, `typedec`, etc.)

|->
2+|<<similarityfunctions_feature>>
|Compute vector similarity (`cosine`, `hamdist`, etc.)

|->
2+|<<controlfunctions>>
|Control functions (`do`, `firstval`, `returnif`, `halt`, etc.)

|->
2+|<<variadicaggregatorfunctions>>
|Aggregate multiple variable arguments (`sum`, `prod`, `mean`, etc.)

|->
2+|<<simplerankingfunctions>>
|Basic functions for ranking search results (`rank`, `prox`, etc.)

|->
2+|<<collectorstagingfunctions>>
|Collect result data in expressions (`stage`, `collectif`, etc.)

4+|*<<evaluatormemory>>*

|->
2+|<<evaluatormemorysingle>>
|These functions perform operations on a specified memory location

2+|
|__<<evaluatormemorystoreload>>__
|Write and read memory data location (`store`, `write`, `load`, etc.)

2+|
|__<<evaluatormemorystackops>>__
|Memory stack operations (`push`, `pop`, etc.)

2+|
|__<<evaluatormemorymovingdata>>__
|Move data between memory locations (`mov`, `xchg`, etc.)

2+|
|__<<evaluatormemoryincdec>>__
|Inc/dec data in memory location (`inc`, `decif`, etc.)

2+|
|__<<evaluatormemorycomparator>>__
|Compare data in two memory locations (`equ`, `gt`, `lte`, etc.)

2+|
|__<<evaluatormemoryarithmetic>>__
|Arithmetic operations on memory location (`add`, `divif`, etc.)

2+|
|__<<evaluatormemorybitwise>>__
|Bitwise operations on memory location (`shr`, `and`, `xorif`, etc.)

2+|
|__<<evaluatormemoryvector>>__
|AVX accelerated bytearray vector operations (`dp_pi8`, `cos_pi8`, etc.)

2+|
|__<<evaluatormemoryvarious>>__
|Smoothing and counting (`smooth`, `count`, etc.)

2+|
|__<<evaluatormemoryindexingop>>__
|Various memory indexing helper functions (`modindex`, etc.)

|->
2+|<<evaluatormemory_multiple>>
|These functions perform array operations on multiple memory locations

2+|
|__<<evaluatormemory_arraysetcopy>>__
|Assign and copy data (`mset`, `mcopy`, etc.)

2+|
|__<<evaluatormemory_arrayheap>>__
|Min/max-heap operations (`mheapifymin`, `mheappushmin`, etc.)

2+|
|__<<evaluatormemory_arraysort>>__
|Sort a memory range (`msort`, `mreverse`, etc.)

2+|
|__<<evaluatormemory_arraycast>>__
|Convert data in multiple memory locations (`mint`, `mreal`, etc.)

2+|
|__<<evaluatormemory_arrayincdec>>__
|Inc/dec all locations in memory range (`minc`, `mdec`, etc.)

2+|
|__<<evaluatormemory_scalararrayarithmetic>>__
|Arithmetic on multiple memory locations (`mmul`, `msqrt`, etc.)

2+|
|__<<evaluatormemory_arraynumeric>>__
|Numeric operations on multiple locations (`mround`, `mabs`, etc.)

2+|
|__<<evaluatormemory_arraylogexp>>__
|Apply log/exp to memory range (`mlog2`, `mlog10`, `mexp`, etc.)

2+|
|__<<evaluatormemory_arraytrighyp>>__
|Apply trig/hyp functions to memory range (`msin`, `macosh`, etc.)

2+|
|__<<evaluatormemory_arraybitwise>>__
|Bit shift and logical operations on memory range (`mshr`, `mxor`, etc.)

2+|
|__<<evaluatormemory_arrayhash>>__
|Hash multiple memory locations (`mhash`)

2+|
|__<<evaluatormemory_arrayaggregate>>__
|Aggregate memory range (`msum`, `msumsqr`, `mharmmean`, etc.)

2+|
|__<<evaluatormemory_arrayprobe>>__
|Search memory range (`mcount`, `mcmp`, `msubset`, etc.)

|->
2+|<<evaluator_specialpurpose>>
|

2+|
|<<evaluator_probealtarray>>
|`probealtarray()` compares special array object to probe stored in memory range and computes a match score.

2+|
|<<evaluator_synarc_decay>>
|`synarc.decay()` and `synarc.xdecay()` compute time-decayed arc values.



|===


[[evaluatoroverview]]
== Overview

VGX has a built-in evaluator engine for executing user-defined expressions. Custom formulas can be used in traversal filters (`filter=`), result ranking (`rank=`) and rendering of selected fields (`select=`). For example:

[source, python]
----
graph.Neighborhood(
    "Alice",
    filter  = "next.id in {'B*','*ch*'}",
    rank    = "next.arc.value / next['age']",
    select  = ".id; age",
    sortby  = S_RANK
)
----

The expression <<evaluatorsyntax, syntax>> supports <<syn_group, grouping>>, <<syn_group, nesting>>, <<syn_logicalcondition, logical operators>>, <<syn_comparison, comparison operators>>, <<syn_subscript, property lookup>>, <<_store, array indexing>>, membership tests for <<syn_memberofset, discrete>> and <<syn_innumericrange, continuous sets>>, and all the standard mathematical operators and <<evaluatorfunctions, functions>>. Expressions can be <<evaluatordefine, pre-defined>> and referenced by name in graph queries.

A comprehensive library of <<evaluatorfunctions, functions>>, <<evaluatorconstants, constants>> and <<evaluatorenvironment, environment variables>> is available for use in expressions.

It is possible to define and pass a <<evaluatormemory, memory array object>> to queries. Expressions evaluated as part of a query may then read or write elements of the memory array, opening up many possibilities for algorithm design. For instance, variables captured by a filter expression may be passed as input to a ranking expression. The same memory array object can be used by different queries enabling information sharing from one query to the next. Other uses include value aggregation, creating histograms, tracking graph cycles, and computing averages or deviations just to name a few.

Expressions can also be evaluated stand-alone using <<evaluate, `pyvgx.Graph.Evaluate()`>>. For example:
[source, python]
----
graph.Evaluate( "1+1" ) # -> 2
graph.Evaluate( "log( (2.1e3 + 4.5) * (pi - sin(6.7)) )" ) # -> 8.66...
----

=== Safe Evaluation

Due to the schemaless and dynamic nature of data values encountered during traversal the evaluator uses a best-effort approach when computing results. In general the evaluator will compute expressions "the way you intended." Where it deviates from many programming languages is in the lenient handling of operations on incompatible objects, zero division, domain errors, accessing non-existent properties, and out of range array indices.

It is impossible to write an expression that will crash, lock or leave the system in a corrupted state.

==== Incompatible Objects
Operations on incompatible objects will generally produce results as if the operations were not performed, which usually means keeping the leftmost operand. For example, `"'a string' + 2.5"` will produce `'a string'` and `"17.5 + 'a string' + 2.5"` will produce `20.0`.

==== Divide by Zero
The result of zero division is generally a "very large number". For example, `1/0` evaluates to `8.5e37`. This interpretation of zero division ensures formulas are computable even as divisors approach (and reach) zero. The divisor `-0.0` is an exception in that `1/-0.0` produces `-inf` and `0/-0.0` produces `nan`.

==== Domain Errors
Some mathematical functions accept arguments outside their defined domains. Roots of negative numbers produce zero (imaginary numbers are not supported.) Logarithms of zero or negative numbers produce a negative number which depends on the base. For example `sqrt(-1)` evaluates to 0, `log(0)` evaluates to -745.0 and `log2(-1)` evaluates to -1074.0. Computation involving roots and logarithms will always produce numeric results.

Other functions, such as the trigonometric functions, will produce `nan` for invalid arguments. For instance, `asin(2)` results in `nan` as does `sqrt(-1) + asin(2) + 5`.

==== Non-existent Vertex Properties
Lookup of a non-existent property will be processed as if the lookup did not take place. For example, if property _"x"_ does not exist then `1 + vertex['x'] + 2` evaluates to 3 and `5 / vertex['x']` evaluates to 5, even though `isnan( vertex['x'] )` yields `true`.

Following this logic, `cos( vertex['x'] )` is `nan` while both `0 + cos( vertex['x'] )` and `cos( 0 + vertex['x'] )` return 1.

Default values for non-existent properties can be obtained in two ways. The first method is <<_property, function `vertex.property( _"x"_, _default_ )`>> which returns property _"x"_ of current _tail_ (i.e. `vertex['x']`) if it exists, or _default_ if the property does not exist. The second method is <<_firstval, function `firstval()`>>, which is variadic (i.e. any number of arguments) and returns the leftmost argument that is not `nan`. For example, `firstval( vertex['x'], 2.5 )` returns 2.5 if property _"x"_ does not exist and `firstval( next['x'], asin(next['y']), pi/2 )` returns &#928;/2 if the two preceding arguments both produce `nan`.

NOTE: Substitute `next` or `prev` for `vertex` to access properties of the current _head_ or previous _tail_ when traversing arcs. E.g. `next.property( _x_ )` or `prev[ _x_ ]`.


==== Out of Range Subscripts
Operations involving array subscripts employ modulo indexing which guarantees safety. For example, if <<evaluatormemory>> is used and the memory array object has 128 slots `store(5, 100)`, `store(133, 100)`, and `store(-123, 100)` are equivalent; they all assign value `100` to memory location 5. The size of memory array objects is always a power of two. The last four slots are <<evaluatormemoryregisters, aliased with registers>> `R1`, `R2`, `R3` and `R4`. There is also a <<evaluatormemorystack, stack>> which grows downward starting at the slot just before the registers. It is the responsibility of the programmer to ensure algorithm correctness and avoid undesired modulo indexing or aliasing conflicts between array subscripts, registers, and stack.

[[evaluatordatatypes]]
=== Data Types

The evaluator engine can operate on objects of various types. If a function is called with an incompatible argument the result is generally the unprocessed argument, such as `sin('hello')` which simply returns `'hello'`.

Many operators and functions automatically adjust their behavior according to the argument types. For example, the function `hash()` produces a 64-bit integer hash of the argument, which can be of any type, but uses different algorithms depending on the type. (`hash( 123 )`, `hash( 'hello' )` and `hash( vector )` are all valid.)

The final result of an expression is interpreted according to the context where it appears. Filters are concerned with matching (positivity), ranking is concerned with numeric scores and select statements expect lists of objects to render.


[[datatypes]]
.Evaluator Data Types
[cols="2,2,4,2,5"]
|===
|Type |Positive Match |As Rank Score |Type Check |Description

|<<datatype_integer, _integer_>>
|> 0
|real( _self_ )
|<<_isint, isint()>>
|64-bit signed integer.

|<<datatype_real, _real_>>
|> 0.0
|_self_
|<<_isreal, isreal()>>
|64-bit (double precision) floating point.

|<<datatype_real, _string_>>
|true
|real( _first_5_bytes_as_int_ )
|<<_isstr, isstr()>>
|Text string or raw bytes. May appear as function argument or return value.

|<<datatype_group, _group_>>
|first item
|first item value
|
|Comma separated list of objects

|<<datatype_range, _range_>>
|(N/A)
|(N/A)
|
|Continuous set of numbers from _a_ to _b_ `range[a, b>` for use with the `in` and `notin` operators.

|<<datatype_set, _set_>>
|false
|0.0
|
|Discrete set of objects `{a, b, c, ...}` for use with the `in` and `notin` operators.

|<<datatype_vector, _vector_>>
|true
|real( _address_ )
|<<_isvector, isvector()>>
|Object of type <<../similarity/vector.adoc#, &#60;vector&#62;>>

|<<datatype_bitvector, _bitvector_>>
|!= 0
|real( _self_ )
|<<_isbitvector, isbitvector()>>
|64-bit unsigned integer for use with certain operations that handle bit masks and integers differently.

|<<datatype_keyval, _keyval_>>
|_value_ > 0.0
|_value_
|
|2-tuple (_key_, _value_) where _key_ is a 32-bit signed integer and _values_ is a single precision float.

|<<datatype_vertex, _vertex_>>
|true
|real( _address_ )
|
|Object of type <<../vertex/vertex.adoc#pyvgxvertex, pyvgx.Vertex>>

|<<datatype_vertexid, _vertexid_>>
|true
|real( _address_  )
|
|The identifier string of an object of type <<../vertex/vertex.adoc#pyvgxvertex, pyvgx.Vertex>>

|<<datatype_nan, _nan_>>
|false
|0.0
|<<_isnan, isnan()>>
|Not a number

|<<datatype_null, _null_>>
|false
|0.0
|
|No value

|<<datatype_inf, _inf_>>
|true
|0.0
|
|Infinity

|===


[[datatype_integer]]
==== Type _integer_

[source, python]
----
graph.Evaluate( "1000" )   # -> 1000
graph.Evaluate( "-1000" )  # -> -1000
graph.Evaluate( "01000" )  # -> 1000   leading zeros ignored
graph.Evaluate( "0x1000" ) # -> 4096   0x prefix for hexadecimal
graph.Evaluate( "0X1000" ) # -> 4096   0X also accepted
graph.Evaluate( "0xffffffffffffffff" ) # -> -1   2's complement
graph.Evaluate( "0xfffffffffffffffe" ) # -> -2   2's complement
----

[[datatype_real]]
==== Type _real_

[source, python]
----
graph.Evaluate( "3.14" )  # -> 3.14
graph.Evaluate( ".123" )  # -> 0.123
graph.Evaluate( "1e3" )   # -> 1000.0
graph.Evaluate( "-.1e1" ) # -> 1.0
----

[[datatype_string]]
==== Type _string_

[source, python]
----
graph.Evaluate( "'hello'" ) # -> 'hello'
----

[[datatype_group]]
==== Type _group_

[source, python]
----
graph.Evaluate( "(1,2,3,4)" ) # -> 1
graph.Evaluate( "('hello',2,3,4)" ) # -> 'hello'
----

[[datatype_range]]
==== Type _range_

[source, python]
----
graph.Evaluate( "0.999 in range(1,3)" ) # -> 0
graph.Evaluate( "1 in range(1,3)" ) # -> 1
graph.Evaluate( "2.999 in range(1,3)" ) # -> 1
graph.Evaluate( "3 in range(1,3)" ) # -> 0
----

[[datatype_set]]
==== Type _set_

[source, python]
----
graph.Evaluate( "{1, 2, 3}" ) # -> '<set>'
graph.Evaluate( "2 in {1, 2, 3}" ) # -> 1
graph.Evaluate( "2.999 in {1, 2, 3}" ) # -> 0
----

[[datatype_vector]]
==== Type _vector_

[source, python]
----
X = graph.NewVertex( "X" )
Y = graph.NewVertex( "Y" )
X.SetVector( [('a',1),('b',0.5),('c',0.25)] )
Y.SetVector( [('a',1),('b',0.75),('c',0.5)] )

E = graph.Evaluate

### Vector type
E( "next.vector", head="X" ) # -> '<vector>'

### Length
E( "len( next.vector )", head="X" ) # -> 3

### Magnitude
E( "asreal( next.vector )", head="X" ) # -> 1.14564394951

### Fingerprint
E( "hash( next.vector )", head="X" ) # -> -3579455383477239039

### Address
E( "int( next.vector )", head="X" ) # -> 2337927647264

### Element of
E( "'c' in next.vector", head="X" ) # -> 1
E( "'d' in next.vector", head="X" ) # -> 0

### Similarity
g.Evaluate( "sim( prev.vector, next.vector )", tail="X", head="Y" ) # -> 0.97265625
----

[[datatype_bitvector]]
==== Type _bitvector_

[source, python]
----
graph.Evaluate( "0b11110000" ) -> '<bitvector 0x00000000000000f0>'
----

[[datatype_keyval]]
==== Type _keyval_

[source, python]
----
graph.Evaluate( "keyval(1000,0.5)" ) # -> '<keyval (1000,0.5)>'

### Key
graph.Evaluate( "int( keyval(1000,0.5) )" ) # -> 1000

### Value
graph.Evaluate( "real( keyval(1000,0.5) )" ) # -> 0.5

----

[[datatype_vertex]]
==== Type _vertex_

[source, python]
----
V = graph.NewVertex( "Node1" )
V['x'] = 1000
graph.Connect( "Node1", "to", "X" )
graph.Connect( "Node1", "to", "Y" )

### Attribute
graph.Evaluate( "next.odeg", head=V ) -> 2
graph.Evaluate( "next.tmc", head=V ) -> 1642822680

### Internalid string
graph.Evaluate( "str(next)", head=V ) -> '42aa906a0037217e4bc4bcaafc11817e'

### Address
graph.Evaluate( "int( next )", head=V ) -> 2336660804768

### Property
graph.Evaluate( "int( next )", head=V ) -> 2336660804768
graph.Evaluate( "'x' in next", head=V ) -> 1
graph.Evaluate( "'y' in next", head=V ) -> 0
graph.Evaluate( "next['x']", head=V ) -> 1000
----

// cspell:ignore vertexid
[[datatype_vertexid]]
==== Type _vertexid_

[source, python]
----
V = graph.NewVertex( "Node1" )
graph.Evaluate( "next.id", head=V ) -> 'Node1'
hex(graph.Evaluate( "hash( next.id )", head=V )) -> '0x4bc4bcaafc11817e
----

[[datatype_nan]]
==== Type _nan_

[source, python]
----
graph.Evaluate( "nan" ) -> nan
graph.Evaluate( "acos(2)" ) -> nan  # domain error
graph.Evaluate( "acos(2) == nan" ) -> 1
graph.Evaluate( "1.8e308" ) -> nan  # out of range
----

[[datatype_null]]
==== Type _null_

[source, python]
----
graph.Evaluate( "null" )
graph.Evaluate( "isnan( null )" ) -> 1
----

[[datatype_inf]]
==== Type _inf_

[source, python]
----
graph.Evaluate( "inf" ) -> inf
graph.Evaluate( "1e300 * 1e300" ) -> inf
graph.Evaluate( "1e300 * 1e300 == inf" ) -> 1

### Infinity is considered numeric
graph.Evaluate( "isnan( inf )" ) -> 0

### NOTE: The expression language is designed to produce
###       numeric results even when infinity is involved
###       in the computation. Dividing by zero produces
###       "a very large number" and dividing by infinity
###       produces zero.
graph.Evaluate( "1/inf" ) -> 0.0
graph.Evaluate( "1**inf" ) -> 1.0
graph.Evaluate( "1.000001**inf" ) -> 1.7976931348623157e+308
graph.Evaluate( "0.999999**inf" ) -> 0.0
graph.Evaluate( "inf/inf" ) -> nan
graph.Evaluate( "inf-inf" ) -> nan
graph.Evaluate( "-1/-0.0" ) -> inf # Special case
graph.Evaluate( "-1/-0.0 == inf" ) -> 1
----


[[noshortcircuiting]]
=== No Short Circuiting
There are no short-circuit operators, leaving no doubt about which parts of expressions are evaluated: all sub-expressions within a complex expression are always executed.

For example `"1 > 2 && inc( R1 ) > 10"` will naturally always be `false` (due to `1 > 2` part), but will regardless execute `inc( R1 )`.

WARNING: This behavior is different from many programming languages, so beware.

Conditional execution requires explicit use of a conditional function. The above example may be rewritten to perform operations conditionally (also replacing `1 > 2` with the more useful `.arc.value > 2`), like this:

`"incif( .arc.value > 2, R1 ) && load( R1 ) > 10"`. Here the value in register `R1` is only incremented when `.arc.value > 2` and the entire expression evaluates to true after 11 iterations where the `.arc.value` condition was met.

<<filtercaution, Be careful when writing filters>> to avoid unintended overhead in computation and memory access.

There are exactly two exceptions to the no short-circuiting execution policy. The functions <<_return, `return()`>> and <<_returnif, `returnif()`>> can be placed within an expression to terminate execution at that point in the expression.

=== Expression Examples

Suppose we have created a graph with relationships between friends. The following examples show how we can filter, rank results and select fields to return.

==== Filter Example

.Find Alice's friends and pets
[source, python]
----
graph.Neighborhood(
    "Alice",
    filter  = "( .arc.type in {'friend','knows','likes'} && .type == 'person' ) || ( .arc.type == 'owns' && .type = 'pet' )"
)
----

Here we use `filter=` to match three different relationships ("friend", "knows", or "likes") using the `in { ... }` set operator and combine sub-expressions with boolean operators `&&` and `||`.

TIP: Complex matching logic like this is not possible using `arc=` and `neighbor=` parameters alone. However, in many cases it may be more efficient to also include `arc=` and `neighbor=` in the query, since they may help reduce the amount of processing performed by the expression evaluator by early termination of non-matching filters.

==== Dynamic Ranking Example

.Boost Alice's friends
[source, python]
----
graph.Neighborhood(
    "Alice",
    sortby = S_RANK,
    rank   = ".arc.value * ( 1 + 9 * (.arc.type == 'friend')) / next.deg"
)
----

Here we use `rank=` to specify a custom scoring function. To use the computed scores for sorting results we must also specify `sortby=S_RANK`. In this example results are ordered according to arc values divided by neighbor's degree, boosting relationships of type 'friend' by a factor 10.

==== Select Result Fields Example

.Include selected and computed properties in result
[source, python]
----
graph.Neighborhood(
    "Alice",
    select = "age; address; SCORE1: .arc.value / (1 + log( next.odeg / next.ideg )); LABEL1: hash( next.id )"
)
----

The select statement specifies a semicolon-separated list of items to return. Items can be attributes, vertex properties, or computed values identified by labels. If the item is a single token it is interpreted as a vertex property key, unless it starts with a period `"."` which is interpreted as an attribute (such as `".id"` which is short for `"next.id"`).

When the item is a labeled expression `"label : ..."` any valid expression can be specified to dynamically compute values. The computed values will be identifiable in the result by their labels.

This example includes Alice's neighbors' age, address, some computed number identified by label SCORE1, and another computed value identified by LABEL1.

[[evaluatorreference]]
== Expression Language Reference

Expressions are constructed using syntax similar to many programming languages, and offer a wide variety of built-in function. The following sections summarize all available symbols, functions and constructs.

Expressions are available to use in query parameters `filter=`, `rank=` and `select=`.

[[evaluatordefine]]
=== Define Functions with `Define()`

An expression may be defined and stored in the graph for future use.

==== Syntax

`*pyvgx.Graph.Define*( _expression_ )`::
Create a new function formula that can be used by queries for filtering and ranking. The _expression_ parameter is a string of the form `<name> := <formula>`.

==== Parameters

[cols="2,2,5"]
|===
|Parameter |Type |Description

|_expression_
|_str_
|Expression definition of the form `<name> := <formula>` where _<formula>_ is any valid evaluator expression and _<name>_ is a label which is used later by queries to invoke the formula.

|===

==== Return Value

This method does not return anything.

==== Remarks

Pre-defined expressions are stored in the graph object on which the Define() method was invoked. Expressions defined for a graph instance are exclusive to that instance and cannot be referenced by other graphs.

It is recommended to pre-define complex functions before using them in queries since parsing and compiling occur only when the expression is defined. Eliminating this overhead may help speed up query execution, and in cases where the same expression is used by multiple queries it is easier to maintain consistent functionality.

IMPORTANT: Make sure <<../reference.adoc#graphobject_enummethods, type enumerations>> exist for all arc relationship types and vertex types that appear in the expression _before_ the expression is defined. Otherwise the expression will not be correctly evaluated. 

[[evaluate]]
=== Evaluate Expressions with `Evaluate()`

An expression may be evaluated outside the context of a query for testing or for operations that do not require a graph query.

==== Syntax

`*pyvgx.Graph.Evaluate*( _expression_**[**, _tail_**[**, _arc_**[**, _head_**[**, _vector_**[**, _memory_ **]]]]]** )`::
Execute the _expression_, which is a string defining a new formula, or referencing a pre-defined formula. The optional parameters are used to supply information that may be referenced in the formula.

==== Parameters

[cols="2,3,2,5"]
|===
|Parameter |Type |Default |Description

|_expression_
|_str_
|
|Expression to be evaluated

|_tail_
|_str_ or <<../vertex/vertex.adoc#pyvgxvertex, pyvgx.Vertex>>
|None
|Vertex whose attributes and properties may be accessed via the various <<vertexattributes, `vertex*` references>>.

|_arc_
|<<../specification/arcSpecificationSyntax.adoc#arcspecificationsyntax, Relationship specifier>>
|()
|Arc whose attributes may be accessed via the various <<arcattributes, `next.arc*` references>>.

|_head_
|_str_ or <<../vertex/vertex.adoc#pyvgxvertex, pyvgx.Vertex>>
|None
|Vertex whose attributes and properties may be accessed via the various <<vertexattributes, `next*` references>>.

|_vector_
|<<../similarity/vector.adoc#, &#60;vector&#62;>> or Python list
|[]
|Similarity vector which may be accessed via the <<_vector, `vector` reference>>.

|_memory_
|<<evaluatormemory, pyvgx.Memory>> or _int_
|4
|Memory array object which may be accessed using the various <<evaluatormemoryreference, memory operations>>.

|===

==== Return Value

This method returns the result of the evaluation, which may be an integer, a floating point object (including `nan` or `inf`), a string, or other object.

==== Remarks

This method is useful for experimenting with expressions before using them with queries. It can also be used for pre/post processing memory arrays outside the context of a query. For example, if a query was used to gather information into a memory array object this method can then be used to access and further process that information.

All processing within the evaluator occurs outside the Python interpreter, allowing for multi-threaded operation and in some cases more efficient single-threaded processing. For instance, running <<_msum, `*msum()*`>> on a large memory array of 100,000,000 floating point numbers is about 5 times faster than Python's native sum() function on an equivalent Python array. Moreover, running <<_mradd, `*mradd()*`>> on the same memory array is about 50 times faster than performing the equivalent operation in a pure Python loop.

[[evaluatorsyntax]]
=== Basic Expression Syntax

Expressions are evaluated according to operator precedence and associativity, as commonly used in most programming languages. The table below summarizes the syntax rules.

.Symbolic Operators
[cols="2,4,5,2"]
|===
|Precedence| Operator |Description |Associativity

|1
|`(` `)` [[_opgroup]]
 +
`{` `}` [[_opset]]
|Group (parentheses)
 +
Set
|Left-to-right

|2
|`()` [[_opcall]]
 +
`[]` [[_opsubscript]]
 +
`.`
|Function call
 +
Subscript (property)
 +
Attribute
|Left-to-right

|3
|`+` [[_opunaryplus]]
 +
`-` [[_opunaryminus]]
 +
`!` [[_oplogicalnot]]
 +
`~` [[_opbitwisenot]]
 +
`+**+` [[_opexponentiation]]
|Unary plus
 +
Unary minus
 +
Logical NOT
 +
Bitwise NOT (one's complement)
 +
Exponentiation
|Right-to-left

|4
|`in range(...)` [[_opinrange]]
 +
`notin range(...)` [[_opnotinrange]]
 +
`in { ... }` [[_opinset]]
 +
`notin { ... }` [[_opnotinset]]
|In numeric range
 +
Not in numeric range
 +
Is element of set
 +
Is not element of set
|Left-to-right

|5
|`+*+` [[_opmultiplication]]
 +
`/` [[_opdivision]]
 +
`%` [[_opmodulo]]
|Multiplication
 +
Division
 +
Modulo (remainder)
|Left-to-right

|6
|`+` [[_opaddition]]
 +
`-` [[_opsubtraction]]
|Addition
 +
Subtraction
|

|7
|`<<` [[_opleftshift]]
 +
`>>` [[_oprightshift]]
|Bitwise left shift
 +
Bitwise right shift
|Left-to-right

|8
|`<` [[_oplessthan]]
 +
`+<=+` [[_oplessthanequal]]
 +
`>` [[_opgreaterthan]]
 +
`>=` [[_opgreaterthanequal]]
|Less than
 +
Less than or equal to
 +
Greater than
 +
Greater than or equal to
|Left-to-right

|9
|`==` [[_opequal]]
 +
`!=` [[_opnotequal]]
|Equal to
 +
Not equal to
|Left-to-right

|10
|`&` [[_opbitwiseand]]
|Bitwise AND
|Left-to-right

|11
|`^` [[_opbitwisexor]]
|Bitwise XOR
|Left-to-right

|12
|`\|` [[_opbitwiseor]]
|Bitwise OR
|Left-to-right

|13
|`&&` [[_oplogicaland]]
|Logical AND
|Left-to-right

|14
|`\|\|` [[_oplogicalor]]
|Logical OR
|Left-to-right

|15
|`?:` [[_opternaryconditional]]
|Ternary conditional
|Right-to-left

|16
|`:=` [[_opdefine]]
 +
 `=` [[_opvarassign]]
|Expression definition
 +
 Variable assignment
|Right-to-left

|17
|`:` [[_oplabel]]
|Label (`select=` only)
|Right-to-left

|18
|`,` [[_opcomma]]
 +
 `;` [[_opsemicolon]]
|Comma
 +
 Semicolon
|Left-to-right

|===

[[syn_group]]
==== Group

Operations may be enclosed in parentheses `(` `)` to override default precedence rules. Groups may be nested to construct any mathematical formula or logical expression. Nesting is unlimited.

[source, python]
----
1 / ( ( 2 + 3 ) * ( 4 + 5 ) )                   -> 0.02222...
----

A group can also be used to perform one or more "hidden" operations needed for their side-effects. When multiple expressions separated by comma `,` appear within the group only the value of the first expression becomes the value of the group. All subsequent expressions are evaluated but their return values are discarded.

[source, python]
----
( 1, 2, 3 ) + ( 1.5, 2.5, 3.5 )                 -> 2.5
10 * ( 2, store( R1, pi ) )                     -> 20
4 ** 3 - 2 + 1                                  -> 63
4 ** (3 - 2) + 1                                -> 5
4 ** 3 - (2 + 1)                                -> 61
4 ** (3 - 2 + 1)                                -> 16
----

[[syn_set]]
==== Set

A set of discrete numbers or objects is created by placing them within braces `{` `}`, items separated by commas `,`.

[source, python]
----
{ 3, 4, 5, 'hello', 6.7 }
----

[[syn_functioncall]]
==== Function Call

A pair of parentheses `(...)` with optional comma `,` separated arguments is interpreted as a function call when the preceding token is a string.

[source, python]
----
random()
log( 1.23 )
mmul( 0, 31, pi )
----

[[syn_subscript]]
==== Subscript

A literal string `_'s'_` within a pair of brackets `[ _'s'_ ]` denotes a property lookup when the preceding token is a vertex object. Properties are readonly.

[source, python]
----
vertex[ 'prop1' ]
next[ 'value' ]
----

[[syn_attribute]]
==== Attribute

The dot `.` operator is used to access vertex attributes, arc attributes and various context information. Attributes are readonly.

[source, python]
----
vertex.id
next.arc.value
graph.size
----

[[syn_unaryplusminus]]
==== Unary Plus/Minus

Unary plus `+` and minus `&#8722;` set the sign of a numeric value.

[source, python]
----
-1                      -> -1
-(+2 - +5)              -> 3
-7+-1--8                -> 0
----

[[syn_logicalnot]]
==== Logical NOT

The exclamation point `!` negates a logical value.

[source, python]
----
!0                      -> 1
!1                      -> 0
!2                      -> 0
!( true || false )      -> 0
!( !true || false )     -> 1
----

[[syn_bitwisenot]]
==== Bitwise NOT

A tilde `~` denotes one's complement of a numeric value, i.e. all bits are inverted.

[source, python]
----
~0                      -> -1
~1                      -> -2
~0xffffffffffffffff     -> 0
----

[[syn_exponentiation]]
==== Exponentiation

A pair of infix asterisks `**` raises a number to the power of another number.

[source, python]
----
16 ** 2                 -> 256
100.0 ** 0.5            -> 10.0
e ** -0.1               -> 0.9048...
----

[[syn_innumericrange]]
==== In Numeric Range

The `in` and `notin` operators followed by `range( _a_, _b_ )` express the numeric range conditions &#8712; [ _a_, _b_ > and &#8713; [ _a_, _b_ >, respectively.

[source, python]
----
5 in range( 2, 6 )          -> true
5 in range( 2, 5 )          -> false
pi in range( 3.1, 3.2 )     -> true
10 notin range( 1, 5 )      -> true
----

[[syn_memberofset]]
==== Member of Set

The `in` and `notin` operators followed by set `{ _x~1~_, _x~2~_, ..., _x~n~_ }` express the discrete set membership conditions &#8712; { _x~1~_, _x~2~_, ..., _x~n~_ } and &#8713; { _x~1~_, _x~2~_, ..., _x~n~_ }, respectively.

[source, python]
----
5 in { 9, 5, 'cat', 'dog' }                 -> true
4 in { 9, 5, 'cat', 'dog' }                 -> false
'cat' in { 9, 5, 'cat', 'dog' }             -> true
'mouse' notin { 9, 5, 'cat', 'dog' }        -> true
'mouse' in { '*ous*', 'm*e' }               -> true
'mice' in { '*ous*', 'm*e' }                -> true
----

[[syn_multiplication]]
==== Multiplication

Infix `*` multiplies two numbers.

[source, python]
----
2 * 3           -> 6
2 * pi          -> 6.28...
----

[[syn_division]]
==== Division

Infix `/` divides a number by another.

[source, python]
----
15 / 3              -> 5
16 / 3              -> 5.33...
3.14 / pi           -> 0.999...
1 / 0               -> 8.51e37
1 / -0.0            -> -inf
----

IMPORTANT: When integer division has a remainder the result is promoted to floating point. Zero division results in a large floating point value except for the special case divisor -0.0 which produces `-inf`.

[[syn_modulo]]
==== Modulo

Infix `%` yields the remainder after dividing two numbers.

[source, python]
----
15 % 3              -> 0
16 % 3              -> 1
3.14 % pi           -> 3.14
6.2 % pi            -> 3.06...
1 % 0               -> 0
1.1 % 0             -> 1.18e-38
1 % -0.0            -> nan
----

IMPORTANT: Modulo zero results in 0 (or very close to 0) except for the special case divisor -0.0 which produces `nan`.

[[syn_addition]]
==== Addition

Infix `+` adds two numbers or concatenates a string with another object implicitly cast to string.

[source, python]
----
1 + 1               -> 2
pi + e              -> 5.8599...
'x' + 'y'           -> "xy"
'x' + pi            -> "x3.14159"
----

[[syn_subtraction]]
==== Subtraction

Infix `-` subtracts a number from another.

[source, python]
----
1 - 2               -> -1
pi - e              -> 0.42331...
----

[[syn_bitwiseshift]]
==== Bitwise Shift

Infix `<<` and `>>` perform left and right bit shift, respectively, of the integer representation of the left operand by the amount specified by the right operand. Bits are not rotated, i.e. once bits are shifted off the left or right edge they are discarded.

[source, python]
----
1 << 10             -> 1024
1.9 << 10           -> 1024
1.9 << 10.0         -> 1.9
0xff >> 5           -> 7
0xff >> 40          -> 0
----

NOTE: If the right operand is not an integer the shift operation is not performed.

[[syn_comparison]]
==== Comparison

The infix comparison operators `==`, `!=`, `>`, `>=`, `<`, `\<=` compare the left and right operands yielding true or false. Operands may be numbers, strings, vertices or vectors.

[source, python]
----
'hello' == '*llo'           -> true
'cat' != 'dog'              -> true
5 > 4                       -> true
5 >= 5.0                    -> true
5.0 < 4.5                   -> false
5 <= 4.9999999              -> false
5 == 4.9999999              -> true
----

IMPORTANT: Two floating point values compare equal when their difference is smaller than approximately 1.1921e-7. This affects `==` and `!=`, but not `>=` and `\<=`.

[[syn_bitwiselogic]]
==== Bitwise Logic

Infix operators `&`, `|` and `^` perform bitwise AND, OR and XOR, respectively, on their left and right operands.

[source, python]
----
0xf0 & 0x3c                 -> 0x30
0xf0 | 0x3c                 -> 0xfc
0xf0 ^ 0x3c                 -> 0xcc
----

[[syn_logicalcondition]]
==== Logical Condition

Infix conditional operators `&&` and `||` apply the logical conditions AND and OR, respectively, to their left and right operands.

[source, python]
----
1 == 2 && 2 > 1             -> false
1 == 2 || 2 > 1             -> true
1 == 2 && store( R1, 777 )  -> false   (777 still stored in R1)
----

IMPORTANT: Logical short circuiting is not applied. All parts of an expression are always evaluated regardless of whether or not they contribute to the overall result of the expression.

[[syn_ternaryconditional]]
==== Ternary Conditional

The infix `?:` operator selects the second or third operand depending on the value of the first operand.

[source, python]
----
1 < 2 ? 3 + 4 : 5 + 6                      -> 7
1 > 2 ? 3 + 4 : 5 + 6                      -> 11
1 < 2 ? store( R1, 33 ) : store( R1, 44 )  -> 33  (R1 contains 44)
1 > 2 ? store( R1, 33 ) : store( R1, 44 )  -> 44  (R1 contains 44)
----

IMPORTANT: Logical short circuiting is not applied. All operations are completely evaluated, left to right, regardless of condition.

[[syn_define]]
==== Expression definition

The assignment operator `:=` associates a <<evaluatordefine, definition>> with a name that can be referenced later to invoke the expression. Expressions are normally assigned to names using `pyvgx.Graph.Define()`. However, it is also possible to dynamically assign expressions to names during query execution and then reference those names in other parts of the same query.

[source, python]
----
func := next['score'] / (10 * .arc.value)
quad := load( R2 ) ** 2 + load( R1 ) + vertex['offset']
----

NOTE: Each graph instance has its own expression name scope and expressions cannot be shared between separate graph instances. Assigning an expression to a name will overwrite any previous assignment to that name.

[[syn_subexpr]]
==== Sub-expressions and Local Variables

An expression may contain one or more independent sub-expressions separated by semicolons `;`. The last sub-expression determines the value of the overall expression. It is optional to terminate the last expression with a semicolon.

It is possible to assign the result of a sub-expression to a local variable. The scope of such a variable extends from the point of assignment until the end of the expression. Variable assignment uses the `=` operator, and must appear directly after the variable name at the start of a sub-expression. Variable names can be freely chosen so long as they conform to <<../limits.adoc#property_key, valid key>> syntax and do not conflict with pre-defined names or functions like `pi`, `e`, `next`, `sqrt`, etc.

[source, python]
----
1; 5 + log(10); 2.5;                          -> 2.5
store(R1, 7); 3 + load( R1 );                 -> 10
a = 2*pi; b = rad(360); a / b;                -> 1.0
pi = 3.14;    ==>    Syntax Error: invalid variable assignment
----

NOTE: Variable scope is local to the current evaluation of the expression. Once the last sub-expression has completed and returned its result all variables go out of scope. Use <<evaluatormemory>> for global scope and to transfer data between different expressions or repeated evaluations of the same expression.

[[syn_label]]
==== Label

The label operator `:` is exclusive to <<selectEvaluator.adoc#selectlabel, select statements>>, allowing processing of rendered result values to take place and making those values identifiable by the label.

[source, python]
----
val1: 1 / .arc.value; val2: next['score'] & 0xFFFF; val3: graph.ts
----

NOTE: This syntax is only available in `select=` and the expression cannot be pre-defined.

[[syn_comma]]
==== Comma

The comma `,` is used to separate multiple objects such as function arguments, set members, and group elements.

[source, python]
----
max( next['score'], vertex['score'] )
next.id in { 'Alice', '*lie', 'B*' }
( .arc.value, inc( R1 ) ) * firstval( next['score'], 1.0 )
x = next['score'] * pi, y = 1 / .arc.value
----

[[syn_semicolon]]
==== Semicolon

The semicolon `;` is used to terminate sub-expressions within a larger expression, and to separate fields or labeled expressions in `select=` statements.

[source, python]
----
/* Sub-Expression */
x = next['score'] / next.degree; y = log(x) + x/2; z = log2( y * x );

/* Select Statement */
.id; .arc.value; SCORE: next['score'] / 100.0; .degree
----


[[evaluatorattrprop]]
=== Attributes and Properties

Expressions may read information stored in arcs and vertices. Which arc or vertex is currently in scope for the evaluator depends on the query and how the graph is traversed.

NOTE: Attributes and properties refer to two different classes of information associated with an object in the graph. An _attribute_ is a built-in piece of information such as the arc type, arc value, vertex type, vertex degree, etc. A _property_ is a custom key/value pair assigned to a vertex.

[[evaluatorneighborhoodnext]]
==== Neighborhood: `next*`
Attributes named `next*` refer to arcs ("Current Arc" column in <<arcattributes>>) that are traversed to reach the current anchor's neighborhood, or to the contents of those neighbors ("Head" column in <<vertexattributes>> and <<vertexproperties>>.)

When the attribute prefix is omitted it defaults to `next`. For example, `.arc.value` is equivalent to `next.arc.value` and `.id` is equivalent to `next.id`.

IMPORTANT: *When used in `select=` the `next` prefix must be omitted*, otherwise the field is interpreted as a vertex property.
  +
  +
  For example, `select=".arc.value; .id; next.degree"` would interpret `next.degree` as a property of that name (i.e. `next[ "next.degree" ]`.) This is because the simplified `select=` syntax allows a list of field names to be specified, where anything starting with a period `.` is an attribute and everything else is a property.
  +
  +
  Labeled items in the select list are not subject to this restriction. For example, `select=".arc.value; .id; DEG : next.degree"` would evaluate `next.degree` as the vertex degree attribute and identify its value with the label "DEG" in the result.

[[evaluatorneighborhoodprev]]
==== Previous neighborhood: `prev*`
Attributes named `prev*` refer back to the arc ("Previous Arc" column in <<arcattributes>>) that was traversed to reach the current anchor, or to the contents of that arc's initial vertex ("Previous Tail" column in <<vertexattributes>> and <<vertexproperties>>.)

[[evaluatorcurrentvertex]]
==== Current anchor: `vertex*`
Attributes names `vertex*` reference the current anchor ("Tail" column in <<vertexattributes>> and <<vertexproperties>>.)

==== Example

[source, python]
----
graph.Neighborhood(
    "Alice",
    filter      = "next.arc.type == 'knows' && next['age'] >= 21"
    neighbor    = {
        'arc'       : D_OUT
        'filter'    : "prev.arc.value < next.arc.value"
    }
)
----

This query asks for all neighbors that Alice has a "knows" relationship to, whose age is at least 21 and also have connections to other neighbors that are stronger than Alice's connection to them. (I.e Alice's adult friends with better friends.)

Here `"Alice"` is the current anchor, `next.arc.type` is the relationship type of the arc from Alice to her neighbors, `next['age']` is a property of Alice's neighbors, `prev.arc.value` is the value of the arc from Alice to one of her neighbors, and `next.arc.value` is the value of the arc from one of her neighbors to their neighbors. Notice how in this example `next.arc.type` and `next.arc.value` reference different sets of arcs because they appear in two different expressions with different contexts.

[[arcattributes]]
==== Arc Attributes

[cols="3,3,2,5"]
|===
|Previous Arc |Current Arc |Type |Description

|`prev.arc.type` [[_prevarctype]]
|`next.arc.type` [[_nextarctype]]
 +
`.arc.type`
|_int_
|Relationship type enumeration

|`prev.arc.dir` [[_prevarcdir]]
|`next.arc.dir` [[_nextarcdir]]
 +
`.arc.dir`
|_int_ (<<../constants/arcDirectionConstants.adoc#, D_*>>)
|Relationship direction

|`prev.arc.mod` [[_prevarcmod]]
|`next.arc.mod` [[_nextarcmod]]
 +
`.arc.mod`
|_int_ (<<../constants/arcModifierConstants.adoc#, M_*>>)
|Relationship value modifier

|`prev.arc.value` [[_prevarcvalue]]
|`next.arc.value` [[_nextarcvalue]]
 +
`.arc.value`
|_int_ or _float_
|Relationship value

|`prev.arc.dist` [[_prevarcdist]]
|`next.arc.dist` [[_nextarcdist]]
 +
`.arc.dist`
|_int_
|Arc head's distance from original query anchor vertex

|`prev.arc.issyn` [[_prevarcissyn]]
|`next.arc.issyn` [[_nextarcissyn]]
 +
 `.arc.issyn`
|_bool_
|Value is `true` if arc is a synthetic arc or `false` if arc is explicit. Explicit arcs are normal graph arcs. Synthetic arcs are produced as temporary arguments to expressions evaluated outside of arc traversal context.

|`prev.arc.isfwd` [[_prevarcisfwd]]
|`next.arc.isfwd` [[_nextarcisfwd]]
 +
 `.arc.isfwd`
|_bool_
|Value is `true` if arc is a <<../constants/arcModifierConstants.adoc#M_FWDONLY, forward-only arc>>, or `false` otherwise.



|===

NOTE: References to `prev.arc*` have meaning only when evaluated in a context where a traversal has already taken place. All `prev.arc*` attributes will be zero otherwise.

NOTE: Expressions involving arc type equality checks may specify integer enumerations or string literals as the comparison operand. String literals are implicitly encoded as relationship type enumerations in this context. E.g. `.arc.type == 'likes'` is equivalent to `.arc.type == relenc( 'likes' )`. Note, however, that implicit encoding applies to string literals only. If the string operand is the result of a vertex property lookup it must be explicitly encoded for the match to work. E.g. `.arc.type == vertex['relstr']` should instead be written as `.arc.type == relenc( vertex['relstr'] )`.

IMPORTANT: Wildcards are not supported in relationship type string literals. E.g. `.arc.type == '\*'` and `.arc.type == 'fr*'` are always false.

.Example: Alice's close relationships
[source, python]
----
graph.Neighborhood(
    "Alice",
    filter    = ".arc.type in { 'friend', 'knows', 'likes' }",
    neighbor  = {
        'arc'    : D_IN,
        'filter' : "prev.arc.type == 'friend' || prev.arc.value > 100"
    }
)
----

[[vertexattributes]]
==== Vertex Attributes

[cols="4,4,4,2,6"]
|===
|Tail (vertex)|Head (next)|Previous(prev) |Type |Description

|`vertex` [[_vertex]]
|`next` [[_next]]
|`prev` [[_prev]]
|_int_
|Vertex object, interpreted as the vertex address (integer) when used in mathematical expressions

|`vertex.id` [[_vertexid]]
|`next.id` [[_nextid]]
 +
`.id`
|`prev.id` [[_previd]]
|_vertexid_
|Vertex identifier

|`vertex.internalid` [[_vertexinternalid]]
|`next.internalid` [[_nextinternalid]]
 +
`.internalid`
|`prev.internalid` [[_previnternalid]]
|_vertex_
|Vertex instance

|`vertex.type` [[_vertextype]]
|`next.type` [[_nexttype]]
 +
`.type`
|`prev.type` [[_prevtype]]
|_int_
|Vertex type enumeration

|`vertex.deg` [[_vertexdeg]]
|`next.deg` [[_nextdeg]]
 +
`.deg`
|`prev.deg` [[_prevdeg]]
|_int_
|Vertex degree

|`vertex.ideg` [[_vertexideg]]
|`next.ideg` [[_nextideg]]
 +
`.ideg`
|`prev.ideg` [[_prevideg]]
|_int_
|Vertex indegree

|`vertex.odeg` [[_vertexodeg]]
|`next.odeg` [[_nextodeg]]
 +
`.odeg`
|`prev.odeg` [[_prevodeg]]
|_int_
|Vertex outdegree

|`vertex.vector` [[_vertexvector]]
|`next.vector` [[_nextvector]]
 +
`.vector`
|`prev.vector` [[_prevvector]]
|<<../similarity/vector.adoc#, _vector_>>
|Vertex similarity vector

|`vertex.tmc` [[_vertextmc]]
|`next.tmc` [[_nexttmc]]
 +
`.tmc`
|`prev.tmc` [[_prevtmc]]
|_int_
|Vertex <<../vertex/vertexMembers.adoc#vertexTMC, creation time>>.

|`vertex.tmm` [[_vertextmm]]
|`next.tmm` [[_nexttmm]]
 +
`.tmm`
|`prev.tmm` [[_prevtmm]]
|_int_
|Vertex <<../vertex/vertexMembers.adoc#vertexTMM, modification time>>.

|`vertex.tmx` [[_vertextmx]]
|`next.tmx` [[_nexttmx]]
 +
`.tmx`
|`prev.tmx` [[_prevtmx]]
|_int_
|Vertex <<../vertex/vertexMembers.adoc#vertexTMX, expiration time>>.

|`vertex.c1` [[_vertexc1]]
|`next.c1` [[_nextc1]]
 +
`.c1`
|`prev.c1` [[_prevc1]]
|_float_
|Vertex dynamic rank score <<../vertex/vertexRank.adoc#vertexgetrank, 1^st^ order coefficient>>.

|`vertex.c0` [[_vertexc0]]
|`next.c0` [[_nextc0]]
 +
`.c0`
|`prev.c0` [[_prevc0]]
|_float_
|Vertex dynamic rank score <<../vertex/vertexRank.adoc#vertexgetrank, 0^th^ order coefficient>>.

|`vertex.virtual` [[_vertexvirtual]]
|`next.virtual` [[_nextvirtual]]
 +
`.virtual`
|`prev.virtual` [[_prevvirtual]]
|_int_
|`1` if vertex is virtual, `0` if vertex is real

|`vertex.locked` [[_vertexlocked]]
|`next.locked` [[_nextlocked]]
 +
`.locked`
|`prev.locked` [[_prevlocked]]
|_int_
|True when vertex is locked writable by another thread

|`vertex.address` [[_vertexaddress]]
|`next.address` [[_nextaddress]]
 +
`.address`
|`prev.address` [[_prevaddress]]
|_int_
|Vertex memory address

|`vertex.index` [[_vertexindex]]
|`next.index` [[_nextindex]]
 +
`.index`
|`prev.index` [[_previndex]]
|_int_
|Vertex object location index based on its memory address

|`vertex.bitindex` [[_vertexbitindex]]
|`next.bitindex` [[_nextbitindex]]
 +
`.bitindex`
|`prev.bitindex` [[_prevbitindex]]
|_int_
|Vertex bitvector quadword offset

|`vertex.bitvector` [[_vertexbitvector]]
|`next.bitvector` [[_nextbitvector]]
 +
`.bitvector`
|`prev.bitvector` [[_prevbitvector]]
|_bitvector_
|Vertex bitvector quadword

|`vertex.op` [[_vertexop]]
|`next.op` [[_nextop]]
 +
`.op`
|`prev.op` [[_prevop]]
|_int_
|Operation id of the last modifying graph operation for this vertex.

|`vertex.refc` [[_vertexrefc]]
|`next.refc` [[_nextrefc]]
 +
`.refc`
|`prev.refc` [[_prevrefc]]
|_int_
|Vertex object reference count

|`vertex.bidx` [[_vertexbidx]]
|`next.bidx` [[_nextbidx]]
 +
`.bidx`
|`prev.bidx` [[_prevbidx]]
|_int_
|Vertex object allocator block index

|`vertex.oidx` [[_vertexoidx]]
|`next.oidx` [[_nextoidx]]
 +
`.oidx`
|`prev.oidx` [[_prevoidx]]
|_int_
|Vertex object allocator block offset

|`vertex.handle` [[_vertexhandle]]
|`next.handle` [[_nexthandle]]
 +
`.handle`
|`prev.handle` [[_prevhandle]]
|_int_
|Numeric vertex identifier (process independent) with 42 significant bits, in the range 2199023255552 - 3298534883327.

|`vertex.enum` [[_vertexenum]]
|`next.enum` [[_nextenum]]
 +
`.enum`
|`prev.enum` [[_prevenum]]
|_int_
|Numeric vertex identifier (process independent) with 31 significant bits, in the range 0 - 2147483647. (May evaluate to -1 in large graphs, if so use .handle)

|===

NOTE: References to `prev*` have meaning only when evaluated in a context where a traversal has already taken place. All `prev*` attributes are undefined otherwise.

.Example: Alice's well-connected friends with first initial "B"
[source, python]
----
graph.Neighborhood(
    "Alice",
    arc       = ("friend", D_OUT),
    filter    = "next.deg > 100 || next.ideg > 70",
    neighbor  = {
        'filter'   : "vertex.id == 'B*'"
    }
)
----

[[vertexproperties]]
==== Vertex Properties
[cols="2,2,2,4"]
|===
|Tail (vertex) |Head (next) |Previous (prev) |Description

|`vertex.propcount` [[_vertexpropcount]]
|`next.propcount` [[_nextpropcount]]
 +
 `.propcount`
|`prev.propcount` [[_prevpropcount]]
|Number of vertex properties 

|`vertex[ _key_ ]` [[_vertexkey]]
|`next[ _key_ ]` [[_nextkey]]
|`prev[ _key_ ]` [[_prevkey]]
|Value of vertex property _key_ if it exists. The default value is 0 when property lookup 
occurs within arithmetic expressions. The default value is `nan` in all other contexts.

|`vertex.property( key[, default[, condition]] )`
|`next.property( key[, default[, condition]] )` 
 +
 `.property( key[, default[, condition]] )` 
|`prev.property( key[, default[, condition]] )`
|Same as subscript syntax when only _key_ is given. If specified, _default_ value is produced when property does not exist. If _condition_ is also specified the lookup takes place only if condition is true, otherwise _default_ is produced.

|===

NOTE: Accessing `prev[ _key_ ]` or `prev.property( _key_, ... )` has meaning only when evaluated in a context where a traversal has already taken place. The lookup will always return `nan` otherwise.

.Example: Alice's well-connected friends who are 20 - 29 years old
[source, python]
----
graph.Neighborhood(
    "Alice",
    arc       = ("friend", D_OUT),
    filter    = "next.deg > 100 || next.ideg > 70",
    neighbor  = {
        'filter'   : "vertex['age'] in range( 20, 30 )"
    }
)
----

[[filtercaution]]
CAUTION: Be careful when writing filters that involve access to head vertex attributes or properties. There is a significant performance penalty when dereferencing a vertex object, especially when traversing large neighborhoods. Even if your filter includes a condition on the arc designed to reduce the number of candidates the <<noshortcircuiting, entire expression is still evaluated>> leading to unnecessary overhead.
  +
  +
  The problem is easily avoided by splitting the expression into separate filters and using the `arc=(...)` and `neighbor={...}` parameters, ensuring that expensive operations are only executed after passing less expensive filters. As a rule, avoid mixing quick conditions with expensive conditions within the same filter. Arc conditions and current vertex attribute conditions are quick. Head vertex conditions are expensive, especially when property lookup is involved.
  +
  +
  As in the example above, the arc condition is placed in the `arc=` parameter and therefore evaluated first, avoiding premature execution of `next.deg > 100 || next.ideg > 70`. Furthermore, the property condition `vertex['age'] in range( 20, 30 )` is deferred until the very last by placing it in a separate filter within `neighbor={...}`.

TIP: Since vertex properties are costly to store and reference, in some cases you may consider using the general purpose <<../vertex/vertexMembers.adoc#vertexrankc0, c0 and c1>> numeric attributes. Although primarily intended for use with certain <<simplerankingfunctions, dynamic ranking>> functions, you are free to "abuse" them as light-weight numeric (single precision float) properties.

[[evaluator_synthetic_arcs]]
=== Synthetic Arcs

Synthetic arcs are virtual arcs generated by evaluator expressions to enable filtering, collection and traversal based on more than one arc value.

[[synthetic_arcs__background]]
==== Background and Default Behavior
Two vertices _A_ and _B_ may be connected with one or more arcs _AB_ = { _ab~1~_, _ab~2~_, ... }. When _AB_ contains a single component arc _ab~1~_ (or just _ab_) we call _AB_ a simple arc. When _AB_ contains two or more component arcs we call _AB_ a multiple arc.

When traversing arc _AB_ each component arc _ab~i~_ is processed separately without regard to any other component arc in _AB_. If a second level of traversal of _B_'s neighborhood is performed then _B_'s neighborhood will be traversed repeatedly each time _B_ is visited as a result of traversing a component arc in _AB_.

For example, if _A_ is connected to _B_ with multiple arc _AB_ = { _ab~1~_, _ab~2~_, _ab~3~_ } and _B_ is connected to _C_ with multiple arc _BC_ = { _bc~1~_, _bc~2~_, _bc~3~_ } then there are 3 paths from _A_ to _B_ and 3*3=9 paths from _A_ to _C_. The default query behavior is to exhaustively traverse all unique paths.

.This query returns _ab~1~_, _ab~2~_, _ab~3~_ plus all nine combinations of (_ab~i~_, _bc~j~_) for a total of 12 arcs/paths.
[source, python]
----
graph.Neighborhood(
    id        = "A",
    fields    = F_AARC,
    collect   = C_COLLECT,
    neighbors = {
        'arc'    : D_OUT,
        'collect': C_COLLECT
    }
) -> list of 12 entries
----

[[synthetic_arcs__arc_collapsing]]
==== Arc Collapsing with Synthetic Arc Operators

_Synthetic arcs_ are helpful when the default behavior is not desired. A synthetic arc _ab~syn~_ is a simple arc substitute for arc _AB_ (simple or multiple) between two vertices _A_ and _B_.

Synthetic arcs are not stored in the graph. They are temporary virtual relationships created by the expression evaluator for the purpose of filtering, traversal and collection.

// cspell:ignore issyn
[[synthetic_arcs__value_capture]]
===== Value Capture and Synthetic Arc Evaluation

A filter expression containing one or more <<synthetic_arcs__operators>> triggers synthetic arc mode for the expression evaluator. In synthetic arc mode _one additional evaluation_ occurs after all component arcs _ab~i~_ in _AB_ have been processed. The additional evaluation at the end is performed for synthetic arc _ab~syn~_.

When evaluating component arcs _ab~i~_ all synthetic arc operators (except '*.arc.issyn') capture arc information into temporary registers and return `null`. When evaluating synthetic arc _ab~syn~_ the synthetic arc operators return the previously captured values. Most expressions involving `null` operands are no-ops, making it possible to write the expression as if _AB_ were a dictionary with simultaneous access to all of its component arcs _ab~i~_.

See <<synthetic_arcs__example_1>> for a detailed description of how information is captured and used.

[[synthetic_arcs__arc_attributes]]
===== Synthetic Arc Attributes

Synthetic arcs have the special reserved relationship name `"+++__synthetic__+++"` and they have no value and no modifier unless a value is assigned with `collect()` or `collectif()`. When a value is assigned the modifier is automatically set to `M_INT` or `M_FLT` depending on the value type.

[[synthetic_arcs__operators]]
===== Synthetic Arc Operators

.Synthetic Arc Operators
[cols="7,2,4,4"]
|===
|Operator |Return Value |_ab~i~_ Capture Phase| Synthetic Arc _ab~syn~_

|`.arc.issyn`
 +
 `next.arc.issyn`
 +
 `prev.arc.issyn`
|true or false
|Evaluate to *false* when processing component arcs _ab~i~_
|Evaluate to *true* when processing synthetic arc _ab~syn~_

|`synarc.value( _rel_, _mod_ )` [[_synarcvalue]]
|_null_, _real_, or _integer_
|Capture the value of component arc _ab~i~_ matching relationship _rel_ and modifier _mod_. The captured value is stored in a hidden temporary register. Return `null`.
|Return the value of component arc _ab~i~_ matching relationship _rel_ and modifier _mod_. If no match was found `null` is returned.

|`synarc.hasrel( _r~n-1~_, ..., _r~i~_, ..., _r~0~_ )` [[_synarchasrel]]
|_null_ or _bitvector_
|Set bit _i_ in temporary hidden bitvector _V_ to 1 if relationship _r~i~_ exists in arc _AB_. Maximum _n_ is 64. Leftmost arguments _n_ and higher are ignored if _n_ > 64.
|Return bitvector _V_. Bits are set to 1 in positions corresponding to relationships in the argument list that exist in arc _AB_. All other bits are 0.

|`synarc.hasmod( _m~n-1~_, ..., _m~i~_, ..., _m~0~_ )` [[_synarchasmod]]
|_null_ or _bitvector_
|Set bit _i_ in temporary hidden bitvector _V_ to 1 if modifier _m~i~_ exists in arc _AB_. Maximum _n_ is 64. Leftmost arguments _n_ and higher are ignored if _n_ > 64.
|Return bitvector _V_. Bits are set to 1 in positions corresponding to modifiers in the argument list that exist in arc _AB_. All other bits are 0.

|`synarc.hasrelmod( _r~n-1~_, _m~n-1~_, ..., _r~0~_, _m~0~_ )` [[_synarchasrelmod]]
|_null_ or _bitvector_
|Set bit _i_ in temporary hidden bitvector _V_ to 1 if a component arc in _AB_ with relationship _r~i~_ *_and_* modifier _m~i~_ exists. Maximum _n_ is 64. Leftmost arguments _n_ and higher are ignored if _n_ > 64. An even number of arguments is required.
|Return bitvector _V_. Bits are set to 1 in positions corresponding to relationship/modifier pairs in the argument list that match a component arc in _AB_. All other bits are 0.

|`synarc.decay( _rel_[, _rate_] )` [[_synarcdecay]]
 +
 `synarc.xdecay( _rel_[, _rate_] )` [[_synarcxdecay]]
|_null_ or _real_
|Collect relevant values and time information from components arcs _ab~i~_ with relationship _rel_. Return `null`.
|Return a _real_ value representing a decayed version of relationship _rel_'s initial value. See <<evaluator_synarc_decay>> for a detailed description.

|===

==== Synthetic Arcs Examples

[[synthetic_arcs__example_1]]
===== Example 1: Conditional Collection of Composite Value

Consider vertex _A_ connected to two terminals _X_ and _Y_ with arcs _AX_ = { ('count', M_CNT, 25), ('weight', M_FLT, 4.0 ) }, and _AY_ = { ('count', M_CNT, 20), ('weight', M_FLT, 2.0) }. A filter expression can be written to conditionally collect synthetic arcs rather than individual component arcs.

.Conditionally collect synthetic arc based on composite value
[source, python]
----
graph.Neighborhood(
    id        = "A",
    fields    = F_AARC,
    collect   = C_SCAN,
    filter    = """
                c = synarc.value('count',M_CNT);
                w = synarc.value('weight',M_FLT);
                score = c * w;
                collectif( score < 50.0, score );
                """
) -> ['( A )-[ __synthetic__ <M_FLT> 40.000 ]->( Y )']
----

The filter expression is evaluated three times for (multiple) arcs _AX_ and _AY_. First consider the processing of _AX_:

First filter iteration for _AX_::
The neighborhood query visits component arc _ax~1~_ = ('count', M_CNT, 25). The sub-expression `c = synarc.value('count',M_CNT);` has a match on _ax~1~_ and captures the value 25 into an internal register. The value `null` is returned and assigned to `c`. The sub-expression `w = synarc.value('weight',M_FLT);` does not match _ax~1~_ and is a no-op. The value `null` is returned and assigned to `w`. The sub-expression `score = c * w;` assigns `null` to `score` since both factors are `null`. The sub-expression `collectif( score < 50.0, score );` is a no-op because `score < 50.0` is false when `score` is `null`. (Comparisons involving `null` are always false, except when testing equality between two `null` values.)

Second filter iteration for _AX_::
The neighborhood query visits component arc _ax~2~_ = ('weight', M_FLT, 4.0). Evaluation is the same as for _ax~1~_ as above, except sub-expression `w = synarc.value('weight',M_FLT);` now matches _ax~2~_ and captures the value 4.0 into another internal register.

Third filter iteration for _AX_::
The neighborhood query now invokes the evaluator one final time for synthetic arc _ax~syn~_ = ('+++__synthetic__+++', M_NONE, 0). The sub-expression `c = synarc.value('count',M_CNT);` assigns 25 to `c` as this value is retrieved from the internal register that previously captured this value from _ax~1~_. The sub-expression `w = synarc.value('weight',M_FLT);` assigned 4.0 to `w` as this value is retrieved from the internal register that previously captured this value from _ax~2~_. The sub-expression `score = c * w;` multiplies the two values and assigns 100.0 to `score`; The sub-expression `collectif( score < 50.0, score );` is a no-op since the condition is not met. The arc _AX_ did not match and is not collected.

First filter iteration for _AY_::
Component arc _ay~1~_ = ('count', M_CNT, 20) matches and the value 20 is captured, in the same manner as described above for _ax~1~_.

Second filter iteration for _AY_::
Component arc _ay~2~_ = ('weight', M_FLT, 2.0) matches and the value 2.0 is captured, in the same manner as described above for _ax~2~_.

Third filter iteration for _AY_::
Synthetic arc _ay~syn~_ = ('+++__synthetic__+++', M_NONE, 0) is processed, assigning `c = 20` and `w = 2.0` in the same manner as described above for _ax~syn~_. In this case `score = 40.0` and `collectif( score < 50.0, score );` therefore collects the synthetic arc _ay~syn~_ with a value 40.0 provided by the second argument to `collectif()`. We have now built and collected a single composite arc ('+++__synthetic__+++', M_FLT, 40.0) based on components of _AY_.

[[synthetic_arcs__example_2]]
===== Example 2: Avoiding Exhaustive Path Traversal using Arc Collapsing

Consider a graph connecting a root vertex to many neighbors with wide multiple arcs, which in turn are connected to many neighbors with wide multiple arcs. This graph has a very large number of unique paths from the root to each vertex in the 2^nd^ level neighborhood.

Formally, such a graph can be described as follows. Root vertex _A_ has _n_ terminals *B* = { _B~1~_, ... _B~n~_ }, where each _B~i~_ has _m_ terminals *C~i~* = { _C~i,1~_, ..., _C~i,m~_ }. _A_ connects to each _B~i~_ with _k_-multiple arc _AB~i~_ = { _ab~i,1~_, ..., _ab~i,k~_ } and _B~i~_ connects to each _C~i,j~_ with _q_-multiple arc _BC~i,j~_ = { _bc~i,j,1~_, ..., _bc~i,j,q~_}.

.Build graph connecting _A_ via *B* to *C* with wide multiple arcs
[source, python]
----
def build( n=100, m=100, k=10, q=10 ):
    g = Graph( "levels" )
    A = g.NewVertex( "A" )
    for i in range( 1, n+1 ):
        Bi = g.NewVertex( "B_%d" % i )
        for ab in range( 1, k+1 ):
            g.Connect( A, ("r%d"%ab, M_FLT, i*ab), Bi )
        for j in range( 1, m+1 ):
            Cij = g.NewVertex( "C_%d_%d" % (i,j) )
            for bc in range( 1, q+1 ):
                g.Connect( Bi, ("r%d"%bc, M_FLT, i*ab*j*bc), Cij )
    return g
----

If _n_ = _m_ = 1000 and _k_ = _q_ = 100, then _A_ has 1000 terminals _B~1~_ through _B~1000~_ (each connected via a _100_-multiple arc) and each _B~i~_ has 1000 terminals _C~i,1~_ through _C~i,1000~_ (each connected via a _100_-multiple arc.) 

[source, python]
----
graph = build( n=1000, m=1000, k=100, q=100 )
----


The following query collects all paths from _A_ to all *C*, yielding a large result set with _n_ * _k_ * _m_ * _q_ = 10,000,000,000 arcs.

.Exhaustive path traversal from _A_ to *C*
[source, python]
----
graph.Neighborhood(
    id        = "A",
    fields    = F_AARC,
    collect   = C_SCAN,
    neighbor  = {
        'traverse': {
            'arc'    : D_OUT,
            'collect': C_COLLECT
        }
    }
) -> list of n*k*m*q=10,000,000,000 arcs 
----

We can use synthetic arcs to avoid exhaustive path traversal. By adding filter conditions that check for `.arc.issyn == true` we can restrict traversal and collection to synthetic arcs:

.Collapsed path traversal from _A_ to *C*
[source, python]
----
graph.Neighborhood(
    id        = "A",
    fields    = F_AARC,
    collect   = C_SCAN,
    filter    = ".arc.issyn",
    neighbor  = {
        'traverse': {
            'arc'    : D_OUT,
            'collect': C_COLLECT,
            'filter' : ".arc.issyn"
        }
    }
) -> list of n*m arcs=1,000,000 arcs
----

We can also use a combination of synthetic arcs and value aggregation to collect collapsed arcs with computed values. The query below uses memory registers to accumulate values.  Register `R1` accumulates the sum of values of arcs { _ab~i,1~_, ..., _ab~i,k~_ }.  Register `R2` accumulates the sum of values of arcs { _bc~i,j,1~_, ..., _bc~i,j,q~_ }.

.Fancy collapsed path traversal from _A_ to *C*
[source, python]
----
graph.Neighborhood(
    id         = "A",
    sortby     = S_VAL,
    fields     = F_AARC,
    collect    = C_SCAN,
    pre        = """
                 /* Init AB and BC value accumulators */
                 do( store(R1,0),store(R2,0) )
                 """,
    filter     = """
                 // Accumulate AB_i
                 add(R1,.arc.value);
                 // Traverse to B for synthetic arc only
                 .arc.issyn
                 """,
    neighbor   = {
        'traverse' : {
            'arc'     : D_OUT,
            'collect' : C_SCAN,
            'filter'  : """
                        // Accumulate BC_ij and continue
                        add(R2,.arc.value);
                        returnif(!.arc.issyn,0);
                        // Synthetic arc with computed value
                        score = load(R1) + load(R2);
                        collect(score);
                        // Reset BC_ij accumulator
                        do(store(R2,0));
                        """
        },
        'post'     : """
                     // Reset AB_i accumulator
                     do(store(R1,0))
                     """
    }
)
----




[[evaluatorconstants]]
=== Constants

Many numeric constants are available for use in expressions. These are summarized below.

==== Null

[cols="2,2,3,6"]
|===
|Name |Type |Value |Description

|`null` [[_null]]
|_null_
|
| No value

|===

.Example: Non-existent vertex attributes
[source, python]
----
graph.CreateVertex( "V" )
graph.Evaluate( "vertex['prop1'] == null", head="V" ) -> 1
----

==== Boolean
[cols="2,2,3,6"]
|===
|Name |Type |Value |Description

|`true` [[_true]]
|_int_
|1
|Boolean True

|`false` [[_false]]
|_int_
|0
|Boolean False

|===

.Example: Boolean values are integers
[source, python]
----
graph.Evaluate( "true == 1 && false == 0" )  -> 1
----

==== Timestamp Limits
[cols="2,2,3,6"]
|===
|Name |Type |Value |Description

|`T_NEVER` [[_t_never]]
|_int_
|<<../constants/timestampConstants.adoc#T_NEVER, 4102444800>>
|Never

|`T_MAX` [[_t_max]]
|_int_
|<<../constants/timestampConstants.adoc#T_MAX, 4102444799>>
|Thu Dec 31 23:59:59 2099

|`T_MIN` [[_t_min]]
|_int_
|<<../constants/timestampConstants.adoc#T_MIN, 1>>
|Thu Jan 01 00:00:01 1970

|===

.Example: Alice's connections that will expire at some point
[source, python]
----
graph.Neighborhood(
    "Alice",
    filter = ".arc.mod == M_TMX && .arc.value < T_NEVER"
)
----

==== Arc Direction
[cols="2,2,3,6"]
|===
|Name |Type |Value |Description

|`D_ANY` [[_d_any]]
|_int_
|<<../constants/arcDirectionConstants.adoc#D_ANY, 0>>
|Any arc direction

|`D_IN` [[_d_in]]
|_int_
|<<../constants/arcDirectionConstants.adoc#D_IN, 1>>
|Inbound arc direction

|`D_OUT` [[_d_out]]
|_int_
|<<../constants/arcDirectionConstants.adoc#D_OUT, 2>>
|Outbound arc direction

|`D_BOTH` [[_d_both]]
|_int_
|<<../constants/arcDirectionConstants.adoc#D_BOTH, 3>>
|Bi-directional arc

|===

.Example: Sort by arc value, boosting inbound arcs by 1000 extra points
[source, python]
----
graph.Neighborhood(
    "Alice",
    arc    = D_ANY,
    rank   = "1000 * (.arc.dir == D_IN) + .arc.value",
    sortby = S_RANK,
    select = ".arc.dir; .rank"
)
----

IMPORTANT: The `.arc.dir` attribute is "observational" only and cannot be used to control traversal direction. Traversal direction is controlled by the `arc=` parameter and `.arc.dir` reflects the current direction. This implies that `.arc.dir` will never equal `D_ANY`. Furthermore, in `filter=` expressions `.arc.dir` will either be `D_IN` or `D_OUT`, never `D_BOTH`. However, in `rank=` and `select=` expressions `.arc.dir` may equal `D_BOTH` if a bi-directional relationship was collected. This subtle point warrants another example:

.Example: Sort bi-directional arcs before other arcs
[source, python]
----
graph.Neighborhood(
    "X",
    rank     = ".arc.dir == D_BOTH",
    sortby   = S_RANK,
    neighbor = {
        'collect'  : C_COLLECT,
        'arc'      : D_BOTH
    },
    select   = ".arc.dir"
)
----

==== Arc Modifiers
[cols="2,2,3,6"]
|===
|Name |Type |Value |Description

|`M_ANY` [[_m_any]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_ANY, 0>>
|No modifier / wildcard

|`M_STAT` [[_m_stat]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_STAT, 1>>
|Static relationship (no value)

|`M_SIM` [[_m_sim]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_SIM, 18>>
|Similarity relationship, explicit score

|`M_DIST` [[_m_dist]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_DIST, 19>>
|Generic distance relationship value

|`M_LSH` [[_m_lsh]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_LSH, 4>>
|LSH bit pattern subject to hamming distance filter

|`M_INT` [[_m_int]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_INT, 5>>
|General purpose integer relationship value

|`M_UINT` [[_m_uint]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_UINT, 6>>
|General purpose unsigned integer relationship value

|`M_FLT` [[_m_flt]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_FLT, 23>>
|General purpose floating point relationship value

|`M_CNT` [[_m_cnt]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_CNT, 8>>
|Automatic counter relationship value

|`M_ACC` [[_m_acc]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_ACC, 25>>
|Automatic accumulator relationship value

|`M_TMC` [[_m_tmc]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_TMC, 12>>
|Arc creation time relationship value

|`M_TMM` [[_m_tmm]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_TMM, 13>>
|Arc modification time relationship value

|`M_TMX` [[_m_tmx]]
|_int_
|<<../constants/arcModifierConstants.adoc#M_TMX, 14>>
|Arc expiration time relationship value

|===

.Example: Match multiple arc modifiers
[source, python]
----
graph.Neighborhood(
    "Alice",
    filter = ".arc.mod in { M_INT, M_FLT } && .arc.value > 10"
)
----

==== Memory Registers
[cols="2,2,3,6"]
|===
|Name |Type |Value |Description

|`R1` [[_r1]]
|_int_
|-1
|<<evaluatormemory>> register #1

|`R2` [[_r2]]
|_int_
|-2
|<<evaluatormemory>> register #2

|`R3` [[_r3]]
|_int_
|-3
|<<evaluatormemory>> register #3

|`R4` [[_r4]]
|_int_
|-4
|<<evaluatormemory>> register #4

|===

.Example: Sort higher when arc and neighbor's arc have similar values
[source, python]
----
graph.Neighborhood(
    "Alice",
    filter   = "store( R1, .arc.value ) in range( 1, 100 )",
    neighbor = {
        'arc'     : D_OUT
        'filter'  : "store( R2, .arc.value ) in range( 1, 100 )"
    },
    rank     = "prox( load(R1), load(R2) )",
    sortby   = S_RANK,
)
----

==== Collector Staging Slots
[cols="2,2,3,6"]
|===
|Name |Type |Value |Description

|`C1` [[_c1]]
|_int_
|0
|Collector staging slot #1

|`C2` [[_c2]]
|_int_
|1
|Collector staging slot #2

|`C3` [[_c3]]
|_int_
|2
|Collector staging slot #3

|`C4` [[_c4]]
|_int_
|3
|Collector staging slot #4

|===

.Example: Find the most visited country for each of Alice's friends.
[source, python]
----
graph.Neighborhood(
    "Alice",
    collect  = C_NONE,
    neighbor = {
        'type'     : "person",
        'filter'   : "do( store( R1, 0 ) )",
        'traverse' : {
            'arc'     : ( "visit", D_OUT ),
            'collect' : C_SCAN,
            'filter'  : """
                        stageif(
                            storeif(
                                next.arc.value > load(R1),
                                R1,
                                next.arc.value
                            ),
                            null,
                            C1
                        )
                        """,
            'neighbor': {
                'type'  : "country"
            }
        },
        'post'     : "commitif( load(R1) > 0, C1 )"
    }
)
----



==== Mathematical Constants
[cols="2,2,3,6"]
|===
|Name |Type |Value |Description

|`pi` [[_pi]]
|_float_
|3.14159265358979323846
// |`&#960;`
|latexmath:[ \pi ]

|`e` [[_e]]
|_float_
|2.71828182845904523536
// |`e`
|latexmath:[ e ]

|`root2` [[_root2]]
|_float_
|1.4142135623730950488
// |`&#8730;2` (faster than `sqrt(2)`)
|latexmath:[ \sqrt{ 2 } ]

|`root3` [[_root3]]
|_float_
|1.73205080756887729353
// |`&#8730;3` (faster than `sqrt(3)`)
|latexmath:[ \sqrt{ 3 } ]

|`root5` [[_root5]]
|_float_
|2.23606797749978969641
// |`&#8730;5` (faster than `sqrt(5)`)
|latexmath:[ \sqrt{ 5 } ]

|`phi` [[_phi]]
|_float_
|1.6180339887498948482
// |`&#966; = (1+&#8730;5)/2` Golden ratio
|latexmath:[ \varphi = \frac{1+\sqrt{5}}{2} ] (golden ratio)

// cspell:ignore Apéry infty
|`zeta3` [[_zeta3]]
|_float_
|1.2020569031595942854
// |`&#950;(3) = &#8721;1/n^3^` Apéry's constant
|latexmath:[ \zeta(3) = \displaystyle \sum_{n=1}^\infty \frac{1}{n^3} ] (Apéry's constant)

|===

[source, python]
----
graph.Evaluate( "(e + root2) / pi" ) -> 1.3154...
----

[[evaluatorenvironment]]
=== Current Environment

These attributes are relative to the current execution environment.

==== Current Graph State
[cols="2,2,6"]
|===
|Attribute |Type |Description

|`graph.ts` [[_graphts]]
|_float_
|Current graph time, in seconds since 1970

|`graph.t0` [[_grapht0]]
|_float_
|Graph inception time

|`graph.age` [[_graphage]]
|_float_
|Graph age = `graph.ts - graph.t0`

|`graph.order` [[_graphorder]]
|_int_
|Number of vertices in graph

|`graph.size` [[_graphsize]]
|_int_
|Number of arcs in graph

|`graph.op` [[_graphop]]
|_int_
|Current operation counter

|===

NOTE: Graph state attributes are sampled the first time an expression is evaluated in a query and remain constant for the duration of the query.

.Example: Derive information from graph attributes
[source, python]
----
graph.Evaluate( "graph.size / graph.order" ) -> average outdegree
graph.Evaluate( "graph.ts - graph.age" )     -> graph creation time
----

==== System Attributes
[cols="2,2,6"]
|===
|Attribute |Type |Description

|`sys.tick` [[_systick]]
|_int_
|System tick in nanoseconds since computer boot time

|`sys.uptime` [[_sysuptime]]
|_float_
|System uptime in seconds

|===

NOTE: System attributes are re-read from their source each time an expression is evaluated.

.Example: Perform deep traversal and return results in the order of most time consuming
[source, python]
----
graph.Neighborhood(
    "A",
    filter   = "store(R1, sys.tick)",
    neighbor = {
        'arc'      : D_OUT,
        'neighbor' : {
            'filter' : ".id == '*z*'"
        }
    },
    rank     = "sys.tick - load(R1)",
    sortby   = S_RANK,
    select   = ".rank"
)
----

// cspell:ignore sortby
==== Current Evaluator Context
[cols="2,2,6"]
|===
|Name |Type |Description

|`context.rank` [[_context_rank]]
 +
`.rank`
|_float_
|In <<selectEvaluator.adoc#selectstatement, `select=` statements>> this is the result sorting value as determined by the `sortby=` parameter. +

In `filter=` or `rank=` expressions this value is normally 0. However, when the expression is evaluated in the context of traversal or collection resulting from <<bfssupport, breadth-first search with `mcull()`>> this value is set to the score of the culled item being processed.

|`vector` [[_vector]]
|<<../similarity/vector.adoc#, _vector_>>
|Similarity probe vector as supplied in the query `vector=` parameter or <<../vertex/vertexFilter.adoc#vertexfiltersimilarity, similarity filter>>.

|`collectable.real` [[_collectable_real]]
|_float_
|An item's rank score must be greater than (less than) this value to have a chance of being included in a query result sorted by a floating point field in descending (ascending) order.

NOTE: Query <<../constants/sortSpecificationConstants.adoc#, sortby>> parameter determines the data type. Use `collectable.real` with sortby constants `S*` whose Type is (or may be) _float_.

|`collectable.int` [[_collectable_int]]
|_int_
|An item's rank score must be greater than (less than) this value to have a chance of being included in a query result sorted by an integer field in descending (ascending) order.

NOTE: Query <<../constants/sortSpecificationConstants.adoc#, sortby>> parameter determines the data type. Use `collectable.int` with sortby constants `S*` whose Type is _int_.

|===

.Example: Sort results by length of neighbor's id and render result by custom label
[source, python]
----
graph.Neighborhood(
    "X",
    rank   = "len( .id )"
    sortby = S_RANK,
    select = "ID LEN : int( .rank )"
)
----

[[evaluatorfunctions]]
=== Functions

This section summarizes built-in functions available for use in expressions.

// cspell:ignore arcsin arccos arctan binom
[[mathfunctions]]
==== Mathematical Functions

[cols="4,7,4"]
|===
|Function |Description |Comment

|`inv( _x_ )` [[_inv]]
// |Inverse of _x_, i.e. 1/x
|latexmath:[ y = \displaystyle \frac{1}{x} ]
|NOTE: `inv(0)` is defined as 3.4&#183;10^38^.

|`neg( _x_ )` [[_neg]]
//|Negative of _x_, i.e. _&#8722;x_
|latexmath:[ y = -x ]
|

|`log2( _x_ )` [[_log2]]
//|Base-2 logarithm
|latexmath:[ y = \log_2 x  ]
|NOTE: _x_ &#8804; 0 -> &#8722;1074

|`log( _x_ )` [[_log]]
//|Natural logarithm
|latexmath:[ y = \ln{x} ]
|NOTE: _x_ &#8804; 0 -> &#8722;745

|`log10( _x_ )` [[_log10]]
// |Base-10 logarithm
|latexmath:[ y = \log_{10} x ]
|NOTE: _x_ &#8804; 0 -> &#8722;324

|`rad( _x_ )` [[_rad]]
// |Convert degrees to radians, i.e. _x_ &#183; &#960; / 180
|latexmath:[ y = \displaystyle \frac{\pi x}{180} ]
|Degrees to radians

|`deg( _x_ )` [[_deg]]
// |Convert radians to degrees, i.e. _x_ &#183; 180 / &#960;
|latexmath:[ y = \displaystyle \frac{180 \cdot x}{\pi} ]
|Radians to degrees

|`sin( _x_ )` [[_sin]]
// |Compute sine of angle _x_ (radians)
|latexmath:[ y = \sin x ]
|

|`cos( _x_ )` [[_cos]]
// |Compute cosine of angle _x_ (radians)
|latexmath:[ y = \cos x ]
|

|`tan( _x_ )` [[_tan]]
// |Compute tangent of angle _x_ (radians)
|latexmath:[ y = \tan x ]
|

|`asin( _x_ )` [[_asin]]
// |Compute arcsine of _x_ in the range &#8722;&#960;/2 to &#960;/2 radians.
|latexmath:[ y = \arcsin x ]
|

|`acos( _x_ )` [[_acos]]
// |Compute arccosine of _x_ in the range 0 to &#960; radians.
|latexmath:[ y = \arccos x ]
|

|`atan( _x_ )` [[_atan]]
// |Compute arctangent of _x_ in the range &#8722;&#960;/2 to &#960;/2 radians.
|latexmath:[ y = \arctan x ]
|

|`atan2( _a_, _b_ )` [[_atan2]]
// |Compute arctangent of _y_/_x_ in the range &#8722;&#960; to &#960; radians.
|latexmath:[ y = \displaystyle \arctan { \frac{a}{b} } ]
|Both signs of _a_ and _b_ are used to determine the correct quadrant.

|`sinh( _x_ )` [[_sinh]]
// |Compute hyperbolic sine of angle _x_ (radians)
|latexmath:[ y = \sinh x ]
|

|`cosh( _x_ )` [[_cosh]]
// |Compute hyperbolic cosine of angle _x_ (radians)
|latexmath:[ y = \cosh x ]
|

|`tanh( _x_ )` [[_tanh]]
// |Compute hyperbolic tangent of angle _x_ (radians)
|latexmath:[ y = \tanh x ]
|

|`asinh( _x_ )` [[_asinh]]
// |Compute the inverse hyperbolic sine of _x_
|latexmath:[ y = \arcsinh x ]
|

|`acosh( _x_ )` [[_acosh]]
// |Compute the inverse hyperbolic cosine of _x_
|latexmath:[ y = \arccosh x ]
|

|`atanh( _x_ )` [[_atanh]]
// |Compute the inverse hyperbolic tangent of _x_
|latexmath:[ y = \arctanh x ]
|

|`sinc( _x_ )` [[_sinc]]
// |Compute sin( _&#960;x_ ) / _&#960;x_
|latexmath:[ y = \displaystyle \frac{sin (\pi x)}{\pi x} ]
|

|`exp( _x_ )` [[_exp]]
// |Compute e^_x_^
|latexmath:[ y = \displaystyle e^x ]
|

|`abs( _x_ )` [[_abs]]
// |Compute \| _x_ \|
|latexmath:[ y = \| x \| ]
|

|`sqrt( _x_ )` [[_sqrt]]
// |Compute &#8730; _x_
|latexmath:[ y = \sqrt x ]
|NOTE: The result will be 0 when _x_ is negative

|`ceil( _x_ )` [[_ceil]]
// |Return the real value representing the smallest integer &#8805; _x_
|latexmath:[ y = \lceil x \rceil ]
|

|`floor( _x_ )` [[_floor]]
// |Return the real value representing the largest integer &#8804; _x_
|latexmath:[ y = \lfloor x \rfloor ]
|

|`round( _x_ )` [[_round]]
// |Return the real value representing the nearest integer to _x_
|latexmath:[ y = \lfloor x \rceil ]
|NOTE: Rounding rule is to round away from zero. (Differs from Python3 _round-to-even_ rule!)

|`sign( _x_ )` [[_sign]]
// |Return the sign of _x_ as 1 or &#8722;1
|latexmath:[ y = \begin{cases} 1 & \quad \text{if } x > 0 \\ 0 & \quad \text{if } x = 0 \\ -1 & \quad \text{if } x < 0 \end{cases} ]
|

|`fac( _x_ )` [[_fac]]
// |Compute _x!_ (factorial)
|latexmath:[ y = x! ]
|

|`popcnt( _x_ )` [[_popcnt]]
// |Compute _x!_ (factorial)
|Return the number of bits set to 1 in the binary representation of _x_
|

|`comb( _n_, _k_ )` [[_comb]]
// |Compute the number of _k_-combinations of a set with _n_ elements
|latexmath:[ y = \displaystyle \binom{n}{k} =  \frac{n!}{k!(n-k)!} ]
|

|`max( _a_, _b_ )` [[_max]]
// |Return the larger of the values _a_ and _b_
|latexmath:[ y = \begin{cases} a & \quad \text{if } a \geq b \\ b & \quad \text{if } a < b \end{cases} ]
|

|`min( _a_, _b_ )` [[_min]]
// |Return the smaller of the values _a_ and _b_
|latexmath:[ y = \begin{cases} a & \quad \text{if } a < b \\ b & \quad \text{if } a \geq b \end{cases} ]
|

|`hash( _x_ )` [[_hash]]
|Return a 64-bit integer hash value latexmath:[ y = h(x) ]
|

|`random()` [[_random]]
|Return a random number latexmath:[ y \in [0, 1\] ]
|

|`randbits()` [[_randbits]]
|Return a random bitvector
|

|`randint( _a_, _b_ )` [[_randint]]
|Return a random integer latexmath:[y \in [a, b \rangle ]
|

|===

.Example: Miscellaneous function calls
[source, python]
----
graph.Evaluate( "log( 5 ) - sqrt( 17 )" ) -> -2.51...
graph.Evaluate( "acos( sin( pi / 3 ) )" ) -> 0.524...
graph.Evaluate( "sqrt( log( exp(4) ) )" ) -> 2.0
graph.Evaluate( "hash( 'helloworld!' )" ) -> 7982852363355633418
----

[[castandcheckfunctions]]
==== Type Cast and Checks

[cols="4,10"]
|===
|Operation |Description

|`int( _x_ )` [[_int]]
|Return the integer representation of object _x_. If _x_ is a non-numeric object with a memory address the address is returned. If _x_ is _real_ `inf` (or `-inf`) the maximum (or minimum) integer value is returned. If _x_ is the result of a non-existent property lookup 0 is returned. If _x_ is any other object _x_ is returned unchanged.

|`intr( _x_ )` [[_intr]]
|Same as `int()` except _x_ is rounded to the nearest whole number before the cast if _x_ is _real_.

|`asint( _x_ )` [[_asint]]
|Reinterpret the bits of object _x_ as an integer. If _x_ is _real_ (including `inf` and `nan`) the bits are reinterpreted directly as a 64-bit signed integer. If _x_ is a _string_ representing a number it is reinterpreted as the corresponding integer. If the string does not represent a number 0 is returned. If _x_ is a _vector_ it is interpreted as the vector's length. If _x_ is any other object with a memory address the address is returned. If _x_ is the result of a non-existent property lookup 0 is returned. If _x_ is any other object _x_ is returned unchanged.

|`asbits( _x_ )` [[_asbits]]
|Return the raw bits of object _x_ with type set to _int_.

|`real( _x_ )` [[_real]]
|Return the floating point representation of object _x_. If _x_ is a non-numeric object with a memory address the address is returned as a floating point number. If _x_ is _int_ the corresponding floating point value is returned. If _x_ is the result of a non-existent property lookup 0.0 is returned. If _x_ is any other object (including _real_) _x_ is returned unchanged.

|`asreal( _x_ )` [[_asreal]]
|Reinterpret the bits of object _x_ as a floating point number. If _x_ is _int_ the bits are reinterpreted directly as a double precision floating point value. If _x_ is _real_ `inf` (or `-inf`) the maximum (or minimum) double value is returned. If _x_ is a _string_ representing a number it is reinterpreted as the corresponding floating point value. If the string does not represent a number `nan` is returned. If _x_ is a _vector_ it is interpreted as the vector's magnitude. If _x_ is any other object with a memory address the address is returned as a floating point number. If _x_ is the result of a non-existent property lookup 0.0 is returned. If _x_ is any other object _x_ is returned unchanged.

|`str( _x_ )` [[_str]]
|Return the string representation of object _x_. 
 +
 +
 *NOTE*: The returned string is a new string object stored in the <<evaluatormemory>> object used by the expression. Strings produced by this function are not deallocated until the memory object is deleted or explicitly cleared using `"mreset()"` in an expression or calling `Reset()` on the associated Python object.

|`bitvector( _x_ )` [[_bitvector]]
|Return the raw bits of object _x_ with type set to _bitvector_.

|`isint( _x_ )` [[_isint]]
|Return 1 if _x_ is an integer, otherwise return 0

|`isreal( _x_ )` [[_isreal]]
|Return 1 if _x_ is a floating point value, otherwise return 0

|`isstr( _x_ )` [[_isstr]]
|Return 1 if _x_ is a string object, otherwise return 0

|`isvector( _x_ )` [[_isvector]]
|Return 1 if _x_ is a vector object, otherwise return 0

|`isbitvector( _x_ )` [[_isbitvector]]
|Return 1 if _x_ is a bitvector, otherwise return 0

|`isnan( _x_ )` [[_isnan]]
|Return 1 if _x_ is _real_ `nan` or any object other than integer, bitvector or floating point, otherwise return 0

|`isinf( _x_ )` [[_isinf]]
|Return 1 if _x_ is _real_ `inf` or `-inf`, otherwise return 0

|`isarray( _x_ )` [[_isarray]]
|Return 1 if _x_ is a numeric array type, otherwise return 0. See <<../vertex/vertexProperty.adoc#vertex_property_type_list, Vertex Property Types: _list_>> for how to assign a property for which `isarray()` is true.

|`ismap( _x_ )` [[_ismap]]
|Return 1 if _x_ is a map of _keyval_ items, otherwise return 0. See <<../vertex/vertexProperty.adoc#vertex_property_type_dict, Vertex Property Types: _dict_>> for how to assign a property for which `ismap()` is true.

|`iskeyval( _x_ )` [[_iskeyval]]
|Return 1 if _x_ is a _keyval_ type, otherwise return 0

|`isbytearray( _x_ )` [[_isbytearray]]
|Return 1 if _x_ is an array of bytes (0-255), otherwise return 0. See <<../vertex/vertexProperty.adoc#vertex_property_type_bytearray, Vertex Property Types: _bytearray_>> for how to assign a property for which `isbytearray()` is true.

|`isbytes( _x_ )` [[_isbytes]]
|Return 1 if _x_ is an array of bytes (0-255), otherwise return 0. See <<../vertex/vertexProperty.adoc#vertex_property_type_bytes, Vertex Property Types: _bytes_>> for how to assign a property for which `isbytes()` is true.

|`len( _x_ )` [[_len]]
|Return the length of object _x_. Definition of length depends on object type.
 +
 +
 Length of _string_ and _vertexid_ is number of UTF-8 bytes in encoded string.
 +
 Length of _vector_ is number of dimensions.
 +
 Length of _bitvector_ is number of bits set to 1.
 +
 Length of _bytearray_ and _bytes_ is number of bytes.
 +
 Length of _dict_ and _list_ is number of items.
 +
 Length of any other object is 0.

|===

.Example: Miscellaneous casts and checks
[source, python]
----
graph.Evaluate( "int( 2.5 )" )              -> 2
graph.Evaluate( "asint( 2.5 )" )            -> 0x4004000000000000
graph.Evaluate( "asint( '123' )" )          -> 123
graph.Evaluate( "real( 2 )" )               -> 2.0
graph.Evaluate( "asreal( 0x4004 << 48 )" )  -> 2.5
graph.Evaluate( "bitvector( 0xCC )" )       -> 0xCC
graph.Evaluate( "isinf( -1/-0.0 )" )        -> 1
graph.Evaluate( "len( 'hello' )" )          -> 5
----

[[stringfunctions]]
==== String Functions

[cols="8,5,3,7"]
|===
|Operation |Return Value |New Str |Description

|`strcmp( _a_, _b_ )` [[_strcmp]]
|Integer
|
|Compare strings _a_ and _b_. Return zero if strings are equal, negative if _a_ compares less than _b_, or positive if _a_ compares greater than _b_. If either _a_ or _b_ is not a string, `null` is returned.

|`strcasecmp( _a_, _b_ )` [[_strcasecmp]]
|Integer
|
|Compare strings _a_ and _b_, ignoring case. Return zero if strings are equal, negative if _a_ compares less than _b_, or positive if _a_ compares greater than _b_. If either _a_ or _b_ is not a string, `null` is returned.

|`strlen( _x_ )` [[_strlen]]
|Integer
|
|Return the number of bytes in string _x_. If _x_ is not _string_ or _vertexid_ 0 is returned.

|`startswith( _s_, _p_ )` [[_startswith]]
|0 or 1
|
|Return 1 if string _s_ starts with string _p_, otherwise return 0. If either _a_ or _b_ is not a string, `null` is returned.

|`endswith( _string_, _probe_ )` [[_endswith]]
|0 or 1
|
|Return 1 if string _s_ ends with string _p_, otherwise return 0. If either _a_ or _b_ is not a string, `null` is returned.

|`join( _sep_, _s~1~_, _s~2~_, ..., _s~n~_ )` [[_join]]
|_s~1~_ _sep_ _s~2~_ _sep_ ... _sep_ _s~n~_
|y
|Concatenate any number of strings _s~i~_ with string _sep_ inserted between each. Returns a new string object. If _sep_ or _s~i~_ are not strings they are implicitly cast using <<_str,`str()`>>.

|`replace( _str_, _probe_, _repl_  )` [[_replace]]
|Modified copy of _str_ 
|y
|Return a new string object copied from _str_ with all occurrences of _probe_ replaced with _repl_. All non-string arguments are implicitly cast using <<_str,`str()`>>.

|`idx( _s_, _i_ )` [[_idx]]
|Integer or real
|
|Return the value at index _i_ of string _s_. For normal strings this is the byte value at offset _i_. For a vertex property numeric array this is the numeric value at offset _i_.

|`slice( _str_, _a_, _b_ )` [[_slice]]
|Substring of _str_
|y
|Return a new string object representing the substring of _str_ starting at index _a_ and ending at index _b_ - 1. If _str_ is not a string object it is implicitly cast using <<_str,`str()`>>. Arguments _a_ and _b_ must be integers or `null`, which is interpreted as 0 and -1 for _a_ and _b_, respectively.

|===

CAUTION: For those functions returning strings, each time the function is evaluated a new string is created and stored in the <<evaluatormemory>> object used by the expression. Strings are not deallocated until the memory object is deleted or explicitly cleared using `"mreset()"` in an expression or calling `Reset()` on the associated Python object.

NOTE: It is also possible to concatenate strings using the infix `+` operator. As long as the first operand is a string object all subsequent infix operands added with `+` are implicitly cast using <<_str, `str()`>>.

.Example: String functions
[source, python]
----
graph.Evaluate( "strcmp( 'hello', 'hi' )" )          -> -1
graph.Evaluate( "strcasecmp( 'Hello', 'hello' )" )   -> 0
graph.Evaluate( "startswith( 'Hello', 'He' )" )      -> 1
graph.Evaluate( "endswith( 'Hello', 'lo' )" )        -> 1
graph.Evaluate( "join( ' ', 'a', 'b', 'c' )" )       ->  "a b c"
graph.Evaluate( "replace( 'say soda', 's', 'y' )" )  ->  "yay yoda"
graph.Evaluate( "slice( 'hello', 1, 4 )" )           ->  "ell"
graph.Evaluate( "str(pi)")                           ->  "3.14159"
graph.Evaluate( "'hello' + 1 + 2")                   ->  "hello12"
graph.Evaluate( "''+sin(1)+sin(0)" )                 ->  "0.8414710.00000"
----

[[proplookupfunctions]]
==== Property Lookup

[[_property]]
[cols="8,10"]
|===
|Function |Description

|`vertex.property( _x_[, _default_[, _cond_ ]] )`
|Return property _x_ of current _tail_ vertex. If the property does not exist and no _default_ is given, the return value depends on context: In infix arithmetic context the non-existent property evaluates to 0. In all other contexts the non-existent property evaluates to `nan`.
 +
 +
 When _default_ is provided it is returned if the property does not exist.
 +
 +
 When condition _cond_ is provided the lookup only takes place if _cond_ is true. If _cond_ is false OR the property does not exist, _default_ is returned.
 +
 +
 *TIP*: Conditional lookup can be used to avoid unnecessary memory access during evaluation and can speed up processing significantly in some cases. Because of <<noshortcircuiting>> unconditional property lookup is executed regardless of whether or not the final value of the expression depends on it.

|`next.property( _x_[, _default_[, _cond_ ]] )`
 +
 `.property( _x_[, _default_[, _cond_ ]] )`
|Same as `vertex.property()` except lookup occurs in current _head_ vertex.

|`prev.property( _x_[, _default_[, _cond_ ]] )`
|Same as `vertex.property()` except lookup occurs in _previous tail_ vertex.

|===

.Example: Property lookup
[source, python]
----
V = g.NewVertex( "V" )
V['x'] = 100
g.Evaluate( "vertex.property( 'x' )", tail=V )                -> 100
g.Evaluate( "vertex.property( 'y', 999 )", tail=V )           -> 999
g.Evaluate( "next.property( 'x', 0, next.deg > 0 )", head=V ) -> 0
----

Notice how the 3rd property lookup does not perform any lookup unless the degree is non-zero. If evaluated for millions of arcs where the condition is mostly false the memory load is reduced and the query runs faster.

[[enumfunctions]]
==== Enumeration

[cols="4,3,3,6"]
|===
|Function |Argument Type |Return Value |Description

|`relenc( _x_ )` [[_relenc]]
|_str_
|_int_
|Return the internal enumeration code for relationship _x_. If _x_ is an integer then _x_ is returned, otherwise if _x_ is not a string 0 is returned.

|`typeenc( _x_ )` [[_typeenc]]
|_str_
|_int_
|Return the internal enumeration code for vertex type _x_. If _x_ is an integer then _x_ is returned, otherwise if _x_ is not a string 0 is returned.

|`reldec( _x_ )` [[_reldec]]
|_int_
|_str_
|Return the relationship string for internal enumeration code _x_. The default string +"__UNKNOWN__"+ is returned if integer _x_ is not a valid enumeration code. If _x_ is not an integer _x_ is returned.

|`typedec( _x_ )` [[_typedec]]
|_int_
|_str_
|Return the vertex type string for internal enumeration code _x_. The default string +"__UNKNOWN__"+ is returned if integer _x_ is not a valid enumeration code. If _x_ is not an integer _x_ is returned.

|`modtostr( _x_ )` [[_modtostr]]
|`M_*`
|_str_
|Return the string representation of <<../constants/arcModifierConstants.adoc#, arc modifier constant>> _x_. If _x_ is not a valid modifier constant the result is undefined.

|`dirtostr( _x_ )` [[_dirtostr]]
|`D_*`
|_str_
|Return the string representation of <<../constants/arcDirectionConstants.adoc#, arc direction constant>> _x_. If _x_ is not a valid direction constant the result is undefined.

|===

.Example: Miscellaneous enumerations
[source, python]
----
graph.Evaluate( "modtostr( 5 )" )      -> "M_INT"
graph.Evaluate( "relenc( 'likes' )" )  -> 3229  (may vary!)
graph.Evaluate( "reldec( 3229 )" )     -> "likes"
----

[[similarityfunctions_feature]]
==== Similarity (Feature Vectors)

[cols="4,3,3,1,6"]
|===
|Function |Argument Type |Return Value |Return Type |Description

|`sim( _v1_, _v2_ )` [[_sim_feature]]
|<<../similarity/vector.adoc#, _vector_>>
|latexmath:[ s \in \lbrack 0, 1 \rbrack ]
|_float_
|Compute the <<../similarity/similarityMethods.adoc#similaritysimilarity, similarity score>> _s_ for vectors _v1_ and _v2_.

|`cosine( _v1_, _v2_ )` [[_cosine_feature]]
|<<../similarity/vector.adoc#, _vector_>>
|latexmath:[ c \in \lbrack 0, 1 \rbrack ]
|_float_
|Compute the <<../similarity/similarityMethods.adoc#similaritycosine, cosine similarity>> _c_ for vectors _v1_ and _v2_.

|`jaccard( _v1_, _v2_ )` [[_jaccard_feature]]
|<<../similarity/vector.adoc#, _vector_>>
|latexmath:[ J \in \lbrack 0, 1 \rbrack ]
|_float_
|Compute the <<../similarity/similarityMethods.adoc#similarityjaccard, Jaccard index>> _J_ for vectors _v1_ and _v2_.

|`hamdist( _v1_, _v2_ )` [[_hamdist_feature]]
|<<../similarity/vector.adoc#, _vector_>>
|latexmath:[ h \in \lbrack 0, 64 \rbrack ]
|_int_
|Compute the hamming distance _h_ (i.e. number of differing bits) between the fingerprints for vectors _v1_ and _v2_.

|===

.Example: Feature Vector similarity calculation
[source, python]
----
A = graph.NewVertex( "A" )
B = graph.NewVertex( "B" )
A.SetVector( [ ("hello",1), ("world",1) ] )
B.SetVector( [ ("hello",1), ("there",1) ] )

# -> 0.5
graph.Evaluate( "sim( vertex.vector, next.vector )", tail="A", head="B" )
----

[[similarityfunctions_array]]
==== Similarity (Euclidean Vectors)

[cols="4,3,3,6"]
|===
|Function |Argument Type |Return Value |Description

|`sim( _v1_, _v2_ )`
 +
 `cosine( _v1_, _v2_ )` [[_sim_array]]
|<<../similarity/vector.adoc#, _vector_>>
|latexmath:[ s \in \lbrack -1, 1 \rbrack ]
|Compute the <<../similarity/similarityMethods.adoc#similaritycosine, cosine similarity>> _s_ for vectors _v1_ and _v2_.

|`hamdist( _v1_, _v2_ )` [[_hamdist_array]]
|<<../similarity/vector.adoc#, _vector_>>
|latexmath:[ h \in \lbrack 0, 64 \rbrack ]
|Compute the hamming distance _h_ (i.e. number of differing bits) between the fingerprints for vectors _v1_ and _v2_.

|===

.Example: Euclidean Vector similarity calculation
[source, python]
----
A = graph.NewVertex( "A" )
B = graph.NewVertex( "B" )
A.SetVector( [ 0.8, 0.2, -0.9, 0.7 ] + [0]*28 )
B.SetVector( [ 0.3, 0.2, -0.5, 0.5 ] + [0]*28 )

# -> 0.9672
graph.Evaluate( "sim( vertex.vector, next.vector )", tail="A", head="B" )
----

// cspell:ignore kmin kmax
[[controlfunctions]]
==== Control Functions

[cols="5,2,5"]
|===
|Function | Return Value |Description

|`return( _x_ )` [[_return]]
|_x_
|Immediately terminate execution of expression and set the return value of the expression to _x_.

|`returnif( _cond_, _x_ )` [[_returnif]]
|_x_ if _cond_ is true, otherwise 0
|If _cond_ is true, immediately terminate execution of expression and set the return value of the expression to _x_. If _cond_ is false this function returns 0 and execution continues.

|`require( _cond_ )` [[_require]]
|0
|If _cond_ is true this function returns 0 and execution continues. If _cond_ is false, immediately terminate execution of expression and set the return value of the expression to 0. 

|`halt()` [[_halt]]
|1 if halted, else 0
|Terminate execution of query containing this expression. Evaluation of expression continues until completion, after which all other query activity is terminated immediately without raising an exception. This function returns 1 if termination will occur, or 0 if query cannot be terminated.

|`haltif( cond )` [[_haltif]]
|_cond_
|If _cond_ is true <<_halt, perform `halt()`>>.

|`halted()` [[_halted]]
|1 if halted, 0 if not halted
|Return the status of query execution termination.

|`continue()` [[_continue]]
|1
|Continue query execution. If query execution was <<_halt, previously halted>>, termination is cancelled and the query continues executing.

|`continueif( cond )` [[_continueif]]
|_cond_
|If _cond_ is true, continue query execution. If query execution was <<_halt, previously halted>>, termination is cancelled and the query continues executing.

|`firstval( _x~1~_, _x~2~_, ..., _x~n~_ )` [[_firstval]]
|_x~kmin~_
|Return the leftmost argument _x~kmin~_ that is a valid numeric value or other object other than `null`. If none of the arguments are valid values the last argument _x~n~_ is returned.

|`lastval( _x~1~_, _x~2~_, ..., _x~n~_ )` [[_lastval]]
|_x~kmax~_
|Return the rightmost argument _x~kmax~_ that is a valid numeric value or other object other than `null`. If none of the arguments are valid values the first argument _x~1~_ is returned.

|`do( _<expr~1~>_, ..., _<expr~n~>_ )` [[_do]]
|_true_
|Evaluate any number of sub-expressions _<expr~k~>_ (discarding their return values) and finally return _true_. This provides a way to execute expressions that don't contribute directly to the overall expression result value, but may be needed for their side-effects such as operating on memory locations that will be used later.

|`void( _<expr~1~>_, ..., _<expr~n~>_ )` [[_void]]
|`null`
|Evaluate any number of sub-expressions _<expr~k~>_ (discarding their return values) and finally return `null`. This provides a way to execute expressions that don't contribute directly to the overall expression result value, but may be needed for their side-effects such as operating on memory locations that will be used later.

|===

.Example: Miscellaneous control function calls
[source, python]
----
# Use return() for clarity
graph.Evaluate( "a=1+2; return( a )" ) -> 3

# Stop execution when returnif() condition satisfied
V = graph.NewVertex("V")
V['x'] = 1
V['y'] = 2
graph.Evaluate( "a=next['x']; returnif(a,a); next['y']", head="V" ) -> 1

# Return first argument
graph.Evaluate( "firstval()" ) -> nan
graph.Evaluate( "firstval( 1, 2, 3, 4 )" ) -> 1
graph.Evaluate( "firstval( -1/-0.0, asin(2), 42, 43 )" ) -> 42
A = graph.NewVertex( "A" )
graph.Evaluate( "firstval( vertex['xxx'], 123 )", tail="A" ) -> 123

# Return last argument
graph.Evaluate( "lastval( 1, 2, 3, 4 )" )  -> 4

# Execute anything and return 1
graph.Evaluate( "do()" ) -> 1
graph.Evaluate( "do( 0, 0/-0.0)" ) -> 1

# Execute anything and return nan
graph.Evaluate( "void( 1, 2, 3 )" ) -> nan
----

[[variadicaggregatorfunctions]]
==== Variadic Aggregator Functions

[cols="5,3,3,5"]
|===
|Function | Return Value |Description |Comment

|`sum( _x~1~_, _x~2~_, ..., _x~n~_ )` [[_sum]]
// |&#8721; _x~i~_
|latexmath:[ y = \displaystyle \sum_{i=1}^n x_i ]
|Sum of all numeric arguments _x_~i~
|

|`sumsqr( _x~1~_, _x~2~_, ..., _x~n~_ )` [[_sumsqr]]
// |&#8721; _x~i~_^2^
|latexmath:[ y = \displaystyle \sum_{i=1}^n x_i^2 ]
|Sum of the squares of all numeric arguments _x_~i~
|

|`stdev( _x~1~_, _x~2~_, ..., _x~n~_ )` [[_stdev]]
// |&#8721; _x~i~_^2^
|latexmath:[ y = \displaystyle \sqrt{ \frac{\displaystyle \sum_{i=1}^n {x_i^2} - \frac{\left( \sum_{i=1}^n {x_i} \right) ^ 2}{n}}{n-1} } ]
|Standard deviation of numeric arguments _x_~i~
|

|`invsum( _x~1~_, _x~2~_, ..., _x~n~_ )` [[_invsum]]
// |&#8721; (1/_x~i~_)
|latexmath:[ y = \displaystyle \sum_{i=1}^n \frac{1}{x_i} ]
|The inverse sum of all numeric arguments _x_~i~
|(_x_~i~)^&#8722;1^ &#8776; 8.5&#183;10^38^ when _x_~i~ = 0


|`prod( _x~1~_, _x~2~_, ..., _x~n~_ )` [[_prod]]
// |&#8719; _x~i~_
|latexmath:[ y = \displaystyle \prod_{i=1}^n x_i ]
|Product of all numeric arguments _x_~i~
|

|`mean( _x~1~_, _x~2~_, ..., _x~n~_ )` [[_mean]]
// |(&#8721; _x~i~_) / _n_
|latexmath:[ y = \frac{1}{n} \displaystyle \sum_{i=1}^n x_i ]
|Arithmetic mean (i.e. average) of all numeric arguments _x_~i~
|

|`harmmean( _x~1~_, _x~2~_, ..., _x~n~_ )` [[_harmmean]]
// |((&#8721; _x~i~^&#8722;1^_) / _n_ ) ^&#8722;1^
|latexmath:[ y = \left( \frac{1}{n} \displaystyle \sum_{i=1}^n \frac{1}{x_i} \right) ^ {-1} ]
|Harmonic mean of all numeric arguments _x_~i~
|(_x_~i~)^&#8722;1^ &#8776; 8.5&#183;10^38^ when _x_~i~ = 0

|`geomean( _x~1~_, _x~2~_, ..., _x~n~_ )` [[_geomean]]
// |(&#8719; _x~i~_)^(1/_n_)^
|latexmath:[ y = \displaystyle \sqrt[n\]{ \prod_{i=1}^n x_i } ]
|Geometric mean of all numeric arguments _x_~i~
|

|===

[TIP]
====
These functions also accept numeric array vertex properties as x~i~. When multiple properties and/or scalar x~i~ are mixed, the result is as if all arrays were flattened prior to the operation.
====

.Example: Aggregator function calls
[source, python]
----
graph.Evaluate( "sum( 2, 2, 3, 5, 7 )" ) -> 19
graph.Evaluate( "sumsqr( 2, 2, 3, 5, 7 )" ) -> 91
graph.Evaluate( "stdev( 2, 2, 3, 5, 7 )" ) -> 2.17...
graph.Evaluate( "invsum( 2, 2, 3, 5, 7 )" ) -> 1.68...
graph.Evaluate( "prod( 2, 2, 3, 5, 7 )" ) -> 420
graph.Evaluate( "mean( 2, 2, 3, 5, 7 )" ) -> 3.8
graph.Evaluate( "harmmean( 2, 2, 3, 5, 7 )" ) -> 2.98...
graph.Evaluate( "geomean( 2, 2, 3, 5, 7 )" ) -> 3.35...
----

// cspell:ignore geodist
[[simplerankingfunctions]]
==== Simple Ranking Functions

[cols="6,4,6"]
|===
|Function | Return Value |Description

|`rank( _x~1~_, _x~2~_, ..., _x~n~_ )` [[_rank]]
// |_next_~c1~&#183;&#8721; _x~i~_ + _next_~c0~
|latexmath:[ y = \text{next.c1} \cdot \displaystyle \sum_{i=1}^n x_i + \text{next.c0} ]
|Compute a rank score _y_ for head vertex _next_ using its <<../vertex/vertexRank.adoc#, ranking coefficients>> `c1` and `c0` to evaluate `y=c1&#183;X+c0`, where `X` is the sum of all arguments _x_~i~.

|`prox( _a_, _b_ )` [[_prox]]
// |256 / ( 256 + \| _a_ &#8722; _b_ \| )
|latexmath:[ y = \displaystyle \frac{256}{256 + \| a-b \| } ]
|Compute a proximity score latexmath:[ y \in \langle 0,1 \] ] for values _a_ and _b_. The result is equal to 1.0 when _a_ = _b_, and moves towards 0.0 as latexmath:[ \|a-b\| \to \infty].

|`geodist( _lat~A~_, _lon~A~_, _lat~B~_, _lon~B~_)` [[_geodist]]
// |6371001 &#183; 2 &#183; _atan2_( _sqrt_( _sin_^2^( _rad_( _lat~2~_ &#8722; _lat~1~_ ) / 2 ) + _cos_( _rad_( _lat~1~_ ) ) &#183; _cos_( _rad_( _lat~2~_ ) ) &#183; _sin_^2^( _rad_( _lon~2~_ &#8722; _lon~1~_ ) / 2 ) ), _sqrt_( 1 &#8722; (_sin_^2^( _rad_( _lat~2~_ &#8722; _lat~1~_ ) / 2 ) + _cos_( _rad_( _lat~1~_ ) ) &#183; _cos_( _rad_( _lat~2~_ ) ) &#183; _sin_^2^( _rad_( _lon~2~_ &#8722; _lon~1~_ ) / 2 ) ) ) )
|latexmath:[ y = \begin{cases} 6371001 \cdot 2 \cdot \arctan{ \frac{\sqrt{a}}{\sqrt{1-a}}} & \quad \text{if } a < 1 \\ 6371001 \cdot \pi & \quad \text{if } a = 1 \end{cases} ]
 +
 +
 latexmath:[ a = \frac{1 - \cos( \varphi_B - \varphi_A )}{2} + \cos{\varphi_A} \cdot \cos{\varphi_B} \cdot \frac{1 - \cos( \lambda_B - \lambda_A )}{2} ]
 +
 +
 latexmath:[ \varphi_x = \displaystyle \frac{ \pi \cdot lat_x}{180} ]
 +
 +
 latexmath:[ \lambda_x = \displaystyle \frac{ \pi \cdot lon_x}{180} ]
|Compute approximate distance in meters between two geographic locations A = ( _lat~A~_, _lon~A~_ ) and B = ( _lat~A~_, _lon~A~_ ). This formula simplifies the calculation by assuming the Earth is a sphere, leading to small errors up to 0.5%.
 +
This function expects arguments in degrees.

|`geoprox( _lat~1~_, _lon~1~_, _lat~2~_, _lon~2~_)` [[_geoprox]]
// |1 &#8722; _geodist_( _lat~1~_, _lon~1~_, _lat~2~_, _lon~2~_ ) / ( 6371001 &#183; &#928;)
|latexmath:[ y = 1 - \displaystyle \frac{ g(lat_A,lon_A,lat_B,lon_B)}{6371001 \cdot \pi} ]
 +
 +
 where latexmath:[ g() ] is the `geodist()` function.
// |Compute a geographic proximity score &#8714;<0,1] for two locations A = ( _lat~1~_, _lon~1~_ ) and B = ( _lat~2~_, _lon~2~_ ). A location will have a proximity score 1.0 to itself and 0.0 to a point on the opposite side of the Earth.
|Compute a geographic proximity score latexmath:[ y \in \langle 0,1\] ] for two locations A = ( _lat~1~_, _lon~1~_ ) and B = ( _lat~2~_, _lon~2~_ ). A location will have a proximity score 1.0 to itself and 0.0 to a point on the opposite side of the Earth.
 +
This function expects arguments in degrees.

|`georank( _v_ )`
 +
`georank( _lat_, _lon_ )` [[_georank]]
|latexmath:[ y = \begin{cases} p(\text{next}_{c1},\text{next}_{c0},v_{c1},v_{c0}) & \quad \text{if one arg} \\ p(\text{next}_{c1},\text{next}_{c0},lat,lon) & \quad \text{if two args} \end{cases}]
 +
 +
 where latexmath:[ p() ] is the `geoprox()` function.
|Compute a rank score _y_ for head vertex _next_ as a function of its geographic proximity to another vertex _v_ or to a location given by _lat_ and _lon_. The coordinates of head vertex _next_ are determined by its <<../vertex/vertexRank.adoc#, ranking coefficients>> where `c1=latitude` and `c0=longitude`. When a single _v_ argument is provided it is interpreted as a vertex instance whose latitude and longitude are represented by that instance's `c1` and `c0` coefficients. When two arguments _lat_ and _lon_ are provided they are interpreted as the coordinates against which _next_ will be compared. All values of `c1`, `c0`, _lat_, and _lon_ are expressed in degrees.

|===


.Example: Miscellaneous ranking functions
[source, python]
----
graph.Evaluate( "prox( 1000, 1050 )" ) -> 0.8366...
graph.Evaluate( "geodist( 42.3, 71.0, 35.7, -139.7 )" ) -> 10797873.8
A = graph.NewVertex( "A" )
A.c0 = 1000
A.c1 = 2.5
graph.Evaluate( "rank()", head="A") -> 1000.0
graph.Evaluate( "rank(10)", head="A") -> 1025.0
graph.Evaluate( "rank(10,1,2)", head="A") -> 1032.5
----

[[collectorstagingfunctions]]
==== Collector Staging Functions

[cols="6,4,5"]
|===
|Function | Return Value |Description

|`stage( [ _value_[, _slot_] ] )`
|latexmath:[ y = \begin{cases} 1 & \quad \text{if arc staged} \\ 0 & \quad \text{if not staged} \\ -1 & \quad \text{if error} \end{cases} ]
|Store the currently traversed arc (i.e. `next.arc`) into temporary staging buffer _slot_=0. Optionally override the staged arc's value with _value_. Optionally specify staging buffer latexmath:[ slot \in \{0,1,2,3\} ].

|`stageif( _cond_ [, _value_[, _slot_] ] )`
|_cond_
|If condition _cond_ is true store the currently traversed arc (i.e. `next.arc`) into temporary staging buffer _slot_=0. Optionally override the staged arc's value with _value_. Optionally specify staging buffer latexmath:[ slot \in \{0,1,2,3\} ].

|`unstage( [ _slot_ ] )`
|latexmath:[ y = \begin{cases} 1 & \quad \text{if arc unstaged} \\ 0 & \quad \text{if not unstaged} \\ -1 & \quad \text{if error} \end{cases} ]
|Remove any staged arc from selected _slot_, which defaults to 0 if not specified.

|`unstageif( _cond_ [, _slot_ ] )`
|_cond_
|if condition _cond_ is true remove any staged arc from selected _slot_, which defaults to 0 if not specified.

|`commit( [ _slot_ ] )`
|latexmath:[ y = \begin{cases} 1 & \quad \text{if arc collected} \\ 0 & \quad \text{if not collected} \\ -1 & \quad \text{if error} \end{cases} ]
|Collect staged arc in selected _slot_ into result set. Default _slot_=0.

|`commitif( _cond_ [, _slot_ ] )`
|_cond_
|If _cond_ is true collect staged arc in selected _slot_ into result set. Default _slot_=0.

|`collect( [ _value_ ] )`
|latexmath:[ y = \begin{cases} 1 & \quad \text{if arc collected} \\ 0 & \quad \text{if not collected} \\ -1 & \quad \text{if error} \end{cases} ]
|Collect the currently traversed arc (i.e. `next.arc`) directly into the result set (bypassing any temporary staging.) Optionally override the collected arc's value with _value_.

|`collectif( _cond_ [, _value_ ] )`
|_cond_
|If condition _cond_ is true collect the currently traversed arc (i.e. `next.arc`) directly into the result set (bypassing any temporary staging.) Optionally override the collected arc's value with _value_.

|===

.Example: Collect neighbor's neighbor arc with the highest value and return the top 10 of those arcs
[source, python]
----
graph.Neighborhood( 
  "A",
  hits     = 10,
  neighbor = {
    'filter'   : "do( store( R1, 0 ) )",
    'adjacent' : {
      'arc'      : ( "to", D_OUT ),
      'filter'   : """
                   void( 
                       storeif(
                           stageif( next.arc.value > load( R1 ) ),
                           R1,
                           next.arc.value
                       )
                   )
                   """
    },
    'post'     : "commit()"
  },
  sortby   = S_VAL
)
----

[[bfssupport]]
==== Breadth-First Search Support

[cols="4,3,6"]
|===
|Function | Return Value |Description

|`mcull( _score_, _k_ )` [[_mcull]]
|latexmath:[ y = \begin{cases} 1 & \text{if cand.} \\ 0 & \text{if not cand.} \end{cases} ]
|When executed in a `'neighbor': {}` vertex condition perform exhaustive evaluation of neighborhood level before any traversal to a deeper neighborhood, constraining the number of vertices that can be anchors for deeper traversal to the at most _k_ vertices with the highest (positive) numeric _score_.

|`mcullif( _cond_, _score_, _k_ )` [[_mcullif]]
|_cond_
|Same as <<_mcull, `mcull()`>> but with the added constraint that _cond_ must be true for the vertex to be a candidate.

|===

[NOTE]
====
Use of this function is restricted to the local filter evaluator in Neighborhood()'s' `'neighbor': {}` vertex condition.

The presence of `mcull()` / `mcullif()` in a local filter changes the traversal and collection behavior from depth-first to breadth-first. The top-_k_ scoring vertices in the neighborhood are selected _before_ collection of vertices or traversal of vertices' next-level neighborhoods.

A return value 1 from `mcull()` does not mean the visited vertex will be in the final top _k_, only that at the time of its evaluation it is among the top _k_ visited up until that point.
====

.Example: Collect arcs from A's top-5 highest out-degree neighbors

[source, python]
----
graph.Neighborhood( 
  "A",
  collect  = C_NONE,
  neighbor = {
    'filter'   : "mcull( vertex.odeg, 5 )",
    'traverse' : {
      'arc'     : D_OUT,
      'collect' : C_COLLECT 
    }
  }
)
----

.Example: Collect arcs from A's top-5 highest out-degree neighbors, and from those neighbors' neighbors top-3 highest in-degree neighbors

[source, python]
----
graph.Neighborhood( 
  "A",
  collect  = C_NONE,
  neighbor = {
    'filter'   : "mcull(vertex.odeg, 5)",
    'traverse' : {
      'arc'     : D_OUT,
      'collect' : C_COLLECT,
      'neighbor' : {
        'filter'   : "mcull(vertex.ideg, 3)",
        'traverse' : {
            'arc'     : D_OUT,
            'collect' : C_COLLECT
        }
      }
    }
  }
)
----

// cspell:ignore defaultmem memarray memreg memstack
[[evaluatormemory]]
== Evaluator Memory

<<../reference.adoc#memoryobject, Memory arrays>> can be used to implement advanced algorithms. By default a graph query allocates a temporary memory array for use with expressions in the query. This memory is initialized to empty before the query starts executing and is deleted once the query completes.

.Default memory array
image::defaultmem.png[fig_defaultmem]

The default memory array contains eight slots 0 - 7. The last four slots are also accessible as <<evaluatormemoryregisters>> via index aliases `R1`, `R2`, `R3`, and `R4`. A virtual <<evaluatormemorystack>> starts at the index labeled SP and grows downward.

Memory arrays use <<evaluatormemoryindexing, modulo indexing>> allowing both positive and negative indices, as well as indices beyond the array end points which are aliased to slots within the array.

Memory array objects can be created with <<../reference.adoc#memoryobject, pyvgx.Memory()>> and passed to graph queries using the <<../graph/graphQuery.adoc#graphneighborhood, `memory=` query parameter>>. Queries will then use the supplied memory array instead of the default. The memory array is not initialized by the query and will remain after the query completes. A query may read and/or modify the memory array via one or more expressions in the query. The same memory object can be passed to subsequent queries for further processing.

Memory array objects are accessible from Python as regular list objects.
 
Memory array objects can have any size, only limited by system resources. Size is always a power of two, 2^_p_^ where _p_ is the array _order_.

.Memory array object with 2^_p_^ slots (order=_p_)
image::memarray.png[fig_memarray]

.Example: Create arc value histogram
[source, python]
----
# Assumption: arc values are 0-99
# Create array with 100 slots (actual size will be 128)
mem = graph.Memory( 100 ) # size rounded up to nearest power of two
graph.Neighborhood(
    id     = "A",
    memory = mem,
    filter = "inc( int(.arc.value) )"
)
mem[0]  # freq of val=0
mem[1]  # freq of val=1
mem[2]  # freq of val=2
#...
mem[99] # freq of val=99
----

[[evaluatormemoryregisters]]
=== Memory Registers

The last four slots in a memory object are the registers R1 - R4. There is nothing special about these slots other than the convenience of being able to reference them in expressions using predefined index constants `R1`, `R2`, `R3`, and `R4`.

.Four registers at end of memory array
image::memreg.png[fig_memreg]

.Example: Use memory registers
[source, python]
----
mem = graph.Memory( 16 )
graph.Evaluate( "store(R1, 111)", memory=mem )
graph.Evaluate( "store(R2, 222)", memory=mem )
mem[ R1 ]         # -> 111 (memory object as list)
mem.R1            # -> 111 (memory object attribute)
mem[ -1 ]         # -> 111 (indexing from end)
mem[ 15 ]         # -> 111 (indexing from start)
mem.R1 + mem.R2   # -> 333
graph.Evaluate( "load(R1)*load(R2)", memory=mem ) -> 24642
----

NOTE: To access the contents of a register it must be dereferenced using functions like `load()`, `store()`, etc., as shown in the example above. I.e. a constant like `R1` is just the number `-1` which represents a memory address.

[[evaluatormemorystack]]
=== Memory Stack

A virtual "stack" starts just below the registers and grows downward. A `push` operation puts a value on the stack and a `pop` operation removes a value from the stack and returns it. If the stack reaches the bottom of the array (index 0) it wraps around to the top overwriting register `R1`, then `R2`, etc. Likewise, repeated `pop` operations will move the stack pointer upwards wrapping to 0 when the last index is reached. Be careful to allocate a large enough array to accommodate the algorithm using it and to ensure balanced `push` and `pop` operations.

.Memory stack
image::memstack.png[fig_memstack]

CAUTION: Using `push` and `pop` provides no protection against unbalanced calls. Make sure your algorithm is guaranteed to execute an equal number of each operation to avoid leaking the stack into other areas of the memory array you may be using for other purposes.

.Example: Using the virtual stack
[source, python]
----
mem = graph.Memory( 16 )
graph.Evaluate( "push( 111 )", memory=mem )
graph.Evaluate( "push( 222 )", memory=mem )
graph.Evaluate( "push( 333 )", memory=mem )
mem[ 11 ]   # -> 111
mem[ 10 ]   # -> 222
mem[ 9 ]    # -> 333
graph.Evaluate( "pop()", memory=mem )   -> 333
graph.Evaluate( "pop()", memory=mem )   -> 222
graph.Evaluate( "pop()", memory=mem )   -> 111
----

// cspell:ignore moduloindexing
[[evaluatormemoryindexing]]
=== Memory Indexing

Memory arrays are modulo indexed, protecting system memory from invalid access and allowing negative indices to reference the array relative to its end. Although primarily included as a safeguard against invalid memory access you may find modulo indexing to be a useful feature when implementing certain algorithms.

.Memory array slots have multiple aliases due to modulo indexing
image::moduloindexing.png[fig_moduloindexing]

.Example: Modulo indexing
[source, python]
----
mem = graph.Memory( 16 )
graph.Evaluate( "store( 3, 555 )", memory=mem )
graph.Evaluate( "load( 3 )", memory=mem )    ->   555
graph.Evaluate( "load( 19 )", memory=mem )    ->   555
graph.Evaluate( "load( -13 )", memory=mem )     ->   555
----

TIP: To restrict the indexing span to a sub-range of the array use <<_modindex, the `modindex()` function>> to compute the array index.

[[evaluatormemorypython]]
=== Memory Python Interface for Assignment and Lookup

The <<../reference.adoc#memoryobject, Python interface for accessing `pyvgx.Memory` elements>> is similar to `list`. Lookup and assignment use the standard array subscript syntax `[n]` and slice syntax `[a:b]`.

[[evaluatormemorysubscript]]
==== Memory Subscript

For subscript syntax `[n]` the behavior is the same as for `list`.

.Memory subscript and value types (assignment)
[cols="6,3,3,5"]
|===
|Syntax |Python Value Type |Stored Value Type| Description

|`memobj[ _n_ ] = _value_`
|_int_
|_integer_
|Assign an integer _value_ to memory location _n_

|`memobj[ _n_ ] = _value_`
|_float_
|_real_
|Assign a real _value_ to memory location _n_

|`memobj[ _n_ ] = _value_`
|_str_
|_string_
|Assign a string _value_ to memory location _n_

|`memobj[ _n_ ] = _value_`
|_pyvgx.Vector_
|_vector_
|Assign a _vector_ object to memory location _n_

|`memobj[ _n_ ] = [ _value_ ]`
|[ _int_ ]
|_bitvector_
|Assign integer _value_ as a 64-bit bitvector to memory location _n_

|`memobj[ _n_ ] = ( _key_, _value_ )`
|( _int_, _float_ )
|_keyval_
|Assign a _keyval_ tuple to memory location _n_

|`memobj[ _n_ ] = bytearray( _list_ )`
|_bytearray_
|raw bytes
|Assign an array of raw (unsigned) bytes to memory location _n_

|`memobj[ _n_ ] = bytes( _data_ )`
|_bytes_
|raw bytes (immutable)
|Assign an immutable array of (unsigned) bytes to memory location _n_

|===

.Memory subscript and value types (lookup)
[cols="3,6,3,5"]
|===
|Syntax |When Stored Value Type Is... |Python Value Type| Description

|`memobj[ _n_ ]`
|_integer_
|_int_
|Retrieve an integer value from memory location _n_ as a Python _int_

|`memobj[ _n_ ]`
|_real_
|_float_
|Retrieve a real value from memory location _n_ as a Python _float_

|`memobj[ _n_ ]`
|_string_
|_str_
|Retrieve a string value from memory location _n_ as a Python _str_

|`memobj[ _n_ ]`
|_vector_
|_pyvgx.Vector_
|Retrieve a vector object from memory location _n_ as pyvgx.Vector

|`memobj[ _n_ ]`
|_bitvector_
|[ _int_ ]
|Retrieve a bitvector from memory location _n_ as a Python _list_ with a single _int_ value  

|`memobj[ _n_ ]`
|_keyval_
|( _int_, _float_ )
|Retrieve a keyval from memory location _n_ as a Python _tuple_ with a 32-bit integer key and a single precision float value

|`memobj[ _n_ ]`
|raw bytes
|_bytearray_
|Retrieve a sequence of raw bytes from memory location _n_ as a Python _bytearray_ object

|`memobj[ _n_ ]`
|raw bytes
|_bytes_
|Retrieve an array of bytes from memory location _n_ as a Python _bytes_ object

|===

.Memory indexing
[source, python]
----
mem = graph.Memory(32)
mem[10] = 1234      # Assign 1234 to memory location 10
mem[11] = 3.14      # Assign 3.14 to memory location 11
mem[12] = "hello"   # Assign string "hello" to memory location 13
mem[13] = [0xFF00]  # Assign bitvector 0xFF00 to memory location 12
mem[14] = (42, 1.7) # Assign keyval 42:1.7 to memory location 14
mem[15] = bytearray( [10,20,0,0,50] ) # Assign raw bytes to mem 15
mem[16] = bytes( [1,2,3,4] ) # Assign raw bytes to mem 16
mem[17] = graph.sim.rvec(64) # Assign random vector to mem 17

# int
list( mem[10] )       # <class 'int'>
print( mem[10] )      # 1234
print( mem[-22] )     # 1234 (modulo indexing)

# float
type( mem[11] )       # <class 'float'>
print( mem[11] )      # 3.14

# str
type( mem[12] )       # <class 'str'>
print( mem[12] )      # hello

# bitvector
type( mem[13] )       # <class 'list'>
print( mem[13] )      # [65280]

# key/val
type( mem[14] )       # <class 'tuple'>
print( mem[14] )      # (42, 1.7000000476837158)

# bytearray
type( mem[15] )       # <class 'bytearray'>
list( mem[15] )       # [10, 20, 0, 0, 50]

# bytes
type( mem[16] )       # <class 'bytes'>
list( mem[16] )       # [1,2,3,4]

# vector
type( mem[17] )       # <class 'pyvgx.Vector'>
print( mem[17] )      # <PyVGX_Vector: ...>

----

[[evaluatormemoryslice]]
==== Memory Slice

For slice syntax `[a:b]` the behavior is the same as for `list` with the exception of assignment which differs when the assignment list is smaller than the slice. The memory object is updated by applying the new values starting from the beginning of the slice and leaving the end of the slice unmodified. The behavior of `list` is to replace the entire slice with the new assigned values.

Just as for `list` slices may omit either end point, and negative indices reference backwards from the end.

.Memory slice and value types
[cols="5,4,4"]
|===
|Syntax |Value Types| Description

|`memobj[ _a:b_ ] = [ _v~1~_,_v~2~_,...,_v~n~_ ]`
|_int_ -> _integer_
 +
 _float_ -> _real_
 +
 _str_ -> _string_
 +
 [_int_] -> _bitvector_
 +
 (_int_,_float_) -> _keyval_
 +
 _bytearray_ -> raw bytes
 +
 _bytes_ -> raw bytes
|Assign values _v~1~_ through _v~n~_ to memory locations starting at _a_. If _n < b - a_ the end of the memory slice remains unaffected. (This behavior is different from Python `list`.)

|`memobj[ _a:b_ ]`
|_int_ <- _integer_
 +
 _float_ <- _real_
 +
 _str_ <- _string_
 +
 [_int_] <- _bitvector_
 +
 (_int_,_float_) <- _keyval_
 +
 _bytearray_ <- raw bytes
 +
 _bytes_ <- raw bytes
|Return a list of values from memory locations _a_ through _b - 1_.

|===

.Memory slices
[source, python]
----
mem = graph.Memory(8)
mem[4:8] = [44,55,66,7.89]  # Assign multiple values to slice
mem[4:8] = [444,555]        # Partial slice assignment
print( mem[4:8] )           # [444, 555, 66, 7.89]

print( mem[:] )             # [0, 0, 0, 0, 444, 555, 66, 7.89]
print( mem[:5] )            # [0, 0, 0, 0, 444]
print( mem[3:] )            # [0, 444, 555, 66, 7.89]
print( mem[:-2] )           # [0, 0, 0, 0, 444, 555]
----

[[evaluatormemoryinit]]
==== Memory Initialization

New memory objects can be initialized to specific values by passing an initializer list to the constructor. An existing memory object can have all its elements reset to a certain constant value or range of values.

.Memory object initialization and reset
[source, python]
----
# Construct using initializer
mem = graph.Memory( [100,1,1,1,50] )
# [100, 1, 1, 1, 50, 0, 0, 0]
len( mem ) # 8, smallest power of two to hold initializer

# Reset all elements to zero
mem.Reset()
# [0, 0, 0, 0, 0, 0, 0, 0]

# Reset all elements to 2.5
mem.Reset( 2.5 )
# [2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5]

# Reset elements to a range
mem.Reset( 1, 5 ) # First value is 1, step is 5
# [1, 6, 11, 16, 21, 26, 31, 36]
----

[[evaluatormemorysort]]
==== Memory Sort

Memory objects can be sorted. It is possible to sort the entire array or a specific range within the array. The element comparator used for sorting is automatically chosen by the type of the first element in the range to be sorted.

.Memory sorting
[source, python]
----
mem = graph.Memory( 32 )

# Randomize 16 elements 0 through 15
graph.Evaluate( "mrandomize(0,15)", memory=m )

# Sort 16-element range 0 through 15
mem.Sort( 0, 16 )

# Reverse sort
mem.Sort( 0, 16, reverse=True )

# Sort 28 non-register elements
mem.Sort()
----

[[evaluatormemoryvaluetypes]]
==== A Note on Memory Value Types

Although memory objects internally can hold elements of <<evaluatordatatypes, any type supported by the evaluator engine>>, the only element types accessible by the Python interpreter are _integer_, _real_, _string_, _bitvector_, _keyval_, _bytearray_ and _bytes_ which map to Python types or objects `int`, `float`, `str`, `[int]`, `(int,float)`, `bytearray` and `bytes`, respectively. Element types _null_, _nan_ and _inf_ in memory objects are accessed by the Python interpreter as Python type `float` with values _nan_, _nan_ and _inf_, respectively.

_integer_::
Maps directly to Python `int`
+
[source, python]
----
mem[0] = 123
graph.Evaluate( "isint(load(0))", memory=mem ) -> true
mem[0] -> 123
----

_real_::
Maps directly to Python `float`
+
[source, python]
----
mem[1] = 3.14
graph.Evaluate( "isreal(load(1))", memory=mem ) -> true
mem[1] -> 3.14
----

_string_::
This type is interpreted differently in different contexts. When accessing a Python memory object the evaluator _string_ type maps directly to Python `str` with implicit UTF-8 encoding internally. When the evaluator engine executes an expression the _string_ type also encompasses the _bytearray_ and _bytes_ types, i.e. the execution engine treats _bytearray_ and _bytes_ as subtypes of _string_.
+
[source, python]
----
mem[2] = 'hello'
g.Evaluate( "isstr(load(2))", memory=mem ) -> true
mem[2] -> 'hello'
----

_bitvector_::
This is a pseudo-type represented by a single-element Python `list` where the element is a Python `int`. Bitvectors are assigned as `mem[_n_] = [_bv_]`. When retrieving the bitvector value it is returned as a singleton list `[_bv_]`. Evaluator expressions can also assign bitvectors, e.g. `"store( 0, bitvector( 0xFF00 ) )"`.
+
[source, python]
----
mem[3] = [0xfff]
graph.Evaluate( "isbitvector(load(3))", memory=mem ) -> true
mem[3] -> [4095]
----

_keyval_::
This is a pseudo-type represented by a two-element Python `tuple` where the first element is a Python `int` and the second element is a Python `float`. Keyval items are assigned as `mem[_n_] = (_key_, _value_)`. Note that _key_ has a 32-bit range and _value_ is truncated to single precision internally.
+
[source, python]
----
mem[4] = (123,3.14)
graph.Evaluate( "iskeyval(load(4))", memory=m ) -> true
mem[4] -> 123, 3.140000104904175)
----

_bytearray_ and _bytes_::
These types are applicable only when interacting with memory objects from Python. The Python `bytearray` and `bytes` types are internally represented as subtypes of _string_, which means that evaluator expressions operate on all string data as arrays of bytes. When assigning to a memory location as `mem[_n_] = bytearray( ... )` or `mem[_n_] = bytes( ... )` the internal object is _string_ with attributes indicating the subtype.
+
[source, python]
----
mem[5] = bytearray([1,2,3])
graph.Evaluate( "isbytearray(load(5))", memory=mem ) -> true
graph.Evaluate( "isstr(load(5))", memory=mem ) -> true
mem[5] -> bytearray(b'\x01\x02\x03')

mem[6] = bytes([1,2,3])
graph.Evaluate( "isbytes(load(6))", memory=mem ) -> true
graph.Evaluate( "isstr(load(6))", memory=mem ) -> true
mem[6] -> b'\x01\x02\x03'
----

_null_, _nan_, _inf_::
These types indicating "no value" in various contexts are all interpreted as Python `float` when retrieved from memory objects. They cannot be set from Python.
+
[source, python]
----
graph.Evaluate( "store(7,null)", memory=mem ) -> None
type(mem[7]) -> <class 'float'>
mem[7] -> nan

graph.Evaluate( "store(8,nan)", memory=mem ) -> nan
type(mem[8]) -> <class 'float'>
mem[8] -> nan

graph.Evaluate( "store(9,inf)", memory=mem ) -> inf
type(mem[9]) -> <class 'float'>
mem[9] -> inf
----

_vector_::
Maps directly to Python `pyvgx.Vector`
+
[source, python]
----
mem[10] = g.sim.rvec(128)
g.Evaluate( "isvector(load(10))", memory=mem ) -> true
mem[10] -> '<PyVGX_Vector: typ=euclidean len=128 mag=6.948...'
----


[[evaluatormemory_note_on_strings]]
==== A note about strings and vectors in evaluator expressions

[CAUTION]
====
String and vector objects can be assigned to memory locations from within expressions and from the Python interpreter. The `pyvgx.Memory` instance becomes an owner of the assigned object, either by creating a copy or by owning an additional reference.

String and vector objects are retained by the `pyvgx.Memory` associated with the expression being evaluated. Each time a string-generating function (such as `str()` or `replace()`) is used, or a string or vector object is assigned to a memory location, the `pyvgx.Memory` instance will accumulate ownership of assigned objects even if the memory location is later overwritten by another value.

If a memory instance is long-lived manual cleanup of strings and vectors is required to avoid unbounded buildup of objects that are no longer in use. Cleanup is performed explicitly via `pyvgx.Memory.Reset()` or evaluator function <<_mreset, `"mreset()"`>>. (Cleanup is automatic when the `pyvgx.Memory` instance itself is deleted.)

Note that copying existing strings or vectors between memory locations _does not_ create new instances or additional ownership when performed by an expression. For instance, `"store( 0, str('hello') ); mov( 1, 0 )"` creates one new string object referenced from two separate memory locations, i.e. locations 0 and 1 point to the same string object owned _once_ by the memory object. (Python interpreter copy (e.g. `mem[1] = mem[0]`) is normal assignment and therefore creates new object ownership each time.)

====

.Example: Value Types
[source, python]
----
mem = graph.Memory( 16 )

mem[0] = 0xFF0000     # Type is integer
mem[1] = [ 0xFF0000 ] # Type is bitvector
mem[2] = 3.14         # Type is real
mem[3] = "Alice"      # Type is string
mem.R1 = graph.sim.rvec(64) # Type is vector
mem.R2 = graph.sim.rvec(64) # Type is vector

mem[0]                # -> 16711680
mem[1]                # -> [16711680]
mem[2]                # -> 3.14
mem[3]                # -> 'Alice'
mem.R1                # -> <PyVGX_Vector: ...>
mem.R2                # -> <PyVGX_Vector: ...>

graph.Evaluate( "isbitvector( load(0) )", memory=m ) # -> 0
graph.Evaluate( "isbitvector( load(1) )", memory=m ) # -> 1
graph.Evaluate( "mul( 2, 10 )", memory=m )           # -> 31.4
graph.Evaluate( "load( 3 ) == 'Ali*'  ", memory=m )  # -> 1
graph.Evaluate( "store( 4, 'Bob' )", memory=m )      # -> 'Bob'
graph.Evaluate( "mov( 5, 3 )", memory=m )            # -> 'Alice'
graph.Evaluate( "mov( 6, 4 )", memory=m )            # -> 'Bob'
graph.Evaluate( "isvector(r1)", memory=m )           # -> 1
graph.Evaluate( "cosine(r1,r2)", memory=m )          # -> 0.02157

# Strings 'Alice' and 'Bob', and vectors are now deleted
graph.Evaluate( "mreset()", memory=m )
----


[[evaluatormemoryreference]]
== Memory Operation Reference

* <<evaluatormemorysingle>>
* <<evaluatormemory_multiple>>
* <<evaluator_specialpurpose>>

=== Notation Conventions
The following notation is used to describe operations listed in all tables below.

IMPORTANT: This notation is for describing how functions work, and has no relation to expression syntax.

Simple Assignment `:=`::
The simple assignment operator `:=` assigns the right operand to the left operand. For example, to indicate assignment of value _x_ to memory location _a_ we write `[ _a_ ] := _x_`.

Operator Assignment `<op>=`::
When the value of a left operand is modified by the right operand the general `<op>=` syntax is used, such as `+=`, `/=`, `>>=`, etc. For example `[ _addr_ ] /= _x_` means the value at location _addr_ is divided by _x_ and the result written back to location _addr_.

Exchange `:=:`::
The exchange operator `:=:` swaps the two operands. For example, `[ _a_ ] :=: [ _b_ ]` means the values at memory locations _a_ and _b_ are swapped.

Dereference `[]`::
Dereference notation `[ _addr_ ]` is used to represent the contents at memory address _addr_.

Double Dereference `[[]]`::
Double dereference notation `[[ _addr_ ]]` is used to represent the contents at address stored at address _addr_. For example, `[[ _a_ ]] := _x_` means the value _x_ is written to memory location stored in location _a_. As a concrete example, if `_a_ = 1000` and the value `50` is stored in location `1000` then `[[ _a_ ]] = 7` will assign `7` to location `50`.

Range Dereference `[:]`::
Dereference notation `[ _a_ : _b_ ]` is used to indicate the contents of a range of addresses starting at address _a_ and ending at address _b_, both endpoints included. For example, to assign value _x_ to all memory locations starting at _a_ and ending at _b_ we write `[ _a_ : _b_ ] := _x_` When the right operand is or includes a range the right element _i_ is assigned to left element _i_. For example, `[ _a_ : _b_ ] := _operation_( [ _a_ : _b_ ] )` means the operation is applied to each element starting at location _a_ and ending at location _b_.

CAUTION: Operations taking a memory range input are *inclusive of the end index*. (This is different from how ranges are processed by the Python interpreter, where the end index is not included.) Negative indices are allowed. They count backwards from the element just beyond the end of the memory array, i.e. index `-1` references the very last element.

[[evaluatormemorysingle]]
=== Operations on Single Memory Locations

.Quick Links
[cols="4,6"]
|===
|Category |Functions

|<<evaluatormemorystoreload>>
|`store()`, `write()`, `load()`, etc.

|<<evaluatormemorystackops>>
|`push()`, `pop()`, etc.

|<<evaluatormemorymovingdata>>
|`mov()`, `xchg()`, etc.

|<<evaluatormemoryincdec>>
|`inc()`, `dec()`, etc.

|<<evaluatormemorycomparator>>
|`equ()`, `neq()`, `gt()`, `lte()`, etc.

|<<evaluatormemoryarithmetic>>
|`add()`, `sub()`, `mul()`, `div()`, etc.

|<<evaluatormemorybitwise>>
|`shr()`, `shl()`, `and()`, `or()`, `xor()`, etc.

|<<evaluatormemoryvector>>
|`dp_pi8()`, `cos_pi8()`, etc.

|<<evaluatormemoryvarious>>
|`smooth()`, `count()`, etc.

|<<evaluatormemoryindexingop>>
|`modindex()`, `index()`, etc.

|===

[[evaluatormemorystoreload]]
==== Storing and Loading

.Storing and Loading
[cols="15,13,5,12"]
|===
|Function |Operation |Ret | Description

4+|*Store*

|`store( _dest_, _x_ )` [[_store]]
|[_dest_] := _x_
|[_dest_]
|Assign numeric value _x_ to memory location _dest_ and return _x_

// cspell:ignore pdest
|`rstore( _pdest_, _x_ )` [[_rstore]]
|&#91;&#91; _pdest_ &#93;&#93; := _x_
|&#91;&#91; _pdest_ &#93;&#93;
|Assign numeric value _x_ to memory location pointed to by address in _pdest_ and return _x_

|`storeif( _cond_, _dest_, _x_ )` [[_storeif]]
|[_dest_] := _x_ if _cond_ == true
|_cond_
|If _cond_ is nonzero assign numeric value _x_ to memory location _dest_. Always returns _cond_.

|`rstoreif( _cond_, _pdest_, _x_ )` [[_rstoreif]]
|&#91;&#91; _pdest_ &#93;&#93; := _x_ if _cond_ == true
|_cond_
|If _cond_ is nonzero assign numeric value _x_ to memory location pointed to by address in _pdest_. Always returns _cond_.

4+|*Write*

|`write( _dest~1~_, _x~1~_, _x~2~_, ..., _x~n~_ )` [[_write]]
|[_dest~1~_ : _dest~n~_] := _x~1~_, _x~2~_, ..., _x~n~_
|_n_
|Assign _n_ numeric values _x~1~_ through _x~n~_ to a range of consecutive destinations starting at _dest~1~_. The number _n_ of values to write equals the number of value arguments _x~i~_ and therefore _dest~n~_ is implied. If the end of the memory array is reached during writing, the next destination will be index 0 and writing continues until all _x~i~_ have been written.

|`writeif( _cond_, _dest~1~_, _x~1~_, ..., _x~n~_ )` [[_writeif]]
|[_dest~1~_ : _dest~n~_] := _x~1~_, ..., _x~n~_ if _cond_ == true
|_cond_
|If _cond_ is nonzero the remaining arguments are passed to `write()`. Always returns _cond_.

|`rwrite( _pdest_, _x~1~_, _x~2~_, ..., _x~n~_ )` [[_rwrite]]
|[[_pdest_]&#43;&#43;] := _x~1~_
 +
 [[_pdest_]&#43;&#43;] := _x~2~_
 +
 ...
 +
 [[_pdest_]&#43;&#43;] := _x~n~_
|_n_
|Assign _n_ numeric values _x~1~_ through _x~n~_ to a range of consecutive destinations starting at the index referenced by _pdest_, incrementing the index in _pdest_ after each iteration. If the end of the memory array is reached during writing, modulo indexing ensures the next destination will be index 0 and writing continues until all _x~i~_ have been written. The value in _pdest_ will have been incremented by _n_ after the operation completes.

|`rwriteif( _cond_, _pdest_, _x~1~_, ..., _x~n~_ )` [[_rwriteif]]
|If _cond_ is true then:
 +
 [[_pdest_]&#43;&#43;] := _x~1~_
 +
 [[_pdest_]&#43;&#43;] := _x~2~_
 +
 ...
 +
 [[_pdest_]&#43;&#43;] := _x~n~_
|_cond_
|If _cond_ is nonzero the remaining arguments are passed to `rwrite()`. Always returns _cond_.

4+|*Load*

|`load( _src_ )` [[_load]]
|[_src_]
|[_src_]
|Return value at memory location _src_

|`rload( _psrc_ )` [[_rload]]
|&#91;&#91; _psrc_ &#93;&#93;
|&#91;&#91; _psrc_ &#93;&#93;
|Return value at memory location pointed to by _psrc_

|===

[[evaluatormemorystackops]]
==== Stack

.Stack
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

// cspell:ignore stackptr
|`push( _x_ )` [[_push]]
| [_stackptr_] := _x_, _stackptr_ &#8722;= 1
|_x_
|Push numeric value _x_ onto stack and return _x_

|`pushif( _cond_, _x_ )` [[_pushif]]
|if _cond_ == true then
 +
[_stackptr_] := _x_, _stackptr_ &#8722;= 1
|_cond_
|If _cond_ is nonzero push numeric value _x_ onto stack. Always returns _cond_.

|`pop()` [[_pop]]
| _stackptr_ += 1, _x_ := [_stackptr_]
|_x_
|Pop value from stack and return it

|`get()` [[_get]]
|_x_ := [_stackptr_]
|_x_
|Return value at top of stack without popping

|===

[[evaluatormemorymovingdata]]
==== Moving Data

.Moving Data
[cols="15,14,6,12"]
|===
|Function |Operation |Ret | Description

4+|*Copy*

|`mov( _dest_, _src_ )` [[_mov]]
|[_dest_] := [_src_]
|[_dest_]
|Copy the value at memory location _src_ into memory location _dest_ and return the copied value

|`rmov( _pdest_, _psrc_ )` [[_rmov]]
|&#91;&#91; _pdest_ &#93;&#93; := &#91;&#91; _psrc_ &#93;&#93;
|&#91;&#91; _pdest_ &#93;&#93;
|Copy the value at memory location pointed to by address in _psrc_ into memory location pointed to by address in _pdest_ and return the copied value

|`movif( _cond_, _dest_, _src_ )` [[_movif]]
|[_dest_] := [_src_] 
 +
 if _cond_ == true
|_cond_
|If _cond_ is nonzero copy the value at memory location _src_ into memory location _dest_. Always returns _cond_.

|`rmovif( _cond_, _pdest_, _psrc_ )` [[_rmovif]]
|&#91;&#91; _pdest_ &#93;&#93; :=&#91;&#91; _psrc_ &#93;&#93;
 +
 if _cond_ == true
|_cond_
|If _cond_ is nonzero copy the value at memory location pointed to by address in _psrc_ into memory location pointed to by address in _pdest_. Always returns _cond_.

4+|*Exchange*

|`xchg( _m~1~_, _m~2~_ )` [[_xchg]]
|[_m~1~_] :=: [_m~2~_]
|[_m~1~_]
|Exchange the values at memory locations _m~1~_ and _m~2~_ and return the value at location _m~1~_ after the exchange (i.e. the value originally in _m~2~_)

|`rxchg( _pm~1~_, _pm~2~_ )` [[_rxchg]]
|&#91;&#91; _pm~1~_ &#93;&#93; :=: &#91;&#91; _pm~2~_ &#93;&#93;
|&#91;&#91; _pm~1~_ &#93;&#93;
|Exchange the values at memory locations pointed to by addresses in _pm~1~_ and _pm~2~_ and return the value at location pointed to by address in _pm~1~_ after the exchange (i.e. the value originally pointed to by address in _pm~2~_)

|`xchgif( _cond_, _m~1~_, _m~2~_ )` [[_xchgif]]
|[_m~1~_] :=: [_m~2~_]
 +
 if _cond_ == true
|_cond_
|If _cond_ is nonzero exchange the values at memory locations _m~1~_ and _m~2~_. Always returns _cond_.

|`rxchgif( _cond_, _pm~1~_, _pm~2~_ )` [[_rxchgif]]
|&#91;&#91; _pm~1~_ &#93;&#93; :=:&#91;&#91; _pm~2~_ &#93;&#93;
 +
 if _cond_ == true
|_cond_
|If _cond_ is nonzero exchange the values at memory locations pointed to by addresses in _pm~1~_ and _pm~2~_. Always returns _cond_.

|===

[[evaluatormemoryincdec]]
==== Increment and Decrement

.Increment and Decrement
[cols="15,15,6,12"]
|===
|Function |Operation |Ret | Description

4+|*Increment*

|`inc( _dest_ )` [[_inc]]
|[_dest_] += 1
|[_dest_]
|Increment value at memory location _dest_ and return the new value

|`rinc( _pdest_ )` [[_rinc]]
|&#91;&#91; _pdest_ &#93;&#93; += 1
|&#91;&#91; _pdest_ &#93;&#93;
|Increment value at memory location pointed to by address in _pdest_ and return the new value

|`incif( _cond_, _dest_ )` [[_incif]]
|[_dest_] += 1 if _cond_ == true
|_cond_
|If _cond_ is nonzero increment value at memory location _dest_. Always returns _cond_.

|`rincif( _cond_, _pdest_ )` [[_rincif]]
|&#91;&#91; _pdest_ &#93;&#93; += 1 if _cond_ == true
|_cond_
|If _cond_ is nonzero increment value at memory location pointed to by address in _pdest_. Always returns _cond_.

4+|*Decrement*

|`dec( _dest_ )` [[_dec]]
|[_dest_] &#8722;= 1
|[_dest_]
|Decrement value at memory location _dest_ and return the new value

|`rdec( _pdest_ )` [[_rdec]]
|&#91;&#91; _pdest_ &#93;&#93; &#8722;= 1
|&#91;&#91; _pdest_ &#93;&#93;
|Decrement value at memory location pointed to by address in _pdest_ and return the new value

|`decif( _cond_, _dest_ )` [[_decif]]
|[_dest_] &#8722;= 1 if _cond_ == true
|_cond_
|if _cond_ is nonzero decrement value at memory location _dest_. Always returns _cond_.

|`rdecif( _cond_, _pdest_ )` [[_rdecif]]
|&#91;&#91; _pdest_ &#93;&#93; &#8722;= 1 if _cond_ == true
|_cond_
|if _cond_ is nonzero decrement value at memory location pointed to by address in _pdest_. Always returns _cond_.

|===

[[evaluatormemorycomparator]]
==== Comparator

.Comparator
[cols="10,10,3,20"]
|===
|Function |Operation |Ret | Description

4+|*Equality*

|`equ( _a_, _b_ )` [[_equ]]
|_c_ := [_a_] == [_b_]
|_c_
|Return _true_ if items in memory locations _a_ and _b_ compare equal, else return _false_

|`requ( _pa_, _pb_ )` [[_requ]]
|_c_ := &#91;&#91; _pa_ &#93;&#93; == &#91;&#91; _pb_ &#93;&#93;
|_c_
|Return _true_ if items pointed to by addresses in memory locations _pa_ and _pb_ compare equal, else return _false_

|`neq( _a_, _b_ )` [[_neq]]
|_c_ := [_a_] != [_b_]
|_c_
|Return _true_ if items in memory locations _a_ and _b_ compare not equal, else return _false_

|`rneq( _pa_, _pb_ )` [[_rneq]]
|_c_ := &#91;&#91; _pa_ &#93;&#93; != &#91;&#91; _pb_ &#93;&#93;
|_c_
|Return _true_ if items pointed to by addresses in memory locations _pa_ and _pb_ compare not equal, else return _false_

4+|*Greater*

|`gt( _a_, _b_ )` [[_gt]]
|_c_ := [_a_] > [_b_]
|_c_
|Return _true_ if item in memory location _a_ compares greater than item in memory location _b_, else return _false_

|`rgt( _pa_, _pb_ )` [[_rgt]]
|_c_ := &#91;&#91; _pa_ &#93;&#93; > &#91;&#91; _pb_ &#93;&#93;
|_c_
|Return _true_ if item pointed to by address in memory location _pa_ compares greater than item pointed to by address in memory location _pb_, else return _false_

|`gte( _a_, _b_ )` [[_gte]]
|_c_ := [_a_] >= [_b_]
|_c_
|Return _true_ if item in memory location _a_ compares greater than or equal to item in memory location _b_, else return _false_

|`rgte( _pa_, _pb_ )` [[_rgte]]
|_c_ := &#91;&#91; _pa_ &#93;&#93; >= &#91;&#91; _pb_ &#93;&#93;
|_c_
|Return _true_ if item pointed to by address in memory location _pa_ compares greater than or equal to item pointed to by address in memory location _pb_, else return _false_

4+|*Less*

|`lt( _a_, _b_ )` [[_lt]]
|_c_ := [_a_] < [_b_]
|_c_
|Return _true_ if item in memory location _a_ compares less than item in memory location _b_, else return _false_

|`rlt( _pa_, _pb_ )` [[_rlt]]
|_c_ := &#91;&#91; _pa_ &#93;&#93; < &#91;&#91; _pb_ &#93;&#93;
|_c_
|Return _true_ if item pointed to by address in memory location _pa_ compares less than item pointed to by address in memory location _pb_, else return _false_

|`lte( _a_, _b_ )` [[_lte]]
|_c_ := [_a_] \<= [_b_]
|_c_
|Return _true_ if item in memory location _a_ compares less than or equal to item in memory location _b_, else return _false_

|`rlte( _pa_, _pb_ )` [[_rlte]]
|_c_ := &#91;&#91; _pa_ &#93;&#93; \<= &#91;&#91; _pb_ &#93;&#93;
|_c_
|Return _true_ if item pointed to by address in memory location _pa_ compares less than or equal to item pointed to by address in memory location _pb_, else return _false_

|===

[[evaluatormemoryarithmetic]]
==== Arithmetic

.Arithmetic
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

4+|*Addition*

|`add( _addr_, _x_ )` [[_add]]
|[_addr_] += _x_
|[_addr_]
|Add _x_ to value at memory location _addr_ and return the sum

|`addif( _cond_, _addr_, _x_ )` [[_addif]]
|[_addr_] += _x_ if _cond_ == true
|_cond_
|If _cond_ is nonzero add _x_ to value at memory location _addr_. Always returns _cond_.

4+|*Subtraction*

|`sub( _addr_, _x_ )` [[_sub]]
|[_addr_] &#8722;= _x_
|[_addr_]
|Subtract _x_ from value at memory location _addr_ and return the difference

|`subif( _cond_, _addr_, _x_ )` [[_subif]]
|[_addr_] &#8722;= _x_ if _cond_ == true
|_cond_
|If _cond_ is nonzero subtract _x_ from value at memory location _addr_. Always returns _cond_.

4+|*Multiplication*

|`mul( _addr_, _x_ )` [[_mul]]
|[_addr_] *= _x_
|[_addr_]
|Multiply value at memory location _addr_ by _x_ and return the product

|`mulif( _cond_, _addr_, _x_ )` [[_mulif]]
|[_addr_] *= _x_ if _cond_ == true
|_cond_
|If _cond_ is nonzero multiply value at memory location _addr_ by _x_. Always returns _cond_.

4+|*Division*

|`div( _addr_, _x_ )` [[_div]]
|[_addr_] /= _x_
|[_addr_]
|Divide value at memory location _addr_ by _x_ and return the quotient

|`divif( _cond_, _addr_, _x_ )` [[_divif]]
|[_addr_] /= _x_ if _cond_ == true
|_cond_
|If _cond_ is nonzero divide value at memory location _addr_ by _x_. Always returns _cond_.

4+|*Modulo*

|`mod( _addr_, _x_ )` [[_mod]]
|[_addr_] %= _x_
|[_addr_]
|Perform modulo by _x_ operation on value at memory location _addr_ and return the remainder

|`modif( _cond_, _addr_, _x_ )` [[_modif]]
|[_addr_] %= _x_ if _cond_ == true
|_cond_
|If _cond_ is nonzero perform modulo by _x_ operation on value at memory location _addr_. Always returns _cond_.

|===

[[evaluatormemorybitwise]]
==== Bitwise

.Bitwise Operations
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

4+|*Shift*

|`shr( _addr_, _b_ )` [[_shr]]
|[_addr_] >>= _b_
|[_addr_]
|Shift value (interpreted as integer) at memory location _addr_ right by _b_ bits and return the new value.

|`shrif( _cond_, _addr_, _b_ )` [[_shrif]]
|[_addr_] >>= _b_ if _cond_ == true
|_cond_
|If _cond_ is nonzero shift value (interpreted as integer) at memory location _addr_ right by _b_ bits. Always returns _cond_.

|`shl( _addr_, _b_ )` [[_shl]]
|[_addr_] <\<= _b_
|[_addr_]
|Shift value (interpreted as integer) at memory location _addr_ left by _b_ bits and return the new value.

|`shlif( _cond_, _addr_, _b_ )` [[_shlif]]
|[_addr_] <\<= _b_ if _cond_ == true
|_cond_
|If _cond_ is nonzero shift value (interpreted as integer) at memory location _addr_ left by _b_ bits. Always returns _cond_.

4+|*Bitwise AND*

|`and( _addr_, _x_ )` [[_and]]
|[_addr_] &= _x_
|[_addr_]
|Perform bitwise-AND operation on value (interpreted as integer) at memory location _addr_ using bit mask _x_ and return the new value.

|`andif( _cond_, _addr_, _x_ )` [[_andif]]
|[_addr_] &= _x_ if _cond_ == true
|_cond_
|If _cond_ is nonzero perform bitwise-AND operation on value (interpreted as integer) at memory location _addr_ using bit mask _x_. Always returns _cond_.

4+|*Bitwise OR*

|`or( _addr_, _x_ )` [[_or]]
|[_addr_] \|= _x_
|[_addr_]
|Perform bitwise-OR operation on value (interpreted as integer) at memory location _addr_ using bit mask _x_ and return the new value.

|`orif( _cond_, _addr_, _x_ )` [[_orif]]
|[_addr_] \|= _x_ if _cond_ == true
|_cond_
|If _cond_ is nonzero perform bitwise-OR operation on value (interpreted as integer) at memory location _addr_ using bit mask _x_. Always returns _cond_.

4+|*Bitwise XOR*

|`xor( _addr_, _x_ )` [[_xor]]
|[_addr_] ^= _x_
|[_addr_]
|Perform bitwise-XOR operation on value (interpreted as integer) at memory location _addr_ using bit mask _x_ and return the new value.

|`xorif( _cond_, _addr_, _x_ )` [[_xorif]]
|[_addr_] ^= _x_ if _cond_ == true
|_cond_
|If _cond_ is nonzero perform bitwise-XOR operation on value (interpreted as integer) at memory location _addr_ using bit mask _x_. Always returns _cond_.

|===

// cspell:ignore mathbf
[[evaluatormemoryvector]]
==== Vector Arithmetic

.Vector Arithmetic
[cols="12,16,5,16"]
|===
|Function |Operation |Ret | Description

|`dp_pi8( *A*, *B* )`
 +
 `dp_pi8_256( *A*, *B* )`
 +
 `dp_pi8_512( *A*, *B* )` [[_dp_pi8]]
|latexmath:[ y := \mathbf{A} \cdot \mathbf{B} ]
 +
 +
 where
 +
 latexmath:[ \mathbf{A} = (a_1,a_2,...,a_n) ]
 +
 latexmath:[ \mathbf{B} = (b_1,b_2,...,b_n) ]
 +
 +
 i.e.
 +
 latexmath:[ y := a_1b_1 + a_2b_2 + ... + a_nb_n]
 +
 +
 latexmath:[ a_i \in [-128,127\] ]
 +
 latexmath:[ b_i \in [-128,127\] ]
 +
 +
 Vector length _n_ such that
 +
 latexmath:[ n \mod w = 0 ]
 +
 +
 where
 +
 latexmath:[ w = \begin{cases} 32 & \quad \text{for 256 version} \\ 64 & \quad \text{for 512 version} \end{cases}]
|float( _y_ )
|Compute the dot-product of vectors *A* and *B* represented by _bytearrays_. Vector lengths must be equal, and a multiple of _w_ bytes where _w_ depends on the function version. Vector elements are interpreted as signed bytes.
 +
 +
 The returned value is floating point.
 +
 +
 *NOTE1*: Availability of these functions depends on the pyvgx library build version and the instruction set extensions present on the CPU. The `512` version requires the AVX-512 enabled build and a CPU with AVX-512 support. The `256` version requires the AVX2 enabled build and a CPU with AVX2 support. `dp_pi8()` is an alias for the highest width version available on the system.
 +
 +
 *NOTE2*: _bytearray_ objects store unsigned byte values in range [0,255]. However, `dp_pi8()` uses signed arithmetic where values are two's complement encoded. Raw array values in range [128,255] are therefore interpreted as negative.
 +
 +
 *NOTE3*: *A* and/or *B* may be supplied as <<../similarity/vector.adoc#, _vector objects_>> (e.g. <<_nextvector, `next.vector`>>). A vector object is implicitly cast to _bytearray_ for the computation. The vector's scaling factor is applied 

|`cos_pi8( *A*, *B* )`
 +
 `cos_pi8_256( *A*, *B* )`
 +
 `cos_pi8_512( *A*, *B* )` [[_cos_pi8]]
// |_cos &#920;_ := *_a_ &#183; _b_* / ( \|*_a_*\| \|*_b_*\| )
|latexmath:[ y := \cos{ \theta } = \displaystyle \frac{ \mathbf{A} \cdot \mathbf{B}}{ \\|\mathbf{A}\\| \cdot \\|\mathbf{B}\\|} ]
 +
 +
 where
 +
 latexmath:[ \mathbf{A} = (a_1,a_2,...,a_n) ]
 +
 latexmath:[ \mathbf{B} = (b_1,b_2,...,b_n) ]
 +
 +
 i.e.
 +
 latexmath:[ y := \displaystyle \frac{\displaystyle \sum_{i=1}^n {a_ib_i}}{ \sqrt{\displaystyle \sum_{i=1}^n {a_i^2}} \cdot \sqrt{\displaystyle \sum_{i=1}^n {b_i^2} }} ]
 +
 +
 latexmath:[ a_i \in [-128,127\] ]
 +
 latexmath:[ b_i \in [-128,127\] ]
 +
 +
 Vector length _n_ such that
 +
 latexmath:[ n \mod w = 0 ]
 +
 +
 where
 +
 latexmath:[ w = \begin{cases} 32 & \quad \text{for 256 version} \\ 64 & \quad \text{for 512 version} \end{cases}]
|_y_
|Compute cosine of angle latexmath:[ \theta ] between vectors *A* and *B* (represented by _bytearrays_) whose lengths must be equal, and a multiple of _w_ bytes where _w_ depends on the function version. Vector elements are interpreted as signed bytes.
 +
 +
 Return float value latexmath:[ y \in [-1, 1\]]
 +
 +
 *NOTE1*: <<_dp_pi8, See `dp_pi8()` NOTE1>> for availability of `512`, `256` versions.
 +
 +
 *NOTE2*: <<_dp_pi8, See `dp_pi8()` NOTE2>> regarding encoding of signed values.

// cspell:ignore overrightarrow
|`ecld_pi8( *A*, *B* )`
 +
 `ecld_pi8_256( *A*, *B* )`
 +
 `ecld_pi8_512( *A*, *B* )` [[_ecld_pi8]]
|latexmath:[ y := d( \mathbf{A}, \mathbf{B} ) = \displaystyle \\|\overrightarrow{ \mathbf{AB} }\\| ]
 +
 +
 where
 +
 latexmath:[ \mathbf{A} = (a_1,a_2,...,a_n) ]
 +
 latexmath:[ \mathbf{B} = (b_1,b_2,...,b_n) ]
 +
 +
 i.e.
 +
 latexmath:[ y := \displaystyle \sqrt{ \sum_{i=1}^n {(a_i - b_i)^2}} ]
 +
 +
 latexmath:[ a_i \in [-128,127\] ]
 +
 latexmath:[ b_i \in [-128,127\] ]
 +
 +
 Vector length _n_ such that
 +
 latexmath:[ n \mod w = 0 ]
 +
 +
 where
 +
 latexmath:[ w = \begin{cases} 32 & \quad \text{for 256 version} \\ 64 & \quad \text{for 512 version} \end{cases}]
|_y_
|Compute the Euclidean (L2) norm of the difference between vectors *A* and *B* represented by _bytearrays_. The number of vector dimensions must be a multiple of _w_ bytes where _w_ depends on the function version. Vector elements are interpreted as signed bytes.
 +
 +
 Return float value latexmath:[ y \geq 0 ]
 +
 +
 *NOTE1*: <<_dp_pi8, See `dp_pi8()` NOTE1>> for availability of `512`, `256` versions.
 +
 +
 *NOTE2*: <<_dp_pi8, See `dp_pi8()` NOTE2>> regarding encoding of signed values.

// cspell:ignore hamdist
|`ham_pi8( *A*, *B* )` [[_ham_pi8]]
|latexmath:[ y := hamdist( \mathbf{A}, \mathbf{B} ) ]
 +
 +
 where
 +
 latexmath:[ \mathbf{A} = (a_1,a_2,...,a_n) ]
 +
 latexmath:[ \mathbf{B} = (b_1,b_2,...,b_n) ]
|_y_
|Compute the Hamming Distance between the 64-bit fingerprints (LSH) of vectors *A* and *B* (represented by _bytearrays_ or vector objects.) Vector elements are interpreted as signed bytes.
 +
 +
 Return integer value latexmath:[ y \in \lbrack 0, 64 \rbrack ]
 +
 +
 *NOTE2*: <<_dp_pi8, See `dp_pi8()` NOTE2>> regarding encoding of signed values.

|===

[CAUTION]
====
The `512` versions of the above functions are generally 50% faster than `256` versions for large vectors.

However, there is a cost to using the `512` versions in that the CPU has to switch back and forth between using the wider 512-bit registers and the narrower registers used by other parts of the program code. Furthermore the CPU may automatically throttle down its frequency while executing AVX-512 instructions to remain within thermal bounds, and this could have an impact on both the performance of the vector computation and other concurrently running parts of the system.

Benchmarking is the only way to select the most performant vector function in a given application.
====

[[evaluatormemoryvarious]]
==== Various Functions

.Various Functions
[cols="22,11,3,10"]
|===
|Function |Operation |Ret | Description

|`smooth( _addr_, _x_, _&#945;_ )` [[_smooth]]
|[_addr_] += _&#945;_ &#183; ( _x_ &#8722; [addr] )
|[_addr_]
|Update value at memory location _addr_ from new value _x_ using exponential smoothing factor _&#945;_ and return the updated value.

|`count( _addr_ [, _<expr~1~>_, ..., _<expr~n~>_] )` [[_count]]
|[_addr_] += 1
|[_addr_]
|Evaluate any number of sub-expressions _<expr~k~>_ (discarding their return values), increment value at memory location _addr_ and return the new value. This provides a way to count the number of times an expression is evaluated and to execute expressions that don't contribute directly to the overall expression result value, but may be needed for their side-effects such as operating on memory locations that will be used later.

|`countif( _cond_, _addr_[, _<expr~1~>_, ..., _<expr~n~>_] )` [[_count]]
|[_addr_] += 1 if _cond_ == true
|[_cond_]
|Same behavior as `count()` except value at location _addr_ is incremented only when _cond_ is true, and _cond_ is always returned.

|===

[[evaluatormemoryindexingop]]
==== Indexing

.Indexing
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

|`modindex( _i_, _mod_, _ofs_ )` [[_modindex]]
|_x_ = _i_ % _mod_ + _ofs_
|_x_
|Compute the array index _x_ for a sub-array index _i_ defined by _mod_ and _ofs_.

// cspell:ignore bitindex
|`index( _vertex_ )` [[_index]]
|[_vertex_.bitindex] \|= _vertex_.bitvector
|1 or 0
|Add _vertex_ to memory array bitvector index by setting the appropriate bit of the value in a memory location determined by the vertex address

|`indexed( _vertex_ )` [[_indexed]]
|[_vertex_.bitindex] & _vertex_.bitvector
|1 or 0
|Test if _vertex_ has been indexed in the memory array

|`unindex( _vertex_ )` [[_unindex]]
|[_vertex_.bitindex] &= ~_vertex_.bitvector
|0
|Remove _vertex_ from memory array bitvector index by clearing the appropriate bit of the value in a memory location determined by the vertex address

|===

[[evaluatormemory_multiple]]
=== Operations on Multiple Memory Locations

These operations affect ranges of memory locations. 

==== Function Naming Conventions

Prefix `m*`::
All functions of this type start with the letter `m`.

Prefix `mi*`::
Some functions are optimized for use with integer arrays and have the `mi` prefix. These functions have undefined behavior on non-integer data.

Prefix `mr*`::
Some functions are optimized for use with floating point arrays and have the `mr` prefix. These functions have undefined behavior on non-floating point data.

Prefix `mv*`::
Some functions operate element-wise on two equally sized vectors and have the `mv` prefix.

==== Array Indexing and Range Specification

Array index subscript convention::
Array indices are specified using 1-based offsets. The array _A_ with _k_ elements has its first element at _A~1~_ and its last element at _A~k~_.

Start and end indices::
Functions that specify a memory range using start and end indices are inclusive of the end index. In general, a function `m<func>( m~1~, m~n~[, ... ] )` applies to memory locations _m~1~_, _m~2~_, ..., _m~n~_.

Array location and length::
Functions that specify a memory range using an array location _A_ and its length _k_ generally have the form `m<func>( A, k[, ... ] )` and apply to memory locations _A~1~_, _A~2~_, ..., _A~k~_.

==== Applying Operations to Memory Range

The simplified notation latexmath:[ M_n ] is sometimes used to represent the set of _n_ values in consecutive memory range _m~1~_ through _m~n~_.

latexmath:[ M_n ::=\ [ m_1 : m_n \] ],

where dereference notation latexmath:[ [m\] ] is used to represent the value in memory location _m_.

Using this definition of latexmath:[ M_n ] we can then describe functions more compactly. 

.Simplified memory range notation examples
[cols="3,5,4"]
|===
|Function Example |Operation |Description

|`m<f>( m~1~, m~n~ )`
|latexmath:[ M_n := f( M_n ) ]
 +
 +
 is the equivalent of
 +
 +
 latexmath:[ [ m_1 : m_n \] := f( [ m_1 : m_n \] ) ]
 +
 +
 is the equivalent of
 +
 +
 latexmath:[ [m_i\] := f([m_i\]) \text{ for all } i \in \{1,2,...,n\} ]
|Let latexmath:[ y = f(x) ] and let latexmath:[ [ m \] ] represent the value in memory location _m_. This evaluator function then computes latexmath:[ y_i = f(x_i) \text{ for all } x_i = [m_i\]],
 +
 latexmath:[ i \in \{m_1, m_2, ..., m_n\} ]
 +
 and then performs latexmath:[ [m_i\] = y_i ]. 
 +
 +
 Stated more simply, transform all values in the specified memory range using latexmath:[f(x)].

|`m<g>( m~1~, m~n~, p )`
|latexmath:[ M_n := M_n \text{ <g> } p ]
 +
 +
 is the equivalent of
 +
 +
 latexmath:[ M_n := g( M_n, p ) ]
 +
 +
 is the equivalent of 
 +
 +
 latexmath:[ [m_i\] := g([m_i\],p) \text{ for all } i \in \{1,2,...,n\} ]
 +
 where latexmath:[ g(x,p) = x \text{ <g> } p ]
|Let latexmath:[ y = g(x,p) ] and let latexmath:[ [ m \] ] represent the value in memory location _m_. This evaluator function then computes latexmath:[ y_i = g(x_i,p) \text{ for all } x_i = [m_i\]],
 +
 latexmath:[ i \in \{m_1, m_2, ..., m_n\} ]
 +
 and then performs latexmath:[ [m_i\] = y_i ]. 
 +
 +
 Stated more simply, transform all values in the specified memory range using latexmath:[g(x,p)].

|===

==== Section Links

[cols="4,6"]
|===
|Category |Functions

|<<evaluatormemory_arraysetcopy>>
|`mset()`, `mreset()`, `mrandomize()`, `mcopy()`, etc.

|<<evaluatormemory_arrayheap>>
|`mheapinit()`, `mheapifymin()`, `mheappushmin()`, etc.

|<<evaluatormemory_arraysort>>
|`msort()`, `mreverse()`, etc.

|<<evaluatormemory_arraycast>>
|`mint()`, `mreal()`, etc.

|<<evaluatormemory_arrayincdec>>
|`minc()`, `mdec()`, etc.

|<<evaluatormemory_scalararrayarithmetic>>
|`madd()`, `mvadd()`, `mvmul()`, `mpow()`, `msqrt()`, etc.

|<<evaluatormemory_arraynumeric>>
|`mceil()`, `mround()`, `mabs()`, etc.

|<<evaluatormemory_arraylogexp>>
|`mlog()`, `mlog2()`, `mexp()`, `mexp10()`, etc.

|<<evaluatormemory_arraytrighyp>>
|`msin()`, `macos()`, `mtanh()`, `msinc()`, etc.

|<<evaluatormemory_arraybitwise>>
|`mshr()`, `mvshr()`, `mand()`, `mvxor()`, etc.

|<<evaluatormemory_arrayhash>>
|`mhash()`

|<<evaluatormemory_arrayaggregate>>
|`msum()`, `msumsqr()`, `mprod()`, `mmean()`, `mstdev()`, etc.

|<<evaluatormemory_arrayprobe>>
|`mmax()`, `mcontains()`, `msubset()`, etc.

|===

[[evaluatormemory_arraysetcopy]]
==== Set and Copy

.Set and Copy Operations
[cols="14,17,3,12"]
|===
|Function |Operation |Ret | Description

|`mset( _m~1~_, _m~n~_, _x_ )` [[_mset]]
// |[ _m~1~_ : _m~n~_ ] := _x_
|latexmath:[ M_n := x ]
|_n_
|Assign numeric value _x_ to all memory locations _m~1~_ to _m~n~_ and return the number of memory locations set.

|`mreset()` [[_mreset]]
|latexmath:[ [ 0 : -1 \] := 0 ]
|_n_
|Set all memory locations to integer 0 and free all temporary string memory consumed by any previous calls to string functions such as <<_str,`str()`>>, <<_join,`join()`>>, etc. Return the total number of memory locations.

|`mrandomize( _m~1~_, _m~n~_ )` [[_mrandomize]]
// |[ _m~1~_ : _m~n~_ ] := _random_()
|latexmath:[ M_n := \text{random}() ]
|_n_
|Assign a different random value in the range [0.0 - 1.0] to each memory location _m~1~_ to _m~n~_ and return the number of memory locations affected.

|`mrandbits( _m~1~_, _m~n~_ )` [[_mrandbits]]
|latexmath:[ M_n := \text{randbits}() ]
|_n_
|Assign a different random bit pattern to each memory location _m~1~_ to _m~n~_ and return the number of memory locations affected.

|`mcopy( _D_, _S_, _k_ )` [[_mcopy]]
// |[ _D~1~_ : _D~k~_ ] := [ _S~1~_ : _S~k~_ ]
|latexmath:[ [D_1 : D_k\] := [S_1 : S_k\] ]
|_k_
|Copy the contents of _k_ consecutive source locations starting at _S~1~_ to the range of consecutive destinations starting at _D~1~_. If any _D~i~_ or _S~i~_ references a slot beyond the end of the memory array nothing is copied. The number of copied memory locations is returned.

|`mpwrite( _pD_, _S_, _k_ )` [[_mpwrite]]
// |[ [_pdest_] : [_pdest_] + (_k_-1) ] := [ _src~1~_ : _src~k~_ ]
// +
// [_pdest_] := [_pdest_] + _k_
|latexmath:[ [ [pD\] : [pD\] + (k-1) \] := [ S_1 : S_k\] ]
 +
 +
 then
 +
 +
 latexmath:[ [pD\] := [pD\] + k ]
|_k_
|Copy the contents of _k_ consecutive source locations starting at _S~1~_ to the range of consecutive destinations starting at _the memory location referenced by value in location_ _pD_, then increment the value stored in location _pD_ by _k_. If any _S~i~_ or the value at _pD_ plus _i_ - 1 references a slot beyond the end of the memory array nothing is copied. The number of copied memory locations is returned.

|`mcopyobj( _D_, _obj_ )` [[_mcopyobj]]
// |[ _dest~1~_ : _dest~k~_ ] := [ _obj~1~_ : _obj~k~_ ]
|latexmath:[ [D_1 : D_n\] := [obj_1 : obj_n\] ]
 +
 +
 where
 +
 +
 latexmath:[ n = \\| obj \\| ]
|_n_
|Copy the _n_ raw quadwords of object _obj_ into memory starting at location _D~1~_. The number of quadwords _n_ comprising _obj_ is determined automatically. If any _D~i~_ references a slot beyond the end of the memory array nothing is copied.

|`mterm( _m_ )` [[_mterm]]
|latexmath:[ [m\] := \text{null} ]
|_m_
|Set element at memory location _m_ to _null_.

|`mlen( _A_ )` [[_mlen]]
|latexmath:[ \text{max}(k) \text{ such that} ]
 +
 latexmath:[ \text{null} \notin [ A_1 : A_k \]]
|_k_
|Return the number of elements between memory location _A~1~_ and the first occurrence of a _null_ value or the end of the memory object if no _null_ value is encountered.


|===

[[evaluatormemory_arrayheap]]
==== Heap Operations
  
These functions implement https://en.wikipedia.org/wiki/Binary_heap[binary heap operations^] useful for maintaining subsets of smallest or largest values from a greater set of candidates.

The _min_ and _max_ versions of these functions signify min-heap or max-heap semantics. Recall that a min-heap will discard smaller values as larger values are added, and that a max-heap will discard larger values as smaller values are added:

min-heap::
Keep larger values

max-heap::
Keep smaller values

.Heap Operations
[cols="18,12,6,12"]
|===
|Function |Operation |Ret | Description

4+|*Initialize*

|`mheapinit( _A_, _k_ )` [[_mheapinit]]
|latexmath:[ [A_1 : A_k\] := \text{null} ]
|_k_
|Prepare array of _k_ elements starting at location _A_ for use with heap operations. The array is initialized with null-values that are interpreted as _inf_ for _max-heaps_ and _-inf_ for _min-heaps_. The array satisfies both shape property and heap property for binary min and max heaps after this.

|`mheapifymin( _A_, _k_ )` [[_mheapifymin]]
|latexmath:[ \text{heapifymin}( [ A_1 : A_k \] ) ]
|_k_
|Process array of _k_ elements starting at location _A_ such that the array satisfies the heap property for a _min-heap_.

|`mheapifymax( _A_, _k_ )` [[_mheapifymax]]
|latexmath:[ \text{heapifymax}( [ A_1 : A_k \] ) ]
|_k_
|Process array of _k_ elements starting at location _A_ such that the array satisfies the heap property for a _max-heap_.

4+|*Populate*

|`mheappushmin( _A_, _k_, _x_ )` [[_mheappushmin]]
|latexmath:[\text{if } [A_1\] < x\ \text{, then}]
 +
 latexmath:[\quad [A_1\] := [A_k\]]
 +
 latexmath:[\quad [A_k\] := x]
 +
 latexmath:[\quad \text{downheapmin}( A, k-1 ) ]
 +
 latexmath:[\quad \text{upheapmin}( A, k-1 ) ]
 +
 latexmath:[\quad \text{return } 1]
 +
 +
 latexmath:[\quad \text{else}]
 +
 latexmath:[\quad \text{return } 0]
|1 or 0
|Attempt to insert numeric value _x_ into binary _min-heap_ represented by array of _k_ elements starting at location _A_ and return 1 if successful. Inserting a new value implies discarding the previous smallest value from the heap (if no null-values remain). If the new value is less than all values in the heap nothing is inserted and 0 is returned.

|`mheappushmax( _A_, _k_, _x_ )` [[_mheappushmax]]
|latexmath:[\text{if } [A_1\] > x\ \text{, then}]
 +
 latexmath:[\quad [A_1\] := [A_k\]]
 +
 latexmath:[\quad [A_k\] := x]
 +
 latexmath:[\quad \text{downheapmax}( A, k-1 ) ]
 +
 latexmath:[\quad \text{upheapmax}( A, k-1 ) ]
 +
 latexmath:[\quad \text{return } 1]
 +
 +
 latexmath:[\quad \text{else}]
 +
 latexmath:[\quad \text{return } 0]
|1 or 0
|Attempt to insert numeric value _x_ into binary _max-heap_ represented by array of _k_ elements starting at location _A_ and return 1 if successful. Inserting a new value implies discarding the previous largest value from the heap (if no null-values remain). If the new value is greater than all values in the heap nothing is inserted and 0 is returned.

|`mheapwritemin( _A_, _k_, _x~1~_, _x~2~_, ..., _x~n~_ )` [[_mheapwritemin]]
|latexmath:[\text{for all } x_i, i \in \{1,2,...,n\}]
 +
 latexmath:[r_i = \text{mheappushmin}(A,k,x_i)]
 +
 +
 latexmath:[N = \displaystyle \sum_{i=1}^n r_i]
|_N_
|Attempt to insert numeric values _x~1~_ through _x~n~_ into binary _min-heap_ represented by array of _k_ elements starting at location _A_ and return the number of values inserted. This is functionally equivalent to calling <<_mheappushmin, `mheappushmin( _A_, _k_, _x~i~_)`>> for all _i_ from 1 through _n_ and counting as _N_ the number of _x~i~_ successfully inserted. 

|`mheapwritemax( _A_, _k_, _x~1~_, _x~2~_, ..., _x~n~_ )` [[_mheapwritemax]]
|latexmath:[\text{for all } x_i, i \in \{1,2,...,n\}]
 +
 latexmath:[r_i = \text{mheappushmax}(A,k,x_i)]
 +
 +
 latexmath:[N = \displaystyle \sum_{i=1}^n r_i]
|_N_
|Attempt to insert numeric values _x~1~_ through _x~n~_ into binary _max-heap_ represented by array of _k_ elements starting at location _A_ and return the number of values inserted. This is functionally equivalent to calling <<_mheappushmax, `mheappushmax( _A_, _k_, _x~i~_)`>> for all _i_ from 1 through _n_ and counting as _N_ the number of _x~i~_ successfully inserted. 

// cspell:ignore mheappushmin
|`mheapsiftmin( _A_, _k_, _m~1~_, _m~n~_ )` [[_mheapsiftmin]]
|latexmath:[\text{for all } i \in \{1,2,...,n\}]
 +
 mheappushmin(_A_,_k_,[_m~i~_])
|_n_
|Process all numeric values in memory locations _m~1~_ through _m~n~_ by attempting to insert them into binary _min-heap_ represented by array of _k_ elements starting at location _A_ and return the number of processed values, whether inserted or not. On completion the array _A_ will contain the _k_ largest values from the source range.

// cspell:ignore mheappushmax
|`mheapsiftmax( _A_, _k_, _m~1~_, _m~n~_ )` [[_mheapsiftmax]]
|latexmath:[\text{for all } i \in \{1,2,...,n\}]
 +
 mheappushmax(_A_,_k_,[_m~i~_])
|_n_
|Process all numeric values in memory locations _m~1~_ through _m~n~_ by attempting to insert them into binary _max-heap_ represented by array of _k_ elements starting at location _A_ and return the number of processed values, whether inserted or not. On completion the array _A_ will contain the _k_ smallest values from the source range.

|===

[[evaluatormemory_arraysort]]
==== Sorting

.Array Sorting
[cols="15,14,6,12"]
|===
|Function |Operation |Ret | Description

|`msort( _A_, _k_ )` [[_msort]]
| _sort~ascending~_( [ _A~1~_ : _A~k~_ ] )
|_n_ &#8804; _k_
|Sort array of _k_ values starting at location _A_ in ascending order, in-place. Any null-value compares greater-than any numeric value, and will appear at the end of the sorted array. The number _n_ of non-null values is returned. (All other non-_real_ elements are interpreted as integers.)

|`msortrev( _A_, _k_ )` [[_msortrev]]
| _sort~descending~_( [ _A~1~_ : _A~k~_ ] )
|_n_ &#8804; _k_
|Sort array of _k_ values starting at location _A_ in descending order, in-place. Any null-value compares less-than any numeric value, and will appear at the end of the sorted array. The number _n_ of non-null values is returned. (All other non-_real_ elements are interpreted as integers.)

// cspell:ignore isreal
|`mrsort( _A_, _k_ )` [[_mrsort]]
| _sort~ascending~_( [ _A~1~_ : _A~k~_ ] )
  +
  ( assumes _isreal_( _A~i~_ ) == true )
|_k_
|Sort array of _k_ values (interpreted as floating point) starting at location _A_ in ascending order, in-place. 

|`mrsortrev( _A_, _k_ )` [[_mrsortrev]]
| _sort~descending~_( [ _A~1~_ : _A~k~_ ] )
  +
  ( assumes _isreal_( _A~i~_ ) == true )
|_k_
|Sort array of _k_ values (interpreted as floating point) starting at location _A_ in descending order, in-place. 

|`mreverse( _A_, _k_ )` [[_mreverse]]
| _reverse_( [_A~1~_ : _A~k~_] )
|_k_
|Reverse array of _k_ objects starting at location _A_, in-place.

|===

[[evaluatormemory_arraycast]]
==== Type Cast

.Array Type Cast
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

|`mint( _m~1~_, _m~n~_ )` [[_min]]
// |[ _m~1~_ : _m~n~_ ] := _int_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \text{integer}( M_n ) ]
|_n_
|Cast all values in memory locations _m~1~_ to _m~n~_ to integer and return the number of memory locations affected by the operation.

|`mintr( _m~1~_, _m~n~_ )` [[_min]]
// |[ _m~1~_ : _m~n~_ ] := _int_( _round_( [ _m~1~_ : _m~n~_ ] ) )
|latexmath:[ M_n := \text{integer}( \lfloor M_n \rceil ) ]
|_n_
|Cast all values in memory locations _m~1~_ to _m~n~_ to integer after rounding to the nearest whole number and return the number of memory locations affected by the operation.

|`mreal( _m~1~_, _m~n~_ )` [[_mreal]]
// |[ _m~1~_ : _m~n~_ ] := _real_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \text{real}( M_n ) ]
|_n_
|Cast all values in memory locations _m~1~_ to _m~n~_ to floating point and return the number of memory locations affected by the operation.

|`mbits( _m~1~_, _m~n~_ )` [[_mreal]]
// |[ _m~1~_ : _m~n~_ ] := _real_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \text{real}( M_n ) ]
|_n_
|Cast all values in memory locations _m~1~_ to _m~n~_ to floating point and return the number of memory locations affected by the operation.

|===

[[evaluatormemory_arrayincdec]]
==== Increment and Decrement

.Array Increment and Decrement
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

4+|*Increment*

|`minc( _m~1~_, _m~n~_ )` [[_minc]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] + 1
|latexmath:[ M_n := M_n + 1 ]
|_n_
|Increment all values in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`miinc( _m~1~_, _m~n~_ )` [[_miinc]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] + 1
|latexmath:[ M_n := M_n + 1 ]
|_n_
|Increment all values in memory locations _m~1~_ to _m~n~_ (interpreted as integers) and return the number of memory locations affected by the operation.

|`mrinc( _m~1~_, _m~n~_ )` [[_mrinc]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] + 1
|latexmath:[ M_n := M_n + 1 ]
|_n_
|Increment all values in memory locations _m~1~_ to _m~n~_ (interpreted as floating point) and return the number of memory locations affected by the operation.

4+|*Decrement*

|`mdec( _m~1~_, _m~n~_ )` [[_mdec]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] &#8722; 1
|latexmath:[ M_n := M_n - 1 ]
|_n_
|Decrement all values in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`midec( _m~1~_, _m~n~_ )` [[_midec]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] &#8722; 1
|latexmath:[ M_n := M_n - 1 ]
|_n_
|Decrement all values in memory locations _m~1~_ to _m~n~_ (interpreted as integers) and return the number of memory locations affected by the operation.

|`mrdec( _m~1~_, _m~n~_ )` [[_mrdec]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] &#8722; 1
|latexmath:[ M_n := M_n - 1 ]
|_n_
|Decrement all values in memory locations _m~1~_ to _m~n~_ (interpreted as floating point) and return the number of memory locations affected by the operation.

|===

[[evaluatormemory_scalararrayarithmetic]]
==== Arithmetic

.Array Arithmetic
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

4+|*Add*

|`madd( _m~1~_, _m~n~_, _x_ )` [[_madd]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] + _x_
|latexmath:[ M_n := M_n + x ]
|_n_
|Add _x_ to all values in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`miadd( _m~1~_, _m~n~_, _x_ )` [[_miadd]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] + _x_
|latexmath:[ M_n := M_n + x ]
|_n_
|Add integer _x_ to all values in memory locations _m~1~_ to _m~n~_ (interpreted as integers) and return the number of memory locations affected by the operation.

|`mradd( _m~1~_, _m~n~_, _x_ )` [[_mradd]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] + _x_
|latexmath:[ M_n := M_n + x ]
|_n_
|Add floating point value _x_ to all values in memory locations _m~1~_ to _m~n~_ (interpreted as floating point) and return the number of memory locations affected by the operation.

|`mvadd( _A_, _B_, _k_ )` [[_mvadd]]
|[ _A~1~_ : _A~k~_ ] := [ _A~1~_ + _B~1~_ : _A~k~_ + _B~k~_ ]
|_k_
|For all _i_ from 1 through _k_, add numeric values in memory locations _A~i~_ and _B~i~_ and store the result in location _A~i~_, then return _k_.

4+|*Subtract*

|`msub( _m~1~_, _m~n~_, _x_ )` [[_msub]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] &#8722; _x_
|latexmath:[ M_n := M_n - x ]
|_n_
|Subtract _x_ from all values in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`misub( _m~1~_, _m~n~_, _x_ )` [[_misub]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] &#8722; _x_
|latexmath:[ M_n := M_n - x ]
|_n_
|Subtract integer _x_ from all values in memory locations _m~1~_ (interpreted as integers) to _m~n~_ and return the number of memory locations affected by the operation.

|`mrsub( _m~1~_, _m~n~_, _x_ )` [[_mrsub]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] &#8722; _x_
|latexmath:[ M_n := M_n - x ]
|_n_
|Subtract floating point value _x_ from all values in memory locations _m~1~_ to _m~n~_ (interpreted as floating point) and return the number of memory locations affected by the operation.

|`mvsub( _A_, _B_, _k_ )` [[_mvsub]]
|[ _A~1~_ : _A~k~_ ] := [ _A~1~_ &#8722; _B~1~_ : _A~k~_ &#8722; _B~k~_ ]
|_k_
|For all _i_ from 1 through _k_, subtract numeric value in memory location _B~i~_ from numeric value in memory location _A~i~_ and store the result in location _A~i~_, then return _k_.

4+|*Multiply*

|`mmul( _m~1~_, _m~n~_, _x_ )` [[_mmul]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] * _x_
|latexmath:[ M_n := M_n \cdot x ]
|_n_
|Multiply all values in memory locations _m~1~_ to _m~n~_ by _x_ and return the number of memory locations affected by the operation.

|`mimul( _m~1~_, _m~n~_, _x_ )` [[_mimul]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] * _x_
|latexmath:[ M_n := M_n \cdot x ]
|_n_
|Multiply all values in memory locations _m~1~_ to _m~n~_ (interpreted as integers) by integer _x_ and return the number of memory locations affected by the operation.

|`mrmul( _m~1~_, _m~n~_, _x_ )` [[_mrmul]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] * _x_
|latexmath:[ M_n := M_n \cdot x ]
|_n_
|Multiply all values in memory locations _m~1~_ to _m~n~_ (interpreted as floating point) by floating point value _x_ and return the number of memory locations affected by the operation.

|`mvmul( _A_, _B_, _k_ )` [[_mvmul]]
|[ _A~1~_ : _A~k~_ ] := [ _A~1~_ * _B~1~_ : _A~k~_ * _B~k~_ ]
|_k_
|For all _i_ from 1 through _k_, multiply numeric values in memory locations _A~i~_ and _B~i~_ and store the result in location _A~i~_, then return _k_.

4+|*Divide*

|`mdiv( _m~1~_, _m~n~_, _x_ )` [[_mdiv]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] / _x_
|latexmath:[ M_n := \displaystyle \frac{M_n}{x} ]
|_n_
|Divide all values in memory locations _m~1~_ to _m~n~_ by _x_ and return the number of memory locations affected by the operation.

|`midiv( _m~1~_, _m~n~_, _x_ )` [[_midiv]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] / _x_
|latexmath:[ M_n := \displaystyle \frac{M_n}{x} ]
|_n_
|Divide all values in memory locations _m~1~_ to _m~n~_ (interpreted as integers) by integer _x_ and return the number of memory locations affected by the operation.

|`mrdiv( _m~1~_, _m~n~_, _x_ )` [[_mrdiv]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] / _x_
|latexmath:[ M_n := \displaystyle \frac{M_n}{x} ]
|_n_
|Divide all values in memory locations _m~1~_ to _m~n~_ (interpreted as floating point) by floating point value _x_ and return the number of memory locations affected by the operation.

|`mvdiv( _A_, _B_, _k_ )` [[_mvdiv]]
|[ _A~1~_ : _A~k~_ ] := [ _A~1~_ / _B~1~_ : _A~k~_ / _B~k~_ ]
|_k_
|For all _i_ from 1 through _k_, divide numeric value in memory location _A~i~_ by numeric value in memory location _B~i~_ and store the result in location _A~i~_, then return _k_.

4+|*Modulo*

|`mmod( _m~1~_, _m~n~_, _x_ )` [[_mmod]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] % _x_
|latexmath:[ M_n := M_n \mod x ]
|_n_
|Perform modulo by _x_ operation on all values in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`mimod( _m~1~_, _m~n~_, _x_ )` [[_mimod]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] % _x_
|latexmath:[ M_n := M_n \mod x ]
|_n_
|Perform integer modulo by _x_ on all values in memory locations _m~1~_ to _m~n~_ (interpreted as integers) and return the number of memory locations affected by the operation.

|`mrmod( _m~1~_, _m~n~_, _x_ )` [[_mrmod]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] % _x_
|latexmath:[ M_n := M_n \mod x ]
|_n_
|Perform floating point modulo by _x_ on all values in memory locations _m~1~_ to _m~n~_ (interpreted as floating point) and return the number of memory locations affected by the operation.

|`mvmod( _A_, _B_, _k_ )` [[_mvmod]]
|[ _A~1~_ : _A~k~_ ] := [ _A~1~_ % _B~1~_ : _A~k~_ % _B~k~_ ]
|_k_
|For all _i_ from 1 through _k_, perform [_A~i~_] modulo [_B~i~_] and store the result in location _A~i~_, then return _k_.

4+|*Inverse*

|`minv( _m~1~_, _m~n~_ )` [[_minv]]
// |[ _m~1~_ : _m~n~_ ] := 1 / [ _m~1~_ : _m~n~_ ]
|latexmath:[ M_n := \displaystyle \frac{1}{M_n} ]
|_n_
|Perform the inverse operation on all values in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`mrinv( _m~1~_, _m~n~_ )` [[_mrinv]]
// |[ _m~1~_ : _m~n~_ ] := 1.0 / [ _m~1~_ : _m~n~_ ]
|latexmath:[ M_n := \displaystyle \frac{1}{M_n} ]
|_n_
|Perform the inverse operation on all values in memory locations _m~1~_ to _m~n~_ interpreted as floating point values and return the number of memory locations affected by the operation.

4+|*Power*

|`mpow( _m~1~_, _m~n~_, _y_ )` [[_mpow]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] ^_y_^
|latexmath:[ M_n := (M_n)^y ]
|_n_
|Raise all values in memory locations _m~1~_ to _m~n~_ to the _y_^th^ power and return the number of memory locations affected by the operation.

|`mrpow( _m~1~_, _m~n~_, _y_ )` [[_mrpow]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] ^_y_^
|latexmath:[ M_n := (M_n)^y ]
|_n_
|Raise all values (interpreted as floating point values) in memory locations _m~1~_ to _m~n~_ to the _y_^th^ power and return the number of memory locations affected by the operation.

4+|*Square*

|`msq( _m~1~_, _m~n~_ )` [[_msq]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] ^2^
|latexmath:[ M_n := (M_n)^2 ]
|_n_
|Square all values in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`mrsq( _m~1~_, _m~n~_ )` [[_mrsq]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] ^2^
|latexmath:[ M_n := (M_n)^2 ]
|_n_
|Square all values (interpreted as floating point values) in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

4+|*Square Root*

|`msqrt( _m~1~_, _m~n~_ )` [[_msqrt]]
// |[ _m~1~_ : _m~n~_ ] := &#8730; [ _m~1~_ : _m~n~_ ]
|latexmath:[ M_n := \displaystyle \sqrt{M_n} ]
|_n_
|Take the square root of all values in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`mrsqrt( _m~1~_, _m~n~_ )` [[_mrsqrt]]
// |[ _m~1~_ : _m~n~_ ] := &#8730; [ _m~1~_ : _m~n~_ ]
|latexmath:[ M_n := \displaystyle \sqrt{M_n} ]
|_n_
|Take the square root of all values (interpreted as floating point values) in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|===

[[evaluatormemory_arraynumeric]]
==== Numeric

.Array Numeric Functions
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

4+|*Ceil*

|`mceil( _m~1~_, _m~n~_ )` [[_mceil]]
// |[ _m~1~_ : _m~n~_ ] := _ceil_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \lceil M_n \rceil ]
|_n_
|Set all values in memory locations _m~1~_ to _m~n~_ to their floating point values representing the smallest integers greater than or equal to their values. Return the number of memory locations affected by the operation.

|`mrceil( _m~1~_, _m~n~_ )` [[_mrceil]]
// |[ _m~1~_ : _m~n~_ ] := _ceil_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \lceil M_n \rceil ]
|_n_
|Set all values (interpreted as floating point values) in memory locations _m~1~_ to _m~n~_ to their floating point values representing the smallest integers greater than or equal to their values. Return the number of memory locations affected by the operation.

4+|*Floor*

|`mfloor( _m~1~_, _m~n~_ )` [[_mfloor]]
// |[ _m~1~_ : _m~n~_ ] := _floor_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \lfloor M_n \rfloor ]
|_n_
|Set all values in memory locations _m~1~_ to _m~n~_ to their floating point values representing the largest integers less than or equal to their values. Return the number of memory locations affected by the operation.

|`mrfloor( _m~1~_, _m~n~_ )` [[_mrfloor]]
// |[ _m~1~_ : _m~n~_ ] := _floor_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \lfloor M_n \rfloor ]
|_n_
|Set all values (interpreted as floating point values) in memory locations _m~1~_ to _m~n~_ to their floating point values representing the largest integers less than or equal to their values. Return the number of memory locations affected by the operation.

4+|*Round*

|`mround( _m~1~_, _m~n~_ )` [[_mround]]
// |[ _m~1~_ : _m~n~_ ] := _round_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \lfloor M_n \rceil ]
|_n_
|Round all values in memory locations _m~1~_ to _m~n~_ to the real values representing their nearest integers and return the number of memory locations affected by the operation.
 +
 +
 NOTE: Rounding rule is to round away from zero. (Differs from Python3 _round-to-even_ rule!)

|`mrround( _m~1~_, _m~n~_ )` [[_mrround]]
// |[ _m~1~_ : _m~n~_ ] := _round_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \lfloor M_n \rceil ]
|_n_
|Round all values (interpreted as floating point values) in memory locations _m~1~_ to _m~n~_ to the real values representing their nearest integers and return the number of memory locations affected by the operation.

4+|*Absolute Value*

|`mabs( _m~1~_, _m~n~_ )` [[_mabs]]
// |[ _m~1~_ : _m~n~_ ] := \| [ _m~1~_ : _m~n~_ ] \|
|latexmath:[ M_n := \| M_n \| ]
|_n_
|Convert all values in memory locations _m~1~_ to _m~n~_ to their absolute values and return the number of memory locations affected by the operation.

|`mrabs( _m~1~_, _m~n~_ )` [[_mrabs]]
// |[ _m~1~_ : _m~n~_ ] := \| [ _m~1~_ : _m~n~_ ] \|
|latexmath:[ M_n := \| M_n \| ]
|_n_
|Convert all values (interpreted as floating point) in memory locations _m~1~_ to _m~n~_ to their absolute values and return the number of memory locations affected by the operation.

4+|*Sign*

|`msign( _m~1~_, _m~n~_ )` [[_msign]]
// |[ _m~1~_ : _m~n~_ ] := _sign_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \sgn(M_n) ]
 +
 +
 latexmath:[ \sgn(x) = \begin{cases} 1 & \quad \text{if } x > 0 \\ 0 & \quad \text{if } x = 0 \\ -1 & \quad \text{if } x < 0 \end {cases} ]
|_n_
|Replace all values in memory locations _m~1~_ to _m~n~_ with their signs as 1 or -1, and return the number of memory locations affected by the operation.

|`mrsign( _m~1~_, _m~n~_ )` [[_mrsign]]
// |[ _m~1~_ : _m~n~_ ] := _sign_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \sgn(M_n) ]
|_n_
|Replace all values (interpreted as floating point) in memory locations _m~1~_ to _m~n~_ with their signs as 1.0 or -1.0, and return the number of memory locations affected by the operation.

|===

[[evaluatormemory_arraylogexp]]
==== Logarithms and Exponential Functions

.Array Logarithm and Exponential Functions
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

4+|*log~2~*

|`mlog2( _m~1~_, _m~n~_ )` [[_mlog2]]
// |[ _m~1~_ : _m~n~_ ] := _log~2~_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \log_2(M_n) ]
|_n_
|Compute the base-2 logarithm of values in memory locations _m~1~_ to _m~n~_. Return the number of memory locations affected by the operation.

|`mrlog2( _m~1~_, _m~n~_ )` [[_mrlog2]]
// |[ _m~1~_ : _m~n~_ ] := _log~2~_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \log_2(M_n) ]
|_n_
|Compute the base-2 logarithm of values (interpreted as floating point) in memory locations _m~1~_ to _m~n~_. Return the number of memory locations affected by the operation.

4+|*Natural Logarithm*

|`mlog( _m~1~_, _m~n~_ )` [[_mlog]]
// |[ _m~1~_ : _m~n~_ ] := _ln_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \ln(M_n) ]
|_n_
|Compute the natural logarithm of values in memory locations _m~1~_ to _m~n~_. Return the number of memory locations affected by the operation.

|`mrlog( _m~1~_, _m~n~_ )` [[_mrlog]]
// |[ _m~1~_ : _m~n~_ ] := _ln_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \ln(M_n) ]
|_n_
|Compute the natural logarithm of values (interpreted as floating point) in memory locations _m~1~_ to _m~n~_. Return the number of memory locations affected by the operation.

4+|*log~10~*

|`mlog10( _m~1~_, _m~n~_ )` [[_mlog10]]
// |[ _m~1~_ : _m~n~_ ] := _log~10~_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \log_{10}(M_n) ]
|_n_
|Compute the base-10 logarithm of values in memory locations _m~1~_ to _m~n~_. Return the number of memory locations affected by the operation.

|`mrlog10( _m~1~_, _m~n~_ )` [[_mrlog10]]
// |[ _m~1~_ : _m~n~_ ] := _log~10~_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \log_{10}(M_n) ]
|_n_
|Compute the base-10 logarithm of values (interpreted as floating point) in memory locations _m~1~_ to _m~n~_. Return the number of memory locations affected by the operation.

4+|*exp~2~*

|`mexp2( _m~1~_, _m~n~_ )` [[_mexp2]]
// |[ _m~1~_ : _m~n~_ ] := _exp2_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := 2^{M_n} ]
|_n_
|Perform 2^x^ for all values x in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`mrexp2( _m~1~_, _m~n~_ )` [[_mrexp2]]
// |[ _m~1~_ : _m~n~_ ] := _exp2_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := 2^{M_n} ]
|_n_
|Perform 2^x^ for all values x (interpreted as floating point values) in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

4+|*Exponentiation*

|`mexp( _m~1~_, _m~n~_ )` [[_mexp]]
// |[ _m~1~_ : _m~n~_ ] := _exp_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := e^{M_n} ]
|_n_
|Perform e^x^ for all values x in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`mrexp( _m~1~_, _m~n~_ )` [[_mrexp]]
// |[ _m~1~_ : _m~n~_ ] := _exp_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := e^{M_n} ]
|_n_
|Perform e^x^ for all values x (interpreted as floating point values) in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

4+|*exp~10~*

|`mexp10( _m~1~_, _m~n~_ )` [[_mexp10]]
// |[ _m~1~_ : _m~n~_ ] := _exp10_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := 10^{M_n} ]
|_n_
|Perform 10^x^ for all values x in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`mrexp10( _m~1~_, _m~n~_ )` [[_mrexp10]]
// |[ _m~1~_ : _m~n~_ ] := _exp10_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := 10^{M_n} ]
|_n_
|Perform 10^x^ for all values x (interpreted as floating point values) in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|===

[[evaluatormemory_arraytrighyp]]
==== Trigonometric and Hyperbolic

.Array Trigonometric and Hyperbolic Functions
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

4+|*Angle Conversion*

|`mrad( _m~1~_, _m~n~_ )` [[_mrad]]
// |[ _m~1~_ : _m~n~_ ] := _rad_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \displaystyle \frac{\pi}{180} \cdot M_n ]
|_n_
|Convert all values (assumed to be degrees) in memory locations _m~1~_ to _m~n~_ to radians and return the number of memory locations affected by the operation.

|`mrrad( _m~1~_, _m~n~_ )` [[_mrrad]]
// |[ _m~1~_ : _m~n~_ ] := _rad_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \displaystyle \frac{\pi}{180} \cdot M_n ]
|_n_
|Convert all values (assumed to be degrees and interpreted as floating point) in memory locations _m~1~_ to _m~n~_ to radians and return the number of memory locations affected by the operation.

|`mdeg( _m~1~_, _m~n~_ )` [[_mdeg]]
// |[ _m~1~_ : _m~n~_ ] := _deg_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \displaystyle \frac{180}{\pi} \cdot M_n ]
|_n_
|Convert all values (assumed to be radians) in memory locations _m~1~_ to _m~n~_ to degrees and return the number of memory locations affected by the operation.

|`mrdeg( _m~1~_, _m~n~_ )` [[_mrdeg]]
// |[ _m~1~_ : _m~n~_ ] := _deg_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \displaystyle \frac{180}{\pi} \cdot M_n ]
|_n_
|Convert all values (assumed to be radians and interpreted as floating point) in memory locations _m~1~_ to _m~n~_ to degrees and return the number of memory locations affected by the operation.

4+|*Trigonometric*

|`msin( _m~1~_, _m~n~_ )`
 +
 `mcos( _m~1~_, _m~n~_ )`
 +
 `mtan( _m~1~_, _m~n~_ )`
// |[ _m~1~_ : _m~n~_ ] := _sin_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _cos_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _tan_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \sin(M_n) ]
 +
 latexmath:[ M_n := \cos(M_n) ]
 +
 latexmath:[ M_n := \tan(M_n) ]
|_n_
|Compute sin(_x_), cos(_x_) or tan(_x_) for all _x_ in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`mrsin( _m~1~_, _m~n~_ )`
 +
 `mrcos( _m~1~_, _m~n~_ )`
 +
 `mrtan( _m~1~_, _m~n~_ )`
// |[ _m~1~_ : _m~n~_ ] := _sin_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _cos_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _tan_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \sin(M_n) ]
 +
 latexmath:[ M_n := \cos(M_n) ]
 +
 latexmath:[ M_n := \tan(M_n) ]
|_n_
|Compute sin(_x_), cos(_x_) or tan(_x_) for all _x_ (interpreted as floating point) in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

4+|*Inverse Trigonometric*

|`masin( _m~1~_, _m~n~_ )`
 +
 `macos( _m~1~_, _m~n~_ )`
 +
 `matan( _m~1~_, _m~n~_ )`
// |[ _m~1~_ : _m~n~_ ] := _asin_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _acos_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _atan_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \arcsin(M_n) ]
 +
 latexmath:[ M_n := \arccos(M_n) ]
 +
 latexmath:[ M_n := \arctan(M_n) ]
|_n_
|Compute asin(_x_), acos(_x_) or atan(_x_) for all _x_ in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`mrasin( _m~1~_, _m~n~_ )`
 +
 `mracos( _m~1~_, _m~n~_ )`
 +
 `mratan( _m~1~_, _m~n~_ )`
// |[ _m~1~_ : _m~n~_ ] := _asin_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _acos_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _atan_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \arcsin(M_n) ]
 +
 latexmath:[ M_n := \arccos(M_n) ]
 +
 latexmath:[ M_n := \arctan(M_n) ]
|_n_
|Compute asin(_x_), acos(_x_) or atan(_x_) for all _x_ (interpreted as floating point) in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

4+|*Hyperbolic*

|`msinh( _m~1~_, _m~n~_ )`
 +
 `mcosh( _m~1~_, _m~n~_ )`
 +
 `mtanh( _m~1~_, _m~n~_ )`
// |[ _m~1~_ : _m~n~_ ] := _sinh_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _cosh_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _tanh_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \sinh(M_n) ]
 +
 latexmath:[ M_n := \cosh(M_n) ]
 +
 latexmath:[ M_n := \tanh(M_n) ]
|_n_
|Compute sinh(_x_), cosh(_x_) or tanh(_x_) for all _x_ in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`mrsinh( _m~1~_, _m~n~_ )`
 +
 `mrcosh( _m~1~_, _m~n~_ )`
 +
 `mrtanh( _m~1~_, _m~n~_ )`
// |[ _m~1~_ : _m~n~_ ] := _sinh_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _cosh_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _tanh_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \sinh(M_n) ]
 +
 latexmath:[ M_n := \cosh(M_n) ]
 +
 latexmath:[ M_n := \tanh(M_n) ]
|_n_
|Compute sinh(_x_), cosh(_x_) or tanh(_x_) for all _x_ (interpreted as floating point) in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

4+|*Inverse Hyperbolic*

// cspell:ignore asinh acosh atanh
|`masinh( _m~1~_, _m~n~_ )`
 +
 `macosh( _m~1~_, _m~n~_ )`
 +
 `matanh( _m~1~_, _m~n~_ )`
// |[ _m~1~_ : _m~n~_ ] := _asinh_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _acosh_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _atanh_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \arcsinh(M_n) ]
 +
 latexmath:[ M_n := \arccosh(M_n) ]
 +
 latexmath:[ M_n := \arctanh(M_n) ]
|_n_
|Compute asinh(_x_), acosh(_x_) or atanh(_x_) for all _x_ in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`mrasinh( _m~1~_, _m~n~_ )`
 +
 `mracosh( _m~1~_, _m~n~_ )`
 +
 `mratanh( _m~1~_, _m~n~_ )`
// |[ _m~1~_ : _m~n~_ ] := _asinh_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _acosh_( [ _m~1~_ : _m~n~_ ] )
// +
// [ _m~1~_ : _m~n~_ ] := _atanh_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \arcsinh(M_n) ]
 +
 latexmath:[ M_n := \arccosh(M_n) ]
 +
 latexmath:[ M_n := \arctanh(M_n) ]
|_n_
|Compute asinh(_x_), acosh(_x_) or atanh(_x_) for all _x_ (interpreted as floating point) in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

// cspell:ignore sinc
4+|*Sinc*

|`msinc( _m~1~_, _m~n~_ )`
// |[ _m~1~_ : _m~n~_ ] := _sinc_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \displaystyle \frac{\sin{ \pi M_n }}{\pi M_n} ]
|_n_
|Compute sin( _&#960;x_ ) / _&#960;x_ for all _x_ in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|`mrsinc( _m~1~_, _m~n~_ )`
// |[ _m~1~_ : _m~n~_ ] := _sinc_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := \displaystyle \frac{\sin{ \pi M_n }}{\pi M_n} ]
|_n_
|Compute sin( _&#960;x_ ) / _&#960;x_ for all _x_ (interpreted as floating point) in memory locations _m~1~_ to _m~n~_ and return the number of memory locations affected by the operation.

|===

[[evaluatormemory_arraybitwise]]
==== Bitwise Operations

.Array Bitwise Functions
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

4+|*Shift*

|`mshr( _m~1~_, _m~n~_, _b_ )` [[_mshr]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] >> _b_
|latexmath:[ M_n := M_n \text{ >> } b ]
 +
 +
 where
 +
 +
 latexmath:[ a \text{ >> } b \quad] shifts integer latexmath:[a] right by latexmath:[b] bit positions.
|_n_
|Shift all values in memory locations _m~1~_ to _m~n~_ right by _b_ bits and return the number of memory locations affected by the operation.

|`mvshr( _A_, _B_, _k_ )` [[_mvshr]]
|[ _A~1~_ : _A~k~_ ] := [ _A~1~_ >> _B~1~_ : _A~k~_ >> _B~k~_ ]
|_k_
|For all _i_ from 1 through _k_, shift integer value in memory location _A~i~_ right by the number of bits indicated by integer value in memory location _B~i~_ and store the result in location _A~i~_, then return _k_.

|`mshl( _m~1~_, _m~n~_, _b_ )` [[_mshl]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] << _b_
|latexmath:[ M_n := M_n \text{ << } b ]
 +
 +
 where
 +
 +
 latexmath:[ a \text{ << } b \quad] shifts integer latexmath:[a] left by latexmath:[b] bit positions.
|_n_
|Shift all values in memory locations _m~1~_ to _m~n~_ left by _b_ bits and return the number of memory locations affected by the operation.

|`mvshl( _A_, _B_, _k_ )` [[_mvshl]]
|[ _A~1~_ : _A~k~_ ] := [ _A~1~_ << _B~1~_ : _A~k~_ << _B~k~_ ]
|_k_
|For all _i_ from 1 through _k_, shift integer value in memory location _A~i~_ left by the number of bits indicated by integer value in memory location _B~i~_ and store the result in location _A~i~_, then return _k_.

4+|*Logical*

|`mand( _m~1~_, _m~n~_, _x_ )` [[_mand]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] & _x_
|latexmath:[ M_n := M_n \text{ & } x ]
 +
 +
 where
 +
 +
 latexmath:[ a \text{ & } x \quad] performs bitwise AND on integers latexmath:[a \text{ and } x].
|_n_
|Perform bitwise-AND operation on all values in memory locations _m~1~_ to _m~n~_ using mask _x_ and return the number of memory locations affected by the operation.

|`mvand( _A_, _B_, _k_ )` [[_mvand]]
|[ _A~1~_ : _A~k~_ ] := [ _A~1~_ & _B~1~_ : _A~k~_ & _B~k~_ ]
|_k_
|For all _i_ from 1 through _k_, perform bitwise-AND on integer values in memory locations _A~i~_ and _B~i~_ and store the result in location _A~i~_, then return _k_.

|`mor( _m~1~_, _m~n~_, _x_ )` [[_mor]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] \| _x_
|latexmath:[ M_n := M_n \text{ \| } x ]
 +
 +
 where
 +
 +
 latexmath:[ a \text{ \| } x \quad] performs bitwise OR on integers latexmath:[a \text{ and } x].
|_n_
|Perform bitwise-OR operation on all values in memory locations _m~1~_ to _m~n~_ using mask _x_ and return the number of memory locations affected by the operation.

|`mvor( _A_, _B_, _k_ )` [[_mvor]]
|[ _A~1~_ : _A~k~_ ] := [ _A~1~_ \| _B~1~_ : _A~k~_ \| _B~k~_ ]
|_k_
|For all _i_ from 1 through _k_, perform bitwise-OR on integer values in memory locations _A~i~_ and _B~i~_ and store the result in location _A~i~_, then return _k_.

|`mxor( _m~1~_, _m~n~_, _x_ )` [[_mxor]]
// |[ _m~1~_ : _m~n~_ ] := [ _m~1~_ : _m~n~_ ] ^ _x_
|latexmath:[ M_n := M_n \text{ ^ } x ]
 +
 +
 where
 +
 +
 latexmath:[ a \text{ ^ } x \quad] performs bitwise XOR on integers latexmath:[a \text{ and } x].
|_n_
|Perform bitwise-XOR operation on all values in memory locations _m~1~_ to _m~n~_ using mask _x_ and return the number of memory locations affected by the operation.

|`mvxor( _A_, _B_, _k_ )` [[_mvxor]]
|[ _A~1~_ : _A~k~_ ] := [ _A~1~_ ^ _B~1~_ : _A~k~_ ^ _B~k~_ ]
|_k_
|For all _i_ from 1 through _k_, perform bitwise-XOR on integer values in memory locations _A~i~_ and _B~i~_ and store the result in location _A~i~_, then return _k_.

4+|*Other*

// cspell:ignore popcnt
|`mpopcnt( _m~1~_, _m~n~_ )` [[_mpopcnt]]
|latexmath:[ M_n := popcnt(M_n) ]
 +
 +
 where
 +
 +
 latexmath:[ popcnt(a) ] is the number of bits set to 1 in the binary representation of latexmath:[a].
|_n_
|Count the number of bits set to 1 for all values in memory locations _m~1~_ to _m~n~_, update all locations with their respective bit counts and return the number of memory locations affected.


|===

[[evaluatormemory_arrayhash]]
==== Hashing

.Array Hashing
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

|`mhash( _m~1~_, _m~n~_ )` [[_mhash]]
// |[ _m~1~_ : _m~n~_ ] := _hash_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ M_n := h(M_n) ]
 +
 +
 where
 +
 +
 latexmath:[ h : x \mapsto y ]
 +
 such that latexmath:[y] has the properties of a uniformly distributed random number with respect to latexmath:[x].
|_n_
|Compute the 64-bit integer hash of all values in memory locations _m~1~_ to _m~n~_, update all locations with their hash value and return the number of memory locations affected.

|===

[[evaluatormemory_arrayaggregate]]
==== Aggregation

.Array Aggregation
[cols="15,16,3,12"]
|===
|Function |Operation |Ret | Description

4+|*Sum*

|`msum( _dest_, _m~1~_, _m~n~_ )` [[_msum]]
// |[_dest_] = &#8721;( [ _m~1~_ : _m~n~_ ] )
|latexmath:[[dest\] := \displaystyle \sum M_n ]
|[_dest_]
|Add all numeric values in memory locations _m~1~_ through _m~n~_ and assign the resulting sum to memory location _dest_ as a _real_ value then return the result.

|`mrsum( _dest_, _m~1~_, _m~n~_ )` [[_mrsum]]
// |[_dest_] = &#8721;( [ _m~1~_ : _m~n~_ ] )
|latexmath:[[dest\] := \displaystyle \sum M_n ]
|[_dest_]
|Add all values (interpreted as floating point) in memory locations _m~1~_ through _m~n~_ and assign the resulting sum to memory location _dest_ as a _real_ value then return the result.

|`msumsqr( _dest_, _m~1~_, _m~n~_ )` [[_msumsqr]]
// |[_dest_] = &#8721;( [ _m~1~_ : _m~n~_ ] ^2^ )
|latexmath:[[dest\] := \displaystyle \sum (M_n)^2 ]
|[_dest_]
|Add the square of all numeric values in memory locations _m~1~_ through _m~n~_ and assign the resulting sum to memory location _dest_ then return the result.

|`mrsumsqr( _dest_, _m~1~_, _m~n~_ )` [[_mrsumsqr]]
// |[_dest_] = &#8721;( [ _m~1~_ : _m~n~_ ] ^2^ )
|latexmath:[[dest\] := \displaystyle \sum (M_n)^2 ]
|[_dest_]
|Add the square of all values (interpreted as floating point) in memory locations _m~1~_ through _m~n~_ and assign the resulting sum to memory location _dest_ then return the result.

|`minvsum( _dest_, _m~1~_, _m~n~_ )` [[_minvsum]]
// |[_dest_] = &#8721;( 1 / [ _m~1~_ : _m~n~_ ] )
|latexmath:[[dest\] := \displaystyle \sum \frac{1}{M_n} ]
|[_dest_]
|Add the inverse of all numeric values in memory locations _m~1~_ through _m~n~_ and assign the resulting sum to memory location _dest_ then return the result.

|`mrinvsum( _dest_, _m~1~_, _m~n~_ )` [[_mrinvsum]]
// |[_dest_] = &#8721;( 1 / [ _m~1~_ : _m~n~_ ] )
|latexmath:[[dest\] := \displaystyle \sum \frac{1}{M_n} ]
|[_dest_]
|Add the inverse of all values (interpreted as floating point) in memory locations _m~1~_ through _m~n~_ and assign the resulting sum to memory location _dest_ then return the result.

4+|*Product*

|`mprod( _dest_, _m~1~_, _m~n~_ )` [[_mprod]]
// |[_dest_] = &#8719;( [ _m~1~_ : _m~n~_ ] )
|latexmath:[[dest\] := \displaystyle \prod M_n ]
|[_dest_]
|Multiply all numeric values in memory locations _m~1~_ through _m~n~_ and assign the resulting product to memory location _dest_ then return the result.

|`mrprod( _dest_, _m~1~_, _m~n~_ )` [[_mrprod]]
// |[_dest_] = &#8719;( [ _m~1~_ : _m~n~_ ] )
|latexmath:[[dest\] := \displaystyle \prod M_n ]
|[_dest_]
|Multiply all values (interpreted as floating point) in memory locations _m~1~_ through _m~n~_ and assign the resulting product to memory location _dest_ then return the result.

4+|*Mean*

|`mmean( _dest_, _m~1~_, _m~n~_ )` [[_mmean]]
// |[_dest_] = &#8721;( [ _m~1~_ : _m~n~_ ] ) / _n_
|latexmath:[[dest\] := \displaystyle \frac{1}{n} \sum M_n ]
|[_dest_]
|Compute the arithmetic mean (average) of all numeric values in memory locations _m~1~_ through _m~n~_ and assign the result to memory location _dest_ then return the result.

|`mrmean( _dest_, _m~1~_, _m~n~_ )` [[_mrmean]]
// |[_dest_] = &#8721;( [ _m~1~_ : _m~n~_ ] ) / _n_
|latexmath:[[dest\] := \displaystyle \frac{1}{n} \sum M_n ]
|[_dest_]
|Compute the arithmetic mean (average) of all values (interpreted as floating point) in memory locations _m~1~_ through _m~n~_ and assign the result to memory location _dest_ then return the result.

|`mharmmean( _dest_, _m~1~_, _m~n~_ )` [[_mharmmean]]
// |[_dest_] = ( &#8721;( [ _m~1~_ : _m~n~_ ] ^&#8722;1^ ) / _n_ ) ^&#8722;1^
|latexmath:[[dest\] := \displaystyle \left(\frac{1}{n} \sum {\frac{1}{M_n}} \right)^{-1} ]
|[_dest_]
|Compute the harmonic mean of all numeric values in memory locations _m~1~_ through _m~n~_ and assign the result to memory location _dest_ then return the result.

|`mrharmmean( _dest_, _m~1~_, _m~n~_ )` [[_mrharmmean]]
// |[_dest_] = ( &#8721;( [ _m~1~_ : _m~n~_ ] ^&#8722;1^ ) / _n_ ) ^&#8722;1^
|latexmath:[[dest\] := \displaystyle \left(\frac{1}{n} \sum {\frac{1}{M_n}} \right)^{-1} ]
|[_dest_]
|Compute the harmonic mean of all values (interpreted as floating point) in memory locations _m~1~_ through _m~n~_ and assign the result to memory location _dest_ then return the result.

|`mgeomean( _dest_, _m~1~_, _m~n~_ )` [[_mgeomean]]
// |[_dest_] = &#8719;( [ _m~1~_ : _m~n~_ ] ) ^1/_n_^
|latexmath:[[dest\] := \displaystyle \sqrt[n\]{\prod{M_n}} ]
|[_dest_]
|Compute the geometric mean of all numeric values in memory locations _m~1~_ through _m~n~_ and assign the result to memory location _dest_ then return the result.

|`mrgeomean( _dest_, _m~1~_, _m~n~_ )` [[_mrgeomean]]
// |[_dest_] = &#8719;( [ _m~1~_ : _m~n~_ ] ) ^1/_n_^
|latexmath:[[dest\] := \displaystyle \sqrt[n\]{\prod{M_n}} ]
|[_dest_]
|Compute the geometric mean of all values (interpreted as floating point) in memory locations _m~1~_ through _m~n~_ and assign the result to memory location _dest_ then return the result.

4+|*Deviation*

// cspell:ignore stdev
|`mstdev( _dest_, _m~1~_, _m~n~_ )` [[_mstdev]]
// |[_dest_] = _stdev_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ [dest\] := \displaystyle \sqrt{ \frac{1}{n} \displaystyle \sum_{i=1}^n {(x_i-\mu)^2} } ]
 +
 +
 where
 +
 +
 latexmath:[ x_i = \text{value at location } m_i]
 +
 and
 +
 latexmath:[ \mu = \displaystyle \frac{1}{n} \sum M_n]
|[_dest_]
|Compute the standard deviation of numeric values in memory locations _m~1~_ through _m~n~_ and assign the result to memory location _dest_ then return the result.

|`mrstdev( _dest_, _m~1~_, _m~n~_ )` [[_mrstdev]]
// |[_dest_] = _stdev_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ [dest\] := \displaystyle \sqrt{ \frac{1}{n} \displaystyle \sum_{i=1}^n {(x_i-\mu)^2} } ]
|[_dest_]
|Compute the standard deviation of values (interpreted as floating point) in memory locations _m~1~_ through _m~n~_ and assign the result to memory location _dest_ then return the result.

// cspell:ignore geostdev
|`mgeostdev( _dest_, _m~1~_, _m~n~_ )` [[_mgeostdev]]
// |[_dest_] = _geostdev_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ [dest\] := \exp \left(\displaystyle \sqrt{\displaystyle \frac{\displaystyle \sum_{i=1}^n{\left(\ln{\frac{x_i}{\mu_g}}\right)^2}}{n}}\right)     ]
 +
 +
 where
 +
 +
 latexmath:[ x_i = \text{value at location } m_i]
 +
 and
 +
 latexmath:[ \mu_g = \displaystyle \sqrt[n\]{\prod M_n} ]
|[_dest_]
|Compute the geometric standard deviation of numeric values in memory locations _m~1~_ through _m~n~_ and assign the result to memory location _dest_ then return the result.

|`mrgeostdev( _dest_, _m~1~_, _m~n~_ )` [[_mrgeostdev]]
// |[_dest_] = _geostdev_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ [dest\] := \exp \left(\displaystyle \sqrt{\displaystyle \frac{\displaystyle \sum_{i=1}^n{\left(\ln{\frac{x_i}{\mu_g}}\right)^2}}{n}}\right)     ]
|[_dest_]
|Compute the geometric standard deviation of values (interpreted as floating point) in memory locations _m~1~_ through _m~n~_ and assign the result to memory location _dest_ then return the result.

|===

[[evaluatormemory_arrayprobe]]
==== Array Probing

.Array Probing
[cols="14,16,4,12"]
|===
|Function |Operation |Ret | Description

4+|*Simple*

|`mmax( _dest_, _m~1~_, _m~n~_ )` [[_mmax]]
// |[_dest_] = _max_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ [dest\] := \max( M_n ) ]
|_m~k~_
|Find the largest value in memory locations _m~1~_ through _m~n~_ and assign it to memory location _dest_, then return the location _m~k~_ where the largest value was found.

|`mmin( _dest_, _m~1~_, _m~n~_ )` [[_mmin]]
// |[_dest_] = _min_( [ _m~1~_ : _m~n~_ ] )
|latexmath:[ [dest\] := \min( M_n ) ]
|_m~k~_
|Find the smallest value in memory locations _m~1~_ through _m~n~_ and assign it to memory location _dest_, then return the location _m~k~_ where the smallest value was found.

|`mcontains( _m~1~_, _m~n~_, _value_ )` [[_mcontains]]
// | _value_ &#8712; [ _m~1~_ : _m~n~_ ]
|latexmath:[ y = \begin{cases} 1 & \quad \text{if value } \in M_n \\ 0 & \quad \text{if value } \notin M_n \end{cases} ]
|_y_
|Return 1 if _value_ occurs in any memory location _m~1~_ through _m~n~_, otherwise return 0.

|`mcount( _m~1~_, _m~n~_, _value_ )` [[_mcount]]
// | _n_ := \| { _x_ &#8712; [_m~1~_ : _m~n~_] : _x_ = _value_ } \|
|latexmath:[ y = \| { x \in M_n : x = \text{value} } \| ]
| _y_
|Return the number of times _value_ occurs in memory location range _m~1~_ through _m~n~_.

|`mcmp( _A_, _B_, _k_ )` [[_mcmp]]
|latexmath:[ y = cmp( [ A_1 : A_k \], [ B_1 : B_k \] ) ]
 +
 +
 latexmath:[ cmp(a,b) = \begin{cases} 0 & \quad \text{if } a = b \\ 1 & \quad \text{if } a > b \\ -1 & \quad \text{if } a < b \end{cases}]
|_y_
|For all _i_ from 1 through _k_, compare numeric values in memory locations _A~i~_ and _B~i~_. Immediately return -1 at the first iteration where [_A~i~_] < [_B~i~_] or 1 at the first iteration where [_A~i~_] > [_B~i~_]. If [_A~i~_] == [_B~i~_] for all _i_ return 0. If _k_ is such that either _A_ or _B_ extends beyond the end of memory -1 is returned.

|`mcmpa( _A_, _B_, _k_ )` [[_mcmpa]]
|latexmath:[ y = cmp( [ A_1 : A_k \], [ B_1 : B_k \] ) ]
 +
 +
 Element-wise comparison function defined as:
 +
 +
 latexmath:[ cmp(a,b) = \begin{cases} 0 & \quad \text{if } \delta < \varepsilon \\ 1 & \quad \text{if } a > b \wedge \delta \geq \varepsilon \\ -1 & \quad \text{if } a < b \wedge \delta \geq \varepsilon \end{cases}]
 +
 +
 where latexmath:[ \delta = \|a-b\| ]
 +
 and latexmath:[ \varepsilon = 1.1921 \cdot 10^{-7} ]
|_y_
|For all _i_ from 1 through _k_, compare numeric values in memory locations _A~i~_ and _B~i~_ using approximate matching for real values. Real values _a_ and _b_ compare equal when latexmath:[ \|a-b\| < \varepsilon ]. Immediately return -1 at the first iteration where [_A~i~_] < [_B~i~_] or 1 at the first iteration where [_A~i~_] > [_B~i~_]. If [_A~i~_] == [_B~i~_] for all _i_ return 0. If _k_ is such that either _A_ or _B_ extends beyond the end of memory -1 is returned.

|`mindex( _m~1~_, _m~n~_, _value_ )` [[_mindex]]
|latexmath:[ k = \min( i ), i \in [1,n\] \text{ such that} ]
 +
 latexmath:[ value \in [m_1 : m_i\]]
| _m~k~_ or -1
|Return first memory location _m~k~_ where _value_ occurs in range _m~1~_ through _m~n~_. If _value_ does not occur in specified range return -1.

4+|*Subset*

|`msubset( _p~1~_, _p~k~_, _m~1~_, _m~n~_ )` [[_msubset]]
// | [ _p~1~_ : _p~k~_ ] &#8712; [ _m~1~_ : _m~n~_ ]
|latexmath:[ y = \begin{cases} 1 & \quad \text{if } P_k \in M_n \\ 0 & \quad \text{if } P_k \notin M_n \end{cases} ]
 +
 +
 latexmath:[ k \leq n ]
|1 or 0
|Return 1 if all values in probe memory location range _p~1~_ through _p~k~_ occur in memory location range _m~1~_ through _m~n~_, otherwise return 0.

|`msubsetobj( _p~1~_, _p~k~_, _obj_ )` [[_msubsetobj]]
|latexmath:[ y = \begin{cases} 1 & \quad \text{if } P_k \in obj \\ 0 & \quad \text{if } P_k \notin obj \end{cases} ]
 +
 +
 latexmath:[ k \leq \| obj \| ]
|1 or 0
|Return 1 if all values in probe memory location range _p~1~_ through _p~k~_ occur in _obj_, otherwise return 0. The object _obj_ is either a numeric array or a map, i.e. an object for which <<_isarray, isarray()>> or <<_ismap, ismap()>> is true. If _obj_ is a numeric array its values must be integers.

|===


[[evaluator_mappingsets]]
=== Mappings and Sets

These functions operate on built-in maps and sets associated with memory objects.

[CAUTION]
====
The integer set and vertex set functions operate on the same internal set structure. Mixing `iset` and `vset` operations will most certainly yield unexpected results.
====

[[evaluator_integerset]]
==== Integer Set

The integer set is used to store and check existence of unique (32-bit) integer keys. Object _key_ may be of any type, but its raw bit value (as produced by <<_asbits, `asbits(_key_)`>>) is always implied and only the 32 lower bits are used.

Key `0xffffffff` is reserved and cannot be used.

[cols="3,3,6"]
|===
|Function | Return Value |Description

|`iset.add( _key_ )` [[_isetadd]]
|latexmath:[ y = \begin{cases} 1 & \quad \text{key added} \\ 0 & \quad \text{already exists} \\ -1 & \quad \text{error} \end{cases} ]
|Add _key_ to set and return 1 if added or 0 if _key_ already existed in the set. If the value could not be added -1 is returned.

|`iset.del( _key_ )` [[_isetdel]]
|latexmath:[ y = \begin{cases} 1 & \quad \text{key deleted} \\ 0 & \quad \text{does not exist} \end{cases} ]
|Delete _key_ from set and return 1 if deleted or 0 if _key_ did not exist in the set.

|`iset.has( _key_ )` [[_isethas]]
|latexmath:[ y = \begin{cases} 1 & \quad \text{key exists} \\ 0 & \quad \text{does not exist} \end{cases} ]
|Return 1 if _key_ exists in set, otherwise return 0.

|`iset.len()` [[_isetlen]]
|number of mapped keys
|Return the number of keys in set.

|`iset.clr()` [[_isetclr]]
|number of removed keys
|Remove all keys from set and return the number of keys removed.

|===

[[evaluator_vertexset]]
==== Vertex Set

The vertex set is used to store and check existence of unique vertex instances.


[cols="3,3,6"]
|===
|Function | Return Value |Description

|`vset.add( _vertex_ )` [[_vsetadd]]
|latexmath:[ y = \begin{cases} 1 & \quad \text{vertex added} \\ 0 & \quad \text{already exists} \\ -1 & \quad \text{error} \end{cases} ]
|Add _vertex_ to set and return 1 if added or 0 if _vertex_ already existed in the set. If the vertex could not be added -1 is returned.

|`vset.del( _vertex_ )` [[_vsetdel]]
|latexmath:[ y = \begin{cases} 1 & \quad \text{vertex deleted} \\ 0 & \quad \text{does not exist} \end{cases} ]
|Delete _vertex_ from set and return 1 if deleted or 0 if _vertex_ did not exist in the set.

|`vset.has( _vertex_ )` [[_vsethas]]
|latexmath:[ y = \begin{cases} 1 & \quad \text{vertex exists} \\ 0 & \quad \text{does not exist} \end{cases} ]
|Return 1 if _vertex_ exists in set, otherwise return 0.

|`vset.len()` [[_vsetlen]]
|number of vertices
|Return the number of vertices in set.

|`vset.clr()` [[_vsetclr]]
|number of vertices
|Remove all vertices from set and return the number of vertices removed.

|===





[[evaluator_specialpurpose]]
== Special Purpose Operations

This section describes specialized operations for solving specific problems.

.Quick Links
[cols="3,7"]
|===
|Function |Description

|<<evaluator_sumprodobj>>
|

|<<evaluator_probealtarray>>
|Compare array object to probe stored in memory range and compute match score

|<<evaluator_synarc_decay>>
|Time-dependent arc values

|===

// cspell:ignore sumprodobj
[[evaluator_sumprodobj]]
=== _sumprodobj_()

Compute the sum of products of all matching pairs of items in object _obj_ and memory location range latexmath:[ [p_1 : p_k\] ].

The object _obj_ is either a <<_isarray, numeric array>> or a <<_ismap, map>>. If _obj_ is a numeric array its values must be integers.

The items to be matched are compared using key function latexmath:[K(x)] which is either the integer _key_ of _keyval_ item _x_, or _x_ itself if _x_ is an integer.

The item value latexmath:[ V(x) ] is either the float _value_ of _keyval_ item _x_, or 1.0 if _x_ is an integer.

==== Syntax

----
msumprodobj( p1, pk, obj ) -> y
----

==== Parameters

[cols="5,8,15"]
|===
|Parameter |Type |Description

|_p~1~_
|_integer_
|First memory location of probe item

|_p~k~_
|_integer_
|Last memory location of probe item

|_obj_
|<<_isarray, numeric array>> or <<_ismap, map>>
|Numeric array objects are sequences of integers, such as vertex properties assigned as `V.SetProperty( "A", [10,20,30,40] )`. Map object are sets of _keyval_ items, such as vertex properties assigned as `V.SetProperty( "M", {1:2.34, 5:6.78} )`.

|===

==== Return Value

This function returns a floating point value representing the sum of products of item values for all items that occur in both _obj_ and memory range latexmath:[ [p_1 : p_k\] ].

==== Remarks

Items to be matched and whose values are contributing to the sum must be plain integers or _keyval_ items.

Memory probe items are assigned to the memory object using the respective <<datatypes, data type syntax>>.

Integer item in memory probe location::
`m[i] = integer_value`
+
Item key is the assigned integer, and item has implicit value 1.0.

Keyval item in memory probe location::
`m[i] = (integer_key, float_value)`
+
Item key is the tuple's integer_key, and item value is the tuple's float_value.

.Memory probe example
[source, python]
----
from pyvgx import *
g = Graph("test")
m = g.Memory(16)

# Assign integer items
m[0] = 123          # key=123, val=1.0
m[1] = 456          # key=456, val=1.0 
m[2] = 789          # key=789, val=1.0 

# Assign keyval items
m[3] = (200, 2.718) # key=200, val=2.718
m[4] = (300, 3.142) # key=300, val=3.142
----

Objects are typically vertex properties and are assigned according to <<../vertex/vertexProperty.adoc#vertexsetproperty, property assignment syntax>>.

Numeric array in vertex property::
`V[prop] = [v1, v2, ...]`
+
The item key of each integer _v~i~_ is the integer itself, and the item has implicit value 1.0.

Keyval map in vertex property::
`V[prop] = { k1:v1, k2:v2, ... }`
+
The item key of each _k~i~_ : _v~i~_ pair is integer key _k~i~_, and the item value is float _v~i~_.

.Object example (vertex property)
[source, python]
----
from pyvgx import *
g = Graph("test")
V = g.NewVertex( "V" )

# Assign array of three integers to property 'p1'
V['p1'] = [123, 456, 789]

# Assign map of two int:float items to property 'p2'
V['p2'] = {200:2.718, 300:3.142}

----

==== Formula

The return value _s_ is computed as follows.

latexmath:[ s = \displaystyle \sum_{i=1}^k{ \left[   V(p_i) \sum_{j=1}^n{ \bigg( V(x_j) \: \big| \: x_j \in obj \wedge M(p_i,x_j)  \bigg)  }   \right\] }]

where

latexmath:[ V(x) = \begin{cases} \text{value of x} & \quad \text{if x is keyval} \\ 1 & \quad \text{if x is integer} \end{cases} ]

and

latexmath:[ M(a,b) = \begin{cases} true & \quad \text{if } K(a) = K(b) \\ false & \quad \text{if } K(a) \ne K(b) \end{cases} ]

and

latexmath:[ K(x) = \begin{cases} \text{key of x} & \quad \text{if x is keyval} \\ x & \quad \text{if x is integer} \end{cases} ]

and

latexmath:[ n = | obj | ]

==== Example

[source, python]
----
from pyvgx import *
g = Graph("test")
m = g.Memory(16)

# Vertex with array and map properties
#V = g.NewVertex("V")
V['p1'] = [123, 456, 789]
V['p2'] = {200:2.718, 300:3.142}

# Probe items
m[0] = 123
m[1] = 456
m[2] = 789
m[3] = (200, 2.718)
m[4] = (300, 3.142)

# Probe against numeric array object will
# match three integer items and
# return 3.0
g.Evaluate( "msumprodobj(0,4,next['p1'])", memory=m, head="V" )

# Probe against keyval map object will
# match two keyval items and
# return 17.26
g.Evaluate( "msumprodobj(0,4,next['p2'])", memory=m, head="V" )
----

// cspell:ignore probealtarray altarray
[[evaluator_probealtarray]]
=== _probealtarray_()

Test if all elements of a probe stored in memory range [_p~1~_, _p~n~_] exist in array object _altarray_ and return a position-dependent and match-type dependent score. The array can have up to 16 elements. Array elements are _dual-value integers_, divided into a *primary* region and a *secondary* (alternative) region. For a probe element and an array element to match their primary regions must be equal, or their secondary regions must be equal. A probe element may also be a _dual bitvector_ split into a primary and secondary region for cases where the probe is already known to match the array object in one or more positions, but needs to be included for keeping track of number of matches and their positions.

==== Syntax

----
probealtarray( p1, pn, altarray, prefix_boost, alt_deboost ) -> score
----

==== Parameters

[cols="5,8,15"]
|===
|Parameter |Type |Description

|_p~1~_, _p~n~_
|2 x 32-bit integers
 +
 or
 +
 2 x 16-bit bitvectors
|Memory locations 1, 2, ..., _n_ of the probe holding _dual-value integers_ or _dual bitvectors_

|_altarray_
|Numeric array object (multi-valued vertex property)
|Array object to be probed, containing up to 16 _dual-value integers_. 

|_prefix_boost_
|_real_
|Score multiplier for ordered match starting from the first element of _altarray_

// cspell:ignore deboost
|_alt_deboost_
|_real_
|Score multiplier for match involving one or more matches on secondary (alternative) element regions

|===

*_altarray_*: The values in _altarray_ are presumed to be encoded as two 32-bit integers packed into a 64-bit integer. This special encoding will be referred to as _dual-value integer_. The upper 32 bits represent the *primary* region. The lower 32 bits represent the *secondary* (or alternative) region. This makes it possible for two distinct values to occupy the same position in _altarray_, enabling position-aware matching with alternative scoring depending on which region of the element is matched.

*[_p~1~_, _p~n~_]*: A probe element is either a _dual-value integer_ encoded the same way as values in _altarray_, or a _dual bitvector_. A <<_bitvector, bitvector>> in this context uses only the 32 lower bits, subdivided into a 16-bit *primary* region (bits 16-31) and a 16-bit *secondary* region (bits 0-15.) A bitvector asserts a match in all position(s) of _altarray_ corresponding to bitvector position(s) set to 1.

Probe elements _p~1~_ through _p~n~_ reference a consecutive region of a <<evaluatormemory, memory object>> into which the probe data must be entered before calling _probealtarray_().

[IMPORTANT]
====
Probe bitvectors are limited to 32 bits and therefore _dual bitvectors_ are limited to 16 bit positions. Hence the number of positions we are able to keep track of in _altarray_ is also 16. The reason for the 32-bit restriction is to maintain compatibility with arc values, which often will be the carriers of data used to construct bitvector probes.
====

==== Return Value

The default (un-boosted) score returned when all probe elements exist in the array is 1.0. If one or more probe elements do not exist in array 0.0 is returned.

If probe elements match the array _in order, starting from the first array element_ (a prefix match) the return score is multiplied by _prefix_boost_.

If any element match occurs because of a match in the secondary region (due to no match in primary region) the return score is multiplied by _alt_deboost_.

==== Remarks

Probe elements _p~1~_ through _p~n~_ are evaluated against values in _altarray_, in order. Each time a match is found it is "consumed", i.e. if a probe element matched position _q_ in _altarray_ no subsequent probe element can match position _q_ in _altarray_.

Probe elements encoded as _dual-value integers_ are compared against values in _altarray_ by matching primary regions first, then secondary regions if no match in primary regions. As long as ordered (prefix) matches can continue to be made, an element is declared a match if either primary or secondary regions match. If ordered matching fails, unordered matching is attempted and in this case all possibilities for primary region matches are considered before any secondary region matches are considered.

Probe elements encoded as _dual bitvectors_ are used to assert matches in _altarray_ at the position(s) corresponding to 1s in the bitvectors. When a bitvector probe _p~k~_ is matched against a value in _altarray_, the position _q_ of the least significant 1 in the bitvector that also corresponds to unmatched position _q_ in _altarray_ (if one exists) is marked as matched, i.e. position _q_ cannot be matched by any subsequent probe. The primary bit-region of _p~k~_ is processed first, then if no match the secondary bit-region of _p~k~_ is processed. Note that bitvector probe _p~k~_ will only consume one position _q_ in altarray even if _p~k~_ has multiple bits set to 1.

==== Example

[source, python]
----
# Create a vertex and assign a multi-valued
# property of dual-value integers
V = graph.NewVertex( "V" )
V['data'] = [ (1111 << 32) + 555, (4444 << 32) + 444, (3333 << 32) + 1000, (7777 << 32) + 555 ]

# Create the probe
probe = graph.Memory( 32 )
probe[1] = (1111 << 32) + 555   # primary match (pos 0)
probe[2] = (9999 << 32) + 1000  # secondary match (pos 2)
probe[3] = [ 0x00000009 ]       # secondary match (pos 0 and 3)

# Execute search
graph.Evaluate( "probealtarray( 1 , 3, vertex['data'], 100.0, 0.5 )", head=V, memory=probe )  # -> 0.5

# Explanation:
# probe[1] has a primary match for 1111 in pos 0
# probe[2] has a secondary match for 1000 in pos 2
# probe[3] is a bitvector and asserts secondary matches
#          in positions 0 and 3 (0x9 = binary 1001). Position 0
#          was consumed by probe[1] but position 3 was not
#          yet consumed and therefore a match occurs.
# We do not have a prefix match, and we are falling back
# on secondary matches, hence the returned score is
# 1.0 * 0.5 = 0.5.
----

// cspell:ignore synarc xdecay
[[evaluator_synarc_decay]]
=== _synarc.decay_() and _synarc.xdecay_()

Compute age-dependent arc value.

Linear decay `synarc.decay()`::
latexmath:[ N_t = N_0 - r \cdot t ]

Exponential decay `synarc.xdecay()`::
latexmath:[ N_t = N_0 e^{-\lambda t} ]

[[synarc_decay_syntax]]
==== Syntax

[source, python]
----
synarc.decay( relationship[, rate] ) -> decayed_value Nt
synarc.xdecay( relationship[, rate] ) -> decayed_value Nt
----

[[synarc_decay_parameters]]
==== Parameters

[cols="5,5,5,15"]
|===
|Parameter |Type |Default| Description

|_relationship_
|`string` or `integer`
|
|Relationship type given as string or as integer enumeration. To enable computation of decayed value _N~t~_ the relationship must be represented by a <<../graph/graphArc.adoc#multiple_arc, multiple arc>> comprising a creation (`M_TMC`) and/or modification time (`M_TMM`), an initial value _N~0~_ (floating point modifier(s)), and an expiration time (`M_TMX`), all sharing the same relationship type.

|__rate__
|`real`
|latexmath:[ \displaystyle \frac{1}{t_{end} - t_0} ]
|Optional _rate_ overrides _rate_ derived from arc timestamps. Decay constants are always computed as: 
 +
 +
 latexmath:[ r = rate \cdot N_0 ]
 +
 +
 latexmath:[ \lambda = rate \cdot ln \left( 10^4 \right) ] 
 +
 +
 By default linear decay produces latexmath:[ N_t = 0 ] at latexmath:[ t_1 = t_{end} ] and exponential decay produces latexmath:[ N_t = \frac{N_0}{10000} ] at latexmath:[ t_1 = t_{end} ].
|===

[[synarc_decay_return_value]]
==== Return Value

This function returns either _null_ or a _real_ value:

_null_:: Evaluation of the expression containing `synarc.decay()` or `synarc.xdecay()` occurs for each traversed arc during neighborhood traversal, and for all such evaluations this function returns _null_.

_N~t~_:: <<synarc_decay_post_traversal>> of the expression takes place each time all arcs between two vertices have been processed, and at this point a real value representing decayed value _N~t~_ is returned.

[[synarc_decay_remarks]]
==== Remarks

Arc decay functions are special in that they require multiple evaluations to compute a result. Arc components are first captured during traversal of the multiple arc, and finally the decayed value _N~t~_ is computed using those components when the expression is invoked one additional time post-traversal.

[[synarc_decay_arc_components]]
===== Capture arc components
During processing of arcs the arc decay functions will capture arc information for arcs whose relationship matches the _rel_ argument. The arc's value is captured and interpreted according to the modifier.

_t~0~_::
`(A) -[ rel, M_TMC, t~c~ ]\-> (B)` +
`(A) -[ rel, M_TMM, t~m~ ]\-> (B)` +
+
When a decay function is evaluated at time _t~1~_ the creation (or modification) time _t~0~_ provides a reference for computing elapsed time _t_ required by the decay formulas. If both `M_TMC` and `M_TMM` arcs exist the value from the `M_TMM` arc takes precedence.
+
latexmath:[ t_0 = \begin{cases} t_m & \quad \text{if M_TMM arc exists} \\ t_c & \quad \text{if M_TMC arc exists and M_TMM arc does not exist} \end {cases} ]
+
If neither `M_TMC` nor `M_TMM` arc exists _t~0~_ takes on a default value:
+
latexmath:[ t_0 = \begin{cases} t_{end} - \frac{1}{rate} & \quad \text{if rate > 0 and M_TMX arc exists} \\ graph.t_0 & \quad \text{if rate = 0 or M_TMX arc does not exist} \end {cases} ]
+
where latexmath:[ graph.t_0 ] is the <<_grapht0, graph inception time>>.

_t~end~_::
`(A) -[ rel, M_TMX, t~x~ ]\-> (B)` +
+
The time _t~1~_ at which the arc's decayed value reaches its minimum is _t~end~_, which is provided by an arc with the `M_TMX` modifier. 
+
latexmath:[ t_{end} = t_x ]
+
If no arc with modifier `M_TMX` exists _t~end~_ takes on a default value:
+
latexmath:[ t_{end} = \begin{cases} t_0 + \frac{1}{rate} & \quad \text{if } rate > 0 \text{ and } t_0 > graph.t_0 \\ \to \infty & \quad \text{if } rate = 0 \text{ or } t_0 \leq graph.t_0 \end{cases} ]

N~0~::
`(A) -[ rel, M_FLT, v~i~ ]\-> (B)` +
`(A) -[ rel, M_ACC, v~i~ ]\-> (B)` +
`(A) -[ rel, M_SIM, v~i~ ]\-> (B)` +
`(A) -[ rel, M_DIST, v~i~ ]\-> (B)` +
+
The arc's initial value _N~0~_ is derived as the sum of all arcs _with a floating point modifier_. Let _n_ be the number of such arcs, then: +
 +
 latexmath:[ N_0 = \begin{cases} \displaystyle \sum_{i=1}^n{v_i} & \quad \text{if } n > 0 \\ 1 & \quad \text{if } n = 0 \text{ and } rate > 0 \\ 0 & \quad \text{if } n = 0 \text{ and } rate = 0 \end{cases}]

Arcs with relationships other than _rel_, or with modifiers other than those with timestamp or floating point values are ignored by the arc decay function. The ignored non-floating point modifiers are `M_STAT`, `M_LSH`, `M_INT`, `M_UINT`, and `M_CNT`.

The value returned by `synarc.decay()` and `synarc.xdecay()` is always _null_ when the expression is evaluated as part of arc traversal.

[[synarc_decay_post_traversal]]
===== Post-traversal evaluation
Arc decay functions are available for use in <<../vertex/vertexFilter.adoc#vertexfilteradjacentfilter, adjacency filters>> and <<../vertex/vertexFilter.adoc#vertexfiltertraversefilter, traversal filters>>, i.e. filters involving processing of arcs. Normally such filters evaluate once for each arc. However, when an expression contains one or more calls to an arc decay function *the expression is invoked one additional time for each head vertex* following completion of arc processing for that head vertex. Specifically, if _a_ arcs are processed for _h_ head vertices the expression is invoked _a_ + _h_ times, instead of the normal _a_ times for expressions without arc decay functions.

WARNING: Beware of the extra evaluation per vertex pair since this will have side-effects for other functions within the same expression such as `count()`, `inc()`, `rwrite()`, and many others.

[[synarc_decay_synthetic_arc]]
===== Synthetic arc and return value
The arc processed by the expression at the final invocation is a <<evaluator_synthetic_arcs, _synthetic arc_>> that triggers different behavior for functions like `synarc.decay()` and `synarc.xdecay()`. The behavior triggered is to compute and return the decayed value _N~t~_ based on the current time _t~1~_ and arc components captured during processing of arcs.

Expressions should check for `next.arc.issyn == true` or include a type-check such as `isreal()` on the value returned by `synarc.decay()` and `synarc.xdecay()` if the value is to be used as part of a larger expression.

[[synarc_decay_formulas]]
===== Decay Formula Summary

Elapse time _t_::
The relative elapse time _t_ is the difference between the expression invocation time _t~1~_ and the arc's initial time _t~0~_.
+
latexmath:[ t = t_1 - t_0 ]

Decay rate::
If _rate_ is not explicitly given, it is derived from the arc's lifespan:
+
latexmath:[ rate = \displaystyle \frac{1}{t_{end} - t_0} ]

Initial value::
The arc's initial value _N~0~_ is computed as:
+
latexmath:[ N_0 = \displaystyle \sum_{i=1}^n{ v_i } ] +
where _n_ is the number of arc values _v_ with a floating point modifier.
+
If no arcs exist with a floating point modifier (_n_ = 0) the initial value defaults to:
+
latexmath:[ N_0 = \begin{cases} 1 & \quad \text{if } rate > 0 \\ 0 & \quad \text {if } rate = 0 \end{cases}]

Linear decay function `synarc.decay( rel[, rate] )`::
The arc value at elapse time _t_ is computed as:
+
latexmath:[ N_t = N_0 - r \cdot t ]
+
latexmath:[ r = \begin{cases} \frac{N_0}{t_{end} - t_0} & \quad \text{if no rate parameter} \\ rate \cdot N_0 & \quad \text{if rate parameter specified} \end{cases} ]

Exponential decay function `synarc.xdecay( rel[, rate] )`::
The arc value at elapse time _t_ is computed as:
+
latexmath:[ N_t = N_0 e^{-\lambda t} ]
+
latexmath:[ \lambda = \begin{cases} \frac{ln\left( 10^4 \right)}{t_{end} - t_0} & \quad \text{if no rate parameter} \\ rate \cdot \ln\left( 10^4 \right) & \quad \text{if rate parameter specified} \end{cases} ]

[NOTE]
====
When exponential decay constant  &#955; is derived from the arc's lifespan it is chosen such that _N~t~_ decays to 0.01% of the arc's initial value _N~0~_ at _t~1~_ = _t~end~_. This also implies a decay to 10% of initial value 1/4 through the lifespan, 1% of initial value 1/2 through the lifespan, and 0.1% of initial value 3/4 through the lifespan.
====

[[synarc_decay_collect]]
==== Returning decayed arc value in search result 

Search results include arcs that are collected during graph traversal. Arcs are collected into the result set in accordance with the  <<../graph/graphQuery.adoc#graphneighborhood_parameters, query `collect` parameter>> or the <<../vertex/vertexFilter.adoc#vertexfiltertraversecollect, vertex condition `'traverse': { 'collect': ... }` clause>>. Values computed in evaluator expressions can also be collected but must be done using <<collectorstagingfunctions, `collect()` or `collectif()` functions>>.

TIP: When collecting search results using evaluator expressions it is often desirable to collect using the <<../constants/collectConstants.adoc#C_SCAN, `C_SCAN` mode>>. This mode disables automatic collection of traversed arcs and ensures traversal of the entire neighborhood.

To collect an arc with a decayed value we pass the result of `synarc.decay()` or `synarc.xdecay()` to `collect()`.

[[synarc_decay_collect_example]]
===== Example: Collect decayed arc value
[source, python]
----
collect( synarc.decay( 'score' ) )
----

The function `collect( _value_ )` works by adding the currently traversed arc to the search result with the arc's value overridden by _value_, which in the above example is the decayed value. Note that `collect( _value_ )` does nothing unless _value_ is numeric and therefore ignores the _null_ return value from `synarc.decay()` during traversal (i.e. when arc components needed to compute the decayed value are captured.) Only the post-traversal evaluation step results in a numeric value and this is when the arc is collected.

The arc collected this way will appear in the result as:

`-[ 'score', M_FLT, N~t~ ]\->`

[[synarc_decay_example]]
==== Complete example

[source, python]
----
from pyvgx import *

# Build a small graph
g = Graph( "decaytest" )
g.Connect( "A", ("score", M_FLT, 100.0), "B", lifespan=3600 )
g.Connect( "A", ("score", M_FLT, 50.0),  "C", lifespan=3600 )
g.Connect( "A", ("score", M_FLT, 25.0),  "D", lifespan=86400 )

# Wait a few seconds...

# Query with LINEAR DECAY
g.Neighborhood( id      = "A",
                collect = C_SCAN,
                fields  = F_AARC,
                filter  = "collect( synarc.decay( 'score' ) )"
)
# [
#   ( A )-[ score <M_FLT> 99.8160 ]->( B ),
#   ( A )-[ score <M_FLT> 49.9080 ]->( C ),
#   ( A )-[ score <M_FLT> 24.9981 ]->( D )
# ]

# Wait some more...

# Query with EXPONENTIAL DECAY
g.Neighborhood( id      = "A",
                collect = C_SCAN,
                fields  = F_AARC,
                filter  = "collect( synarc.xdecay( 'score' ) )"
)
# [
#   ( A )-[ score <M_FLT> 43.6150 ]->( B ),
#   ( A )-[ score <M_FLT> 21.8075 ]->( C ),
#   ( A )-[ score <M_FLT> 24.1504 ]->( D )
# ]

# Query with EXPONENTIAL DECAY and override decay rate to emulate
# 15 minute lifespan of all arcs.
g.Neighborhood( id      = "A",
                collect = C_SCAN,
                fields  = F_AARC,
                filter  = "collect( synarc.xdecay( 'score', 1/900 ) )"
)
# [
#   ( A )-[ score <M_FLT> 0.0552536 ]->( B ),
#   ( A )-[ score <M_FLT> 0.0276268 ]->( C ),
#   ( A )-[ score <M_FLT> 0.0138134 ]->( D )
# ]

----


___

[.float-group]
--
[.left]
//icon:arrow-circle-left[size=2x, link=selectEvaluator.adoc#, title="Select Evaluator"]
<<selectEvaluator.adoc#, icon:arrow-circle-left[size=2x, title="Select Evaluator"]>>
//icon:arrow-circle-up[size=2x, link=../reference.adoc#, title="pyvgx Reference"]
<<../reference.adoc#, icon:arrow-circle-up[size=2x, title="pyvgx Reference"]>>
//icon:arrow-circle-right[size=2x, link=selectEvaluator.adoc#, title="Select Evaluator"]
<<selectEvaluator.adoc#, icon:arrow-circle-right[size=2x, title="Select Evaluator"]>>
// cspell:ignore backtotop
include::../common/_backtotop.adoc[]
--

[[theend]]
//image::pyvgx.png[PYVGX,120,120,align="center",link="../reference.adoc#"]
[.text-center]
<<../reference.adoc#, image:pyvgx.png[PYVGX, 120, 120, align="center"]>>
