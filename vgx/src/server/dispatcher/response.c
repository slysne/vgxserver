/*######################################################################
 *#
 *# response.c
 *#
 *#
 *######################################################################
 */


#include "_vxserver_dispatcher.h"


/* exception module */
SET_EXCEPTION_MODULE( COMLIB_MSG_MOD_VGX_GRAPH );



/*******************************************************************//**
 *
 *
 ***********************************************************************
 */
DLL_HIDDEN int vgx_server_dispatcher_response__handle( vgx_VGXServer_t *server, vgx_VGXServerDispatcherChannel_t *channel ) {
  int ret = 0;

  int sz = 0;
  const char *line = NULL;
  const char *errmsg = NULL;

  vgx_VGXServerClient_t *client = channel->parent.dynamic.client;
  vgx_VGXServerResponse_t *ch_response = channel->response;
  vgx_StreamBuffer_t *rbuf = ch_response->buffers.content;
  vgx_HTTPResponseHeaderField field;

  switch( CHANNEL_STATE_NOERROR( channel ) ) {

  // ------------------------------
  // Response line
  // e.g. "HTTP/1.1 200 OK"
  // ------------------------------
  case VGXSERVER_CHANNEL_STATE__RECV_INITIAL:
    // Return a complete line
    if( (line = iStreamBuffer.GetLinearLine( rbuf, ch_response->content_offset, HTTP_LINE_MAX, &sz )) == NULL ) {
      goto incomplete_line;
    }

    // Parse initial response line
    if( vgx_server_parser__parse_response_initial_line( line, ch_response ) < 0 ) {
      goto bad_response_line;
    }

    // Adjust offset for next line
    ch_response->content_offset += sz;

    // Headers next
    CHANNEL_UPDATE_STATE( channel, VGXSERVER_CHANNEL_STATE__RECV_HEADERS );

  // ------------------------------
  // Header line(s)
  // e.g. "Content-Length: 1234"
  // ------------------------------
  case VGXSERVER_CHANNEL_STATE__RECV_HEADERS:
    do {
      // Return a complete line
      if( (line = iStreamBuffer.GetLinearLine( rbuf, ch_response->content_offset, HTTP_LINE_MAX, &sz )) == NULL ) {
        goto incomplete_line;
      }

      // Parse response header line e.g. "Content-Length: 123"
      field = vgx_server_parser__parse_response_header_line( line, ch_response );

      // Adjust offset for next line
      ch_response->content_offset += sz;

    } while( field != HTTP_RESPONSE_HEADER__END_OF_HEADERS );

    // Empty \r\n line reached
    CHANNEL_UPDATE_STATE( channel, VGXSERVER_CHANNEL_STATE__RECV_CONTENT );

  // ------------------------------
  // Response content
  //
  // ------------------------------
  case VGXSERVER_CHANNEL_STATE__RECV_CONTENT:
    // Get the number of bytes still needed from the socket to complete the response
    if( __vgxserver_response_unfilled_content_buffer( ch_response ) > 0 ) {
      goto incomplete_content;
    }

    CHANNEL_UPDATE_STATE( channel, VGXSERVER_CHANNEL_STATE__COMPLETE );

    // Transient error for this partial, immediate exception to retry
    switch( ch_response->status.code ) {
    case HTTP_STATUS__TooManyRequests:
      /* FALLTHRU */
    case HTTP_STATUS__ServiceUnavailable:
      goto response_error;
    default:
      break;
    }

    // Channel has served its purpose and will be returned to the pool.
    // (Client holds on to the response instance.)
    vgx_server_dispatcher_channel__return( channel );

    // TODO: We need to monitor responses that never complete.
    //       If a response does not complete within a max timeout
    //       we abandon the entire request (or return a partial result)

    // All Channels are complete
    if( vgx_server_dispatcher_client__no_channels( client ) ) {

      // Remove Client from dispatcher I/O chain
      vgx_server_dispatcher_matrix__client_yank_matrix( &server->matrix, client );
      CLIENT_STATE__UPDATE( client, VGXSERVER_CLIENT_STATE__DISPATCH_COMPLETE );

      // Mark client's response as being generated by backend engine(s)
      client->response.info.execution.dispatch = 1;

      // Dispatch next in line client if backlog exists
      vgx_server_dispatcher_dispatch__apply_backlog( server );

      // Multiple Channels (Merge required) OR Pre/Post Processor(s): move Client to Executor
      if( CHANNEL_IS_PARTIAL( channel ) || CLIENT_HAS_ANY_PROCESSOR( client ) ) {
        ret = vgx_server_dispatch__stage_executor( server, client );
      }
      // Passthru: No merge required, move Client directly to front
      // NOTE: The response from back end is relayed verbatim to the 
      //       font client, which means we are not including dispatcher's
      //       execution time overhead in the response!
      else {
        ret = vgx_server_dispatch__bypass_to_front( server, client );
      }
    }

    // Channel complete, other channel(s) remain
    goto complete;

  // ------------------------------
  // State machine error
  //
  // ------------------------------
  default:
    goto response_error;
  }


complete:
  CHANNEL_BLOCK( server, channel );
  return 0;

incomplete_line:
  // Protect against overlong URI
  if( (iStreamBuffer.Size( rbuf ) - ch_response->content_offset) >= HTTP_LINE_MAX ) {
    HTTPStatus too_long = HTTP_STATUS__URITooLong;
    return vgx_server_dispatcher_io__handle_exception( server, channel, too_long, NULL );
  }

incomplete_content:
  CHANNEL_BLOCK( server, channel );
  return 0;

bad_response_line:
  // TODO: Handle
  goto error;

response_error:
  vgx_server_dispatcher_io__handle_exception( server, channel, ch_response->status.code, errmsg );
  goto error;

error:
  CHANNEL_BLOCK( server, channel );
  return -1;


}
