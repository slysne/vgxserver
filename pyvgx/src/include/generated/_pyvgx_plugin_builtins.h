/******************************************************************************
 * 
 * VGX Server
 * Distributed engine for plugin-based graph and vector search
 * 
 * Module:  pyvgx
 * File:    _pyvgx_plugin_builtins.h
 * Author:  Stian Lysne <...>
 * 
 * Copyright Â© 2025 Rakuten, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 *****************************************************************************/

#ifndef _PYVGX_PLUGIN_BUILTINS_H
#define _PYVGX_PLUGIN_BUILTINS_H



static const char *PYVGX_BUILTIN__ADMIN_Attach[] = {
    "# ADMIN_Attach"
    "import pyvgx",
    "def sysplugin__ADMIN_Attach( request:pyvgx.PluginRequest, headers:dict, authtoken:str, uri:str ):",
    "    \"\"\"",
    "    ADMIN: Attach a subscriber",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.op.Attach( uri )",
    "        return { 'subscriber':uri, 'action':'attached' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_Attach )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_Bind[] = {
    "# ADMIN_Bind"
    "import pyvgx",
    "def sysplugin__ADMIN_Bind( request:pyvgx.PluginRequest, headers:dict, authtoken:str, port:int, durable:int=0 ):",
    "    \"\"\"",
    "    ADMIN: System bind",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        nRO = pyvgx.system.CountReadonly()",
    "        if nRO != 0:",
    "            raise Exception( \"Cannot bind with {} readonly graph(s)\".format( nRO ) )",
    "        pyvgx.op.Bind( port=port, durable=durable )",
    "        return { 'action': 'bind', 'port':port, 'durable':durable }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_Bind )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_CancelSync[] = {
    "# ADMIN_CancelSync"
    "import pyvgx",
    "def sysplugin__ADMIN_CancelSync( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Cancel Synchronize subscribers",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    try:",
    "        sync_stopped = pyvgx.system.CancelSync()",
    "        if sync_stopped > 0:",
    "            status = \"sync stopped\"",
    "        elif sync_stopped == 0:",
    "            status = \"sync not running\"",
    "        else:",
    "            status = \"failed to stop\"",
    "        return { 'action': 'cancel_sync', 'status': status }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        pass",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_CancelSync )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_ClearReadonly[] = {
    "# ADMIN_ClearReadonly"
    "import pyvgx",
    "def sysplugin__ADMIN_ClearReadonly( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Clear system readonly",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.system.ClearReadonly()",
    "        return { 'action': 'system mutable' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_ClearReadonly )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_Console[] = {
    "# ADMIN_Console"
    "import pyvgx",
    "import re",
    "sysplugin__RemotePyvgxMethods   = dict([('pyvgx.{}'.format(x),  getattr(pyvgx,        x)) for x in dir(pyvgx)        if not x.startswith('__') and callable(getattr(pyvgx,        x ))])",
    "sysplugin__RemoteGraphMethods   = dict([('Graph.{}'.format(x),  getattr(pyvgx.Graph,  x)) for x in dir(pyvgx.Graph)  if not x.startswith('__') and callable(getattr(pyvgx.Graph,  x ))])",
    "sysplugin__RemoteVertexMethods  = dict([('Vertex.{}'.format(x), getattr(pyvgx.Vertex, x)) for x in dir(pyvgx.Vertex) if not x.startswith('__') and callable(getattr(pyvgx.Vertex, x ))])",
    "sysplugin__RemoteOpMethods      = dict([('op.{}'.format(x),     getattr(pyvgx.op,     x)) for x in dir(pyvgx.op)     if not x.startswith('__') and callable(getattr(pyvgx.op,     x ))])",
    "sysplugin__RemoteSystemMethods  = dict([('system.{}'.format(x), getattr(pyvgx.system, x)) for x in dir(pyvgx.system) if not x.startswith('__') and callable(getattr(pyvgx.system, x ))])",
    "sysplugin__RemoteVertexWritableMethods = set([",
    "    'Vertex.SetRank',",
    "    'Vertex.SetProperty',",
    "    'Vertex.IncProperty',",
    "    'Vertex.RemoveProperty',",
    "    'Vertex.SetProperties',",
    "    'Vertex.RemoveProperties',",
    "    'Vertex.SetVector',",
    "    'Vertex.RemoveVector',",
    "    'Vertex.SetExpiration',",
    "    'Vertex.ClearExpiration',",
    "    'Vertex.SetType'",
    "])",
    "sysplugin__RemoteForbiddenMethods = {",
    "    'pyvgx': ( sysplugin__RemotePyvgxMethods, [",
    "        'threadid',         # no remote value",
    "        'threadlabel',      # no remote value",
    "        'selftest',         # breaks system",
    "        'selftest_all',     # breaks system",
    "        'enable_selftest',  # breaks system",
    "        'SetOutputStream',  # may corrupt logs",
    "        'AutoArcTimestamps' # may have unintended consequences",
    "    ]),",
    "    'Graph': ( sysplugin__RemoteGraphMethods, [",
    "        'Memory',                   # no remote value",
    "        'NewArcsQuery',             # no remote value",
    "        'NewVerticesQuery',         # no remote value",
    "        'NewNeighborhoodQuery',     # no remote value",
    "        'NewAdjacencyQuery',        # no remote value",
    "        'NewAggregatorQuery',       # no remote value",
    "        'Search',                   # stdout",
    "        'Erase',                    # breaks system",
    "        'ShowVertex',               # stdout",
    "        'ShowOpenVertices',         # stdout",
    "        'DebugPrintAllocators',     # stdout",
    "        'DebugDumpGraph',           # stdout",
    "        'Lock'                      # may have unintended consequences",
    "    ]),",
    "    'Vertex': ( sysplugin__RemoteVertexMethods, [",
    "        'Writable',     # no remote value",
    "        'Readable',     # no remote value",
    "        'Readonly',     # no remote value",
    "        'Close',        # no remote value",
    "        'Escalate',     # no remote value",
    "        'Relax',        # no remote value",
    "        'Commit',       # no remote value",
    "        'DebugVector',  # stdout",
    "        'Debug'         # stdout",
    "    ]),",
    "    'op': ( sysplugin__RemoteOpMethods, [",
    "        'URI',              # no remote value",
    "        'SetDefaultURIs',   # no remote value",
    "        'GetDefaultURIs'    # no remote value",
    "    ]),",
    "    'system': ( sysplugin__RemoteSystemMethods, [",
    "        'IsInitialized',    # no remote value",
    "        'Initialize',       # no remote value",
    "        'Unload',           # breaks system",
    "        'DeleteGraph',      # breaks system",
    "        'StartHTTP',        # may break system",
    "        'StopHTTP',         # breaks system",
    "        'AddPlugin',        # security risk",
    "        'RemovePlugin',     # breaks system",
    "        'RunServer'         # may break system",
    "    ])",
    "}",
    "for api, methods in sysplugin__RemoteForbiddenMethods.items():",
    "    method_dict, method_names = methods",
    "    for name in method_names:",
    "        method_dict.pop( \"%s.%s\" % (api, name) )",
    "sysplugin__RemoteStaticMethods = {}",
    "sysplugin__RemoteStaticMethods.update( sysplugin__RemotePyvgxMethods )",
    "sysplugin__RemoteStaticMethods.update( sysplugin__RemoteOpMethods )",
    "sysplugin__RemoteStaticMethods.update( sysplugin__RemoteSystemMethods )",
    "sysplugin__RemoteAllMethods = {}",
    "sysplugin__RemoteAllMethods.update( sysplugin__RemoteStaticMethods )",
    "sysplugin__RemoteAllMethods.update( sysplugin__RemoteGraphMethods )",
    "sysplugin__RemoteAllMethods.update( sysplugin__RemoteVertexMethods )",
    "def sysplugin__ParseRemoteCommand( command, recursion=0 ):",
    "    m = re.match( r'^(\\S+)\\s*:\\s*(.*)$', command.replace( '\\n', ' ' ) )",
    "    if m:",
    "        return m.group(1), sysplugin__VALIDATOR.SafeEval( m.group(2) )",
    "    elif recursion == 0:",
    "        if \"=\" in command:",
    "            tmp = re.sub( r'(\\w+)\\s*=', lambda m:'\"%s\": ' % m.group(1), command )",
    "            conv = re.sub( r\"^(\\S+)\\s*\\((.*)(\\)\\s*)$\", r\"\\1: {\\2}\", tmp )",
    "        else:",
    "            conv = re.sub( r'^(\\S+)\\s*\\((.*)(\\)\\s*)$', r'\\1: [\\2]', command )",
    "        return sysplugin__ParseRemoteCommand( conv, 1 )",
    "    else:",
    "        raise Exception( \"Invalid command\" )",
    "def sysplugin__RemoteCallVertexMethod( g, cmd, params ):",
    "    V = None",
    "    try:",
    "        vcall = sysplugin__RemoteVertexMethods.get( cmd )",
    "        if cmd in sysplugin__RemoteVertexWritableMethods:",
    "            mode = 'w'",
    "        else:",
    "            mode = 'r'",
    "        if type(params) is dict:",
    "            V = g.OpenVertex( id=params.pop( 'id', None ), mode=mode, timeout=params.pop( 'timeout', 0 ) )",
    "            return vcall( V, **params )",
    "        else:",
    "            id = params.pop(0)",
    "            V = g.OpenVertex( id=id, mode=mode, timeout=100 )",
    "            return vcall( V, *params )",
    "    finally:",
    "        if V is not None:",
    "            g.CloseVertex( V )",
    "def sysplugin__ADMIN_Console( request:pyvgx.PluginRequest, headers:dict, authtoken:str, graph:str, content:str ):",
    "    \"\"\"",
    "    ADMIN: Console access to pyvgx API",
    "    \"\"\"",
    "    if re.search( r\"^\\s*vgxadmin\", content ):",
    "        try:",
    "            sysplugin__LogAdminOperation( headers, opdata=content.strip() )",
    "            args = content.split()[1:]",
    "            result = pyvgx.VGXAdmin.Run( arguments=args, program=None, print_to_stdout=False )",
    "        except Exception as err:",
    "            result = str(err)",
    "        return { 'action': 'vgxadmin', 'result': result }",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    g, close = sysplugin__GetGraphObject( graph )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.LogWarning( \"ADMIN_Console: graph=%s action=%s\" % (graph, content) )",
    "        lines = [line.strip().removesuffix(\";\") for line in re.split( r';\\s*\\n', content ) if line.strip()]",
    "        actions = []",
    "        result = []",
    "        for line in lines:",
    "            cmd, params = sysplugin__ParseRemoteCommand( line )",
    "            ret = None",
    "            while True:",
    "                gcall = sysplugin__RemoteGraphMethods.get( cmd )",
    "                if callable( gcall ):",
    "                    if type(params) is dict:",
    "                        ret = gcall( g, **params )",
    "                    else:",
    "                        ret = gcall( g, *params )",
    "                    break",
    "                if cmd in sysplugin__RemoteVertexMethods:",
    "                    ret = sysplugin__RemoteCallVertexMethod( g, cmd, params )",
    "                    break",
    "                scall = sysplugin__RemoteStaticMethods.get( cmd )",
    "                if callable( scall ):",
    "                    if type(params) is dict:",
    "                        ret = scall( **params )",
    "                    else:",
    "                        ret = scall( *params )",
    "                    break",
    "                if cmd == \"dir\":",
    "                    ret = {",
    "                        \"Graph\":   sorted( sysplugin__RemoteGraphMethods.keys() ),",
    "                        \"Vertex\":  sorted( sysplugin__RemoteVertexMethods.keys() ),",
    "                        \"op\":      sorted( sysplugin__RemoteOpMethods.keys() ),",
    "                        \"system\":  sorted( sysplugin__RemoteSystemMethods.keys() ),",
    "                        \"pyvgx\":   sorted( sysplugin__RemotePyvgxMethods.keys() )",
    "                    }",
    "                    break",
    "                if cmd == \"python\":",
    "                    ret = params",
    "                    break",
    "                raise Exception( \"Unknown command: %s\" % cmd )",
    "            actions.append( cmd )",
    "            result.append( ret )",
    "        return { 'action': actions, 'result': result }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "        if close:",
    "            g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_Console )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_Detach[] = {
    "# ADMIN_Detach"
    "import pyvgx",
    "def sysplugin__ADMIN_Detach( request:pyvgx.PluginRequest, headers:dict, authtoken:str, uri:str ):",
    "    \"\"\"",
    "    ADMIN: Detach a subscriber",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    TxInputSuspended = False",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        TxInputSuspended = pyvgx.op.SuspendTxInput();",
    "        detached = pyvgx.op.Detach( uri, force=True )",
    "        if detached < 1:",
    "            raise Exception( \"Cannot detach subscriber (input server running?)\" )",
    "        return { 'subscriber':uri, 'action':'detached' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "        if TxInputSuspended:",
    "            pyvgx.op.ResumeTxInput()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_Detach )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_DetachAll[] = {
    "# ADMIN_DetachAll"
    "import pyvgx",
    "def sysplugin__ADMIN_DetachAll( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Detach all subscribers",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.op.Detach( uri=None, force=True )",
    "        return { 'subscriber':'all', 'action':'detached' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_DetachAll )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_GetAuthToken[] = {
    "# ADMIN_GetAuthToken"
    "import pyvgx",
    "def sysplugin__ADMIN_GetAuthToken( request:pyvgx.PluginRequest, headers:dict ):",
    "    \"\"\"",
    "    ADMIN: Get a new token to allow one admin operation",
    "    \"\"\"",
    "    client_uri = headers.get( 'X-Vgx-Builtin-Client' )",
    "    token, t0, tx = sysplugin__GenerateNextAuthToken( client_uri )",
    "    return {",
    "        \"authtoken\" : token,",
    "        \"t0\"        : t0,",
    "        \"tx\"        : tx",
    "    }",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_GetAuthToken )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_Persist[] = {
    "# ADMIN_Persist"
    "import pyvgx",
    "import threading",
    "import time",
    "def sysplugin__ADMIN_Persist( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Create local snapshot",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    progress = []",
    "    def perform():",
    "        len(progress)",
    "        try:",
    "            pyvgx.system.Persist( timeout=5000, force=True )",
    "            progress.append( (True, None) )",
    "        except Exception as perr:",
    "            progress.append( (False, perr) )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        Saver = threading.Thread( target=perform )",
    "        Saver.start()",
    "        t0 = time.time()",
    "        while len( progress ) == 0 and time.time() - t0 < 6.0:",
    "            time.sleep( 1 )",
    "        if len( progress ) > 0:",
    "            if progress[0][0] == False:",
    "                status = str( progress[0][1] )",
    "            else:",
    "                status = \"complete\"",
    "        else:",
    "            status = \"in progress\"",
    "        return { 'action': 'persist', 'status': status }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_Persist )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_ReloadPlugins[] = {
    "# ADMIN_ReloadPlugins"
    "import pyvgx",
    "import json",
    "def sysplugin__ADMIN_ReloadPlugins( request:pyvgx.PluginRequest, headers:dict, authtoken:str, content:json ):",
    "    \"\"\"",
    "    ADMIN: Reload Plugins",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        if content is not None:",
    "            if type( content ) is not list:",
    "                raise TypeError( \"content must be list of dicts\" )",
    "            for plugin_def in content:",
    "                if type( plugin_def ) is not dict:",
    "                    raise TypeError( \"content must be list of dicts\" )",
    "            if len( content ) == 0:",
    "                content = None",
    "        added = pyvgx.VGXInstance.LoadPlugins( plugins=content )",
    "        return { 'action': 'plugins_reloaded', 'result': added }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_ReloadPlugins )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_ResetMetrics[] = {
    "# ADMIN_ResetMetrics"
    "import pyvgx",
    "def sysplugin__ADMIN_ResetMetrics( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Reset HTTP Server Metrics",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.system.ResetMetrics()",
    "        return { 'action': 'metrics_reset' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_ResetMetrics )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_RestartHTTP[] = {
    "# ADMIN_RestartHTTP"
    "import pyvgx",
    "import threading",
    "import time",
    "def sysplugin__ADMIN_RestartHTTP( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Restart HTTP Server",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    progress = []",
    "    def perform( ident, current ):",
    "        len( progress )",
    "        was_serving = 0",
    "        try:",
    "            descriptor = pyvgx.Descriptor( sysplugin__GetSystemDescriptor() )",
    "            instance = descriptor.Get( ident )",
    "            instance.HC()",
    "            was_serving = instance.Status()['request']['serving']",
    "            pyvgx.system.ServiceInHTTP( 0 )",
    "            deadline = time.time() + 30",
    "            while time.time() < deadline:",
    "                status = instance.Status()",
    "                active = status['request']['working'] + status['request']['waiting']",
    "                if active > 0:",
    "                    time.sleep(1)",
    "                else:",
    "                    break",
    "            if time.time() > deadline:",
    "                raise Exception( \"Timeout due to ongoing activity\" )",
    "            progress.append( (True, None) )",
    "            time.sleep( 2.0 )",
    "            pyvgx.system.StopHTTP()",
    "            time.sleep(1)",
    "            port = current['port']",
    "            ip = current['ip']",
    "            prefix = current['prefix']",
    "            for cfdispatcher in [instance.cfdispatcher, current['dispatcher']]:",
    "                try:",
    "                    pyvgx.system.StartHTTP( port, ip=ip, prefix=prefix, servicein=0, dispatcher=cfdispatcher )",
    "                    for n in range(5):",
    "                        try:",
    "                            instance.HC()",
    "                            instance.Status()",
    "                            break",
    "                        except:",
    "                            time.sleep(1)",
    "                    break",
    "                except Exception as ex:",
    "                    time.sleep(2)",
    "        except Exception as perr:",
    "            progress.append( (False, perr) )",
    "        finally:",
    "            if was_serving:",
    "                try:",
    "                    pyvgx.system.ServiceInHTTP(1)",
    "                except:",
    "                    pass",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        ident = sysplugin__GetSystemIdent()",
    "        if ident is None:",
    "            raise TypeError( \"System identifier missing, operation cannot be completed\" )",
    "        current = {",
    "            'port':  pyvgx.system.ServerPorts()['base'],",
    "            'ip': pyvgx.system.ServerAdminIP(),",
    "            'prefix': pyvgx.system.ServerPrefix(),",
    "            'dispatcher': pyvgx.system.DispatcherConfig()",
    "        }",
    "        Restarter = threading.Thread( target=perform, args=(ident, current)  )",
    "        Restarter.start()",
    "        status = 'unknown'",
    "        deadline = time.time() + 30",
    "        while len( progress ) == 0 and time.time() < deadline:",
    "            time.sleep(0.1)",
    "        if len( progress ) > 0:",
    "            if progress[0][0] is True:",
    "                status = 'in progress'",
    "            else:",
    "                status = progress[0][1]",
    "        else:",
    "            status = \"timeout\"",
    "        return { 'action': 'restart_http', 'status': status }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_RestartHTTP )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_ResumeEvents[] = {
    "# ADMIN_ResumeEvents"
    "import pyvgx",
    "def sysplugin__ADMIN_ResumeEvents( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Resume TTL",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.system.ResumeEvents()",
    "        return { 'action': 'events_resumed' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_ResumeEvents )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_ResumeTxInput[] = {
    "# ADMIN_ResumeTxInput"
    "import pyvgx",
    "def sysplugin__ADMIN_ResumeTxInput( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Resume Transaction Input",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        nRO = pyvgx.system.CountReadonly()",
    "        if nRO != 0:",
    "            raise Exception( \"Cannot enable transaction input with {} readonly graph(s)\".format( nRO ) )",
    "        pyvgx.op.ResumeTxInput()",
    "        return { 'action': 'tx_input_resumed' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_ResumeTxInput )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_ResumeTxOutput[] = {
    "# ADMIN_ResumeTxOutput"
    "import pyvgx",
    "def sysplugin__ADMIN_ResumeTxOutput( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Resume Transaction Output",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.op.ResumeTxOutput()",
    "        return { 'action': 'tx_output_resumed' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_ResumeTxOutput )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_ServiceIn[] = {
    "# ADMIN_ServiceIn"
    "import pyvgx",
    "def sysplugin__ADMIN_ServiceIn( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: HTTP Service In",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.system.ServiceInHTTP()",
    "        return { 'action': 'service_in' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_ServiceIn )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_ServiceOut[] = {
    "# ADMIN_ServiceOut"
    "import pyvgx",
    "def sysplugin__ADMIN_ServiceOut( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: HTTP Service Out",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.system.ServiceInHTTP( False )",
    "        return { 'action': 'service_out' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_ServiceOut )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_SetReadonly[] = {
    "# ADMIN_SetReadonly"
    "import pyvgx",
    "def sysplugin__ADMIN_SetReadonly( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Set system readonly",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.op.SuspendTxInput()",
    "        pyvgx.system.SetReadonly()",
    "        return { 'action': 'system readonly' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_SetReadonly )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_Shutdown[] = {
    "# ADMIN_Shutdown"
    "import pyvgx",
    "import threading",
    "import time",
    "import sys",
    "import os",
    "import signal",
    "__ADMIN_Shutdown__Undertaker = None",
    "def __ADMIN_Shutdown__shutdown( persist=False ):",
    "    pyvgx.LogInfo( \"Final shutdown initiated\" )",
    "    time.sleep(2)",
    "    if persist:",
    "        pyvgx.LogInfo( \"Shutdown persist\" )",
    "        try:",
    "            pyvgx.system.Persist( force=True, timeout=30000 )",
    "            time.sleep(2)",
    "        except Exception as err:",
    "            pyvgx.LogError( \"Persist error {}\".format(err) )",
    "    pyvgx.LogInfo( \"Stopping HTTP Server\" )",
    "    try:",
    "        pyvgx.system.StopHTTP()",
    "    except:",
    "        pass",
    "    pyvgx.LogInfo( \"Unloading\" )",
    "    try:",
    "        pyvgx.system.Unload()",
    "    except:",
    "        pass",
    "    for n in range(3):",
    "        pyvgx.LogInfo( \"SIGTERM in {}...\".format(3-n) )",
    "        time.sleep(1)",
    "    pyvgx.LogInfo( \"SIGTERM\" )",
    "    os.kill( os.getpid(), signal.SIGTERM )",
    "def sysplugin__ADMIN_Shutdown( request:pyvgx.PluginRequest, headers:dict, authtoken:str, authshutdown:str, persist:int=0 ):",
    "    \"\"\"",
    "    ADMIN: Shutdown",
    "    \"\"\"",
    "    global __ADMIN_Shutdown__Undertaker",
    "    if authshutdown != sysplugin__GetPreviousAuthToken():",
    "        raise Exception( \"Invalid token\" )",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    progress = []",
    "    def prepare():",
    "        pyvgx.LogInfo( \"Shutdown initiated\" )",
    "        err = []",
    "        try:",
    "            pyvgx.system.ServiceInHTTP( service_in=False )",
    "        except Exception as ex:",
    "            err.append( ex )",
    "        try:",
    "            pyvgx.op.Detach( uri=None, force=True )",
    "        except Exception as ex:",
    "            err.append( ex )",
    "        try:",
    "            pyvgx.op.Unbind()",
    "        except Exception as ex:",
    "            err.append( ex )",
    "        if err:",
    "            progress.append( (False, err) )",
    "        else:",
    "            progress.append( (True, None) )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.LogInfo( \"Received remote shutdown command\" )",
    "        Preparer = threading.Thread( target=prepare )",
    "        Preparer.start()",
    "        t0 = time.time()",
    "        while len( progress ) == 0 and time.time() - t0 < 60.0:",
    "            time.sleep( 1 )",
    "        if len( progress ) > 0:",
    "            ok, err = progress[0]",
    "            if ok:",
    "                status = \"going offline\"",
    "            else:",
    "                status = str(err)",
    "        else:",
    "            status = \"in progress\"",
    "        pyvgx.LogInfo( \"Staging final shutdown phase\" )",
    "        do_persist = True if persist > 0 else False",
    "        __ADMIN_Shutdown__Undertaker = threading.Thread( target=__ADMIN_Shutdown__shutdown, args=(do_persist,) )",
    "        __ADMIN_Shutdown__Undertaker.start()",
    "        return { 'action': 'shutdown', 'status': status }",
    "    except Exception as err:",
    "        pyvgx.LogInfo( \"Shutdown error {}\".format( err ) )",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_Shutdown )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_Subscribe[] = {
    "# ADMIN_Subscribe"
    "import pyvgx",
    "import re",
    "def sysplugin__ADMIN_Subscribe( request:pyvgx.PluginRequest, headers:dict, authtoken:str, uri:str, hardsync:int=0, timeout:int=30000):",
    "    \"\"\"",
    "    ADMIN: Subscribe to provider",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        match = re.match( r\"vgx://([^:]+):(\\d+)\", uri )",
    "        if match is None:",
    "            raise Exception( \"Invalid subscriber uri: %s\" % uri )",
    "        host = match.group(1)",
    "        port = int( match.group(2) )",
    "        pyvgx.op.Subscribe( address=(host, port), hardsync=hardsync, timeout=timeout )",
    "        return { 'action': 'subscribed' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_Subscribe )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_SuspendEvents[] = {
    "# ADMIN_SuspendEvents"
    "import pyvgx",
    "def sysplugin__ADMIN_SuspendEvents( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Suspend TTL",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.system.SuspendEvents()",
    "        return { 'action': 'events_suspended' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_SuspendEvents )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_SuspendTxInput[] = {
    "# ADMIN_SuspendTxInput"
    "import pyvgx",
    "def sysplugin__ADMIN_SuspendTxInput( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Suspend Transaction Input",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.op.SuspendTxInput()",
    "        return { 'action': 'tx_input_suspended' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_SuspendTxInput )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_SuspendTxOutput[] = {
    "# ADMIN_SuspendTxOutput"
    "import pyvgx",
    "def sysplugin__ADMIN_SuspendTxOutput( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Suspend Transaction Output",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.op.SuspendTxOutput()",
    "        return { 'action': 'tx_output_suspended' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_SuspendTxOutput )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_Sync[] = {
    "# ADMIN_Sync"
    "import pyvgx",
    "import threading",
    "import time",
    "import json",
    "def sysplugin__ADMIN_Sync( request:pyvgx.PluginRequest, headers:dict, authtoken:str, mode:str=\"repair\" ):",
    "    \"\"\"",
    "    ADMIN: Synchronize subscribers",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    progress = []",
    "    def perform( mode, SubscribersGoal, SubscribersSync, resumeTxIn ):",
    "        len(progress)",
    "        try:",
    "            if mode == \"repair\":",
    "                __internal__ADMIN_UpdateSubscribersExecute( SubscribersGoal, SubscribersSync, authtoken )",
    "            elif mode == \"hard\":",
    "                pyvgx.system.Sync( hard=True )",
    "            elif mode == \"soft\":",
    "                pyvgx.system.Sync()",
    "            else:",
    "                raise ValueError( \"mode must be 'repair', 'hard', or 'soft' (got '{}')\".format( mode ) )",
    "            progress.append( (True, None) )",
    "        except Exception as perr:",
    "            progress.append( (False, perr) )",
    "        finally:",
    "            if resumeTxIn:",
    "                try:",
    "                    pyvgx.op.ResumeTxInput()",
    "                except:",
    "                    pass",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        nRO = pyvgx.system.CountReadonly()",
    "        if nRO != 0:",
    "            raise Exception( \"Cannot sync while {} graph(s) are readonly\".format( nRO ) )",
    "        TxInputSuspended = pyvgx.op.SuspendTxInput()",
    "        if mode == \"repair\":",
    "            server_ports = pyvgx.system.ServerPorts()",
    "            admin_port = server_ports.get( \"admin\" )",
    "            response, headers = sysplugin__SendAdminRequest( host=\"127.0.0.1\", port=admin_port, path=\"/vgx/peerstat\" )",
    "            dest = []",
    "            for uri, details in response[\"subscribers\"]:",
    "                host = details.get( \"host\" )",
    "                adminport = details.get( \"adminport\" )",
    "                dest.append( \"{}:{}\".format( host, adminport ) )",
    "            goal = {",
    "                'control': { 'repair': True },",
    "                'destinations': dest",
    "            }",
    "            goalJSON = json.dumps( goal )",
    "            SubscribersGoal, SubscribersSync = __internal__ADMIN_UpdateSubscribersGetGoalAndSyncLists( goalJSON )",
    "        else:",
    "            SubscribersGoal, SubscribersSync = (None, None)",
    "        Syncer = threading.Thread( target=perform, args=(mode, SubscribersGoal, SubscribersSync, TxInputSuspended)  )",
    "        Syncer.start()",
    "        t0 = time.time()",
    "        while len( progress ) == 0 and time.time() - t0 < 6.0:",
    "            time.sleep( 1 )",
    "        if len( progress ) > 0:",
    "            if progress[0][0] == False:",
    "                status = str( progress[0][1] )",
    "            else:",
    "                status = \"complete\"",
    "        else:",
    "            status = \"in progress\"",
    "        return { 'action': 'sync', 'mode': mode, 'status': status }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_Sync )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_SystemDescriptor[] = {
    "# ADMIN_SystemDescriptor"
    "import pyvgx",
    "def sysplugin__ADMIN_SystemDescriptor( request:pyvgx.PluginRequest, headers:dict, authtoken:str, content:str ):",
    "    \"\"\"",
    "    ADMIN: Update system descriptor",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        descriptor = json.loads( content )",
    "        sysplugin__SetSystemDescriptor( descriptor )",
    "        return { 'action': 'system descriptor updated' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_SystemDescriptor )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_Throttle[] = {
    "# ADMIN_Throttle"
    "import pyvgx",
    "def sysplugin__ADMIN_Throttle( request:pyvgx.PluginRequest, headers:dict, authtoken:str, rate:float=-1.0, unit:str=\"bytes\" ):",
    "    \"\"\"",
    "    ADMIN: Throttle TX input",
    "    rate : Limit TX input processing to units per second",
    "    unit : bytes, opcodes, operations, transactions",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        if rate < 0.0:",
    "            current_limits = pyvgx.op.Throttle()",
    "        else:",
    "            current_limits = pyvgx.op.Throttle( rate=rate, unit=unit )",
    "        return { 'action': 'throttle', 'limits':current_limits }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_Throttle )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_Truncate[] = {
    "# ADMIN_Truncate"
    "import pyvgx",
    "def sysplugin__ADMIN_Truncate( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Delete all graph data",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        tx_suspended = pyvgx.op.SuspendTxInput()",
    "        pyvgx.op.Detach( uri=None, force=True )",
    "        pyvgx.system.ClearReadonly()",
    "        pyvgx.system.SetReadonly()",
    "        pyvgx.system.ClearReadonly()",
    "        if tx_suspended:",
    "            pyvgx.op.ResumeTxInput()",
    "        G = []",
    "        for name, o_s in pyvgx.system.Registry().items():",
    "            try:",
    "                g = pyvgx.Graph( name )",
    "            except:",
    "                g = pyvgx.system.GetGraph( name )",
    "            G.append( g )",
    "        for g in G:",
    "            g.Truncate()",
    "        return { 'action': 'truncate' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_Truncate )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_Unbind[] = {
    "# ADMIN_Unbind"
    "import pyvgx",
    "def sysplugin__ADMIN_Unbind( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: System unbind",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.op.Unbind()",
    "        return { 'action': 'unbind' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_Unbind )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_Unsubscribe[] = {
    "# ADMIN_Unsubscribe"
    "import pyvgx",
    "def sysplugin__ADMIN_Unsubscribe( request:pyvgx.PluginRequest, headers:dict, authtoken:str ):",
    "    \"\"\"",
    "    ADMIN: Unsubscribe from provider",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        pyvgx.op.Unsubscribe()",
    "        return { 'action': 'unsubscribed' }",
    "    except Exception as err:",
    "        return err",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_Unsubscribe )",
    0
};



static const char *PYVGX_BUILTIN__ADMIN_UpdateSubscribers[] = {
    "# ADMIN_UpdateSubscribers"
    "import pyvgx",
    "import threading",
    "import time",
    "import json",
    "import re",
    "import time",
    "def __internal__ADMIN_UpdateSubscribersExecute( SubscribersGoal, SubscribersSync, authtoken ):",
    "    def PrepareSync():",
    "        \"\"\"",
    "        Enter into local state where sync is possible",
    "        Return True if local TX input becomes suspended here",
    "        \"\"\"",
    "        nRO = pyvgx.system.CountReadonly()",
    "        if nRO != 0:",
    "            raise Exception( \"Cannot update subscribers while {} graph(s) are readonly\".format( nRO ) )",
    "    def PerformSync( SubscribersSync ):",
    "        \"\"\"",
    "        Detach all current subscribers, attach to sync destinations, perform sync, then detach all",
    "        \"\"\"",
    "        pyvgx.op.Detach()",
    "        pyvgx.op.Attach( SubscribersSync )",
    "        pyvgx.system.Sync( hard=True )",
    "        pyvgx.op.Detach()",
    "    def AttachGoal( SubscribersGoal ):",
    "        \"\"\"",
    "        Attach to all subscribers",
    "        \"\"\"",
    "        if set( pyvgx.op.Attached() ) != set( SubscribersGoal ):",
    "            pyvgx.op.Detach()",
    "            pyvgx.op.Attach( SubscribersGoal )",
    "    TxSuspendedHere = False",
    "    SubscribersOriginal = pyvgx.op.Attached()",
    "    actions = {}",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        TxSuspendedHere = True if pyvgx.op.SuspendTxInput() == 1 else False",
    "        if len( SubscribersSync ) > 0:",
    "            PrepareSync()",
    "            PerformSync( SubscribersSync )",
    "        AttachGoal( SubscribersGoal )",
    "        actions['action'] = \"attached\"",
    "        actions['added'] = sorted( SubscribersSync )",
    "        actions['removed'] = sorted( list( set(SubscribersOriginal) - set(SubscribersGoal) ) )",
    "        actions['result'] = sorted( SubscribersGoal )",
    "    except Exception as err:",
    "        if set( pyvgx.op.Attached() ) != set( SubscribersOriginal ):",
    "            pyvgx.op.Detach()",
    "            pyvgx.op.Attach( SubscribersOriginal )",
    "        return err",
    "    finally:",
    "        try:",
    "            if TxSuspendedHere:",
    "                pyvgx.op.ResumeTxInput()",
    "        finally:",
    "            sysplugin__EndAdmin( authtoken )",
    "    return actions",
    "def __internal__ADMIN_UpdateSubscribersGetGoalAndSyncLists( goal, content=\"\" ):",
    "    \"\"\"",
    "    Return two lists: The final goal, and the intermediary sync destinations",
    "    \"\"\"",
    "    def GetDestinations( GoalJSON ):",
    "        \"\"\"",
    "        Parse json and return list of destinations",
    "        \"\"\"",
    "        subscribers = {}",
    "        goal = json.loads( GoalJSON )",
    "        if type( goal ) is dict:",
    "            control = goal.get(\"control\")",
    "            if control is not None and type( control ) is not dict:",
    "                raise TypeError( 'Subscriber goal \"control\" must be dict, got {}'.format( type( control ) ) )",
    "            destinations = goal.get(\"destinations\")",
    "            if destinations is None:",
    "                raise ValueError( 'Subscriber goal missing \"destinations\"' )",
    "        else:",
    "            control = {}",
    "            destinations = goal",
    "        if type(destinations) is not list:",
    "            raise TypeError( \"Subscriber destinations must be list, got {}\".format( type(destinations) ) )",
    "        for dest in destinations:",
    "            m = re.match( r\"([^:]+):(\\d+)\", dest )",
    "            if m is None:",
    "                raise ValueError( \"Invalid subscriber address: {}\".format( dest ) )",
    "            host = m.group(1)",
    "            admin_port = int(m.group(2))",
    "            key = \"{}:{}\".format( host, admin_port )",
    "            if key in subscribers:",
    "                raise ValueError( \"Duplicate destination specified: {}\".format( key ) )",
    "            subscribers[ key ] = ( host, admin_port )",
    "        return (sorted( subscribers.values() ), control)",
    "    def GetHostIP( host, admin_port ):",
    "        \"\"\"",
    "        Contact host and get its self-reported IP address",
    "        \"\"\"",
    "        try:",
    "            ping, headers = sysplugin__SendAdminRequest( host, admin_port, path=\"/vgx/ping\" )",
    "            return ping[\"host\"][\"ip\"]",
    "        except Exception as err:",
    "            raise Exception( \"{}:{}/vgx/ping failed: {}\".format( host, admin_port, err ) )",
    "    def GetSubscriberState( host, admin_port ):",
    "        \"\"\"",
    "        Get TX input service state using host's self-reported IP",
    "        \"\"\"",
    "        try:",
    "            peerstat, headers = sysplugin__SendAdminRequest( host, admin_port, path=\"/vgx/peerstat\" )",
    "            tx_port = int( peerstat.get(\"port\",0) )",
    "            tx_provider = peerstat.get( \"provider\", None )",
    "            return (tx_port, tx_provider)",
    "        except Exception as err:",
    "            raise Exception( \"{}:{}/vgx/peerstat failed: {}\".format( host, admin_port, err ) )",
    "    def DestinationRequiresSync( host, admin_port ):",
    "        \"\"\"",
    "        Return True if destination has different data than local system",
    "        \"\"\"",
    "        response, headers = sysplugin__SendAdminRequest( host, admin_port, path=\"/vgx/graphsum\" )",
    "        try:",
    "            graphsum = response[\"graphsum\"]",
    "            remote_digest = graphsum.get(\"digest\", None)",
    "            local_digest = pyvgx.system.Fingerprint()",
    "            if remote_digest != local_digest:",
    "                return True",
    "            else:",
    "                return False",
    "        except:",
    "            return False",
    "    def IsHostServiceIn( host, admin_port ):",
    "        \"\"\"",
    "        Return True if host is in service-in state",
    "        \"\"\"",
    "        status, headers = sysplugin__SendAdminRequest( host, admin_port, path=\"/vgx/status\" )",
    "        try:",
    "            return False if status[\"request\"][\"serving\"] == 0 else True",
    "        except:",
    "            return True",
    "    def IsHostGraphEmpty( host, admin_port ):",
    "        \"\"\"",
    "        Return True if host has no data",
    "        \"\"\"",
    "        response, headers = sysplugin__SendAdminRequest( host, admin_port, path=\"/vgx/graphsum\" )",
    "        try:",
    "            graphsum = response[\"graphsum\"]",
    "            order = graphsum[\"order\"]",
    "            size = graphsum[\"size\"]",
    "            properties = graphsum[\"properties\"]",
    "            vectors = graphsum[\"vectors\"]",
    "            total = order + size + properties + vectors",
    "            return True if total == 0 else False",
    "        except:",
    "            return False",
    "    def DestinationAllowsSync( host, admin_port ):",
    "        \"\"\"",
    "        Return True if this host can safely be synced.",
    "        \"\"\"",
    "        if IsHostServiceIn( host, admin_port ) is not True:",
    "            return True",
    "        if IsHostGraphEmpty( host, admin_port ) is True:",
    "            return True",
    "        return False",
    "    def SubscriberState( host, admin_port, repair=True, nosync=False ):",
    "        \"\"\"",
    "        Return a prospective subscriber's self reported IP address, tx input port, and sync-flag.",
    "        The sync flag is True if nosync parameter is False, AND:",
    "            * the destination currently has no connected provider and its fingerprint differs from the local host",
    "              - or -",
    "            * the repair flag is True and the destination's fingerprint differs from the local host",
    "        \"\"\"",
    "        host_ip = GetHostIP( host, admin_port )",
    "        tx_port, tx_provider = GetSubscriberState( host_ip, admin_port )",
    "        if tx_port <= 0:",
    "            raise Exception( \"Destination has no TX input service: {}:{}\".format( host, admin_port ) )",
    "        if nosync is True:",
    "            sync = False",
    "        else:",
    "            if repair:",
    "                sync = DestinationRequiresSync( host_ip, admin_port )",
    "            else:",
    "                sync = True if tx_provider is None else False",
    "                if sync is True:",
    "                    sync = DestinationRequiresSync( host_ip, admin_port )",
    "            if sync is True:",
    "                if DestinationAllowsSync( host_ip, admin_port ) is not True:",
    "                    raise Exception( \"Cannot sync to destination {}:{}. Service-out and retry.\".format( host, admin_port ) )",
    "        return (host_ip, tx_port, sync)",
    "    def GetVerifiedGoal( goal ):",
    "        \"\"\"",
    "        Return list of (host, admin_port, tx_port, sync) for all destinations.",
    "        \"\"\"",
    "        subscribers = {}",
    "        destinations, control = GetDestinations( goal )",
    "        for host, admin_port in destinations:",
    "            repair = True if control.get(\"repair\") is True else False",
    "            nosync = True if control.get(\"nosync\") is True else False",
    "            host_ip, tx_port, sync = SubscriberState( host, admin_port, repair, nosync )",
    "            ip_key = \"{}:{}\".format( host_ip, tx_port )",
    "            if ip_key in subscribers:",
    "                raise ValueError( \"Duplicate destination IP detected: {} at {}:{}\".format( ip_key, host, admin_port ) )",
    "            subscribers[ ip_key ] = (host, admin_port, tx_port, sync)",
    "        return sorted( subscribers.values() )",
    "    if content:",
    "        goal = content",
    "    VerifiedGoalQuad = GetVerifiedGoal( goal )",
    "    SubscribersGoal = [\"vgx://{}:{}\".format(host, tx_port) for host, admin_port, tx_port, sync in VerifiedGoalQuad]",
    "    SubscribersSync = [\"vgx://{}:{}\".format(host, tx_port) for host, admin_port, tx_port, sync in VerifiedGoalQuad if sync]",
    "    return (SubscribersGoal, SubscribersSync)",
    "def sysplugin__ADMIN_UpdateSubscribers( request:pyvgx.PluginRequest, headers:dict, authtoken:str, content:str, goal:str=\"[]\" ):",
    "    \"\"\"",
    "    ADMIN: Update Subscribers",
    "    \"\"\"",
    "    sysplugin__AuthorizeAdminOperation( headers, authtoken )",
    "    sysplugin__BeginAdmin( authtoken )",
    "    try:",
    "        SubscribersGoal, SubscribersSync = __internal__ADMIN_UpdateSubscribersGetGoalAndSyncLists( goal, content )",
    "        return __internal__ADMIN_UpdateSubscribersExecute( SubscribersGoal, SubscribersSync, authtoken )",
    "    finally:",
    "        sysplugin__EndAdmin( authtoken )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ADMIN_UpdateSubscribers )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_arcs[] = {
    "# BUILTIN_arcs"
    "import pyvgx",
    "import re",
    "sysplugin__arcs_EXCLUDE = set([\"headers\", \"content\", \"graph\", \"hits\", \"query\", \"arc\", \"sharedmem\"])",
    "def sysplugin__arcs( request:pyvgx.PluginRequest, headers:dict, content:str, graph:str, hits:int=25, query:str=\"\", arc:str=\"\", sharedmem:int=0 ):",
    "    \"\"\"",
    "    Global arcs query",
    "    \"\"\"",
    "    g, close = sysplugin__GetGraphObject( graph )",
    "    try:",
    "        Q = {",
    "          'timeout'   : 5000,",
    "          'hits'   : hits,",
    "          'fields' : pyvgx.F_AARC",
    "        }",
    "        for k,v in request.params.items():",
    "            if k not in sysplugin__arcs_EXCLUDE:",
    "                Q[k] = v",
    "        sysplugin__UpdateQueryDict( Q, query, content )",
    "        if arc:",
    "            if 'condition' in Q and 'arc' not in Q['condition']:",
    "                Q['condition']['arc'] = sysplugin__VALIDATOR.SafeEval( arc )",
    "            elif 'condition' not in Q:",
    "                Q['condition'] = { 'arc': sysplugin__VALIDATOR.SafeEval( arc ) }",
    "        if 'memory' in Q:",
    "            Q['memory'] = sysplugin__GetGraphMemory( g, Q['memory'], sharedmem )",
    "        M = Q.get( 'memory' )",
    "        R = g.Arcs( **Q )",
    "        if M is not None:",
    "            if type(R) is not dict:",
    "                R = {'arcs': R}",
    "            R['memory'] = M.AsList()",
    "        return R",
    "    finally:",
    "        if close:",
    "            g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__arcs )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_connect[] = {
    "# BUILTIN_connect"
    "import pyvgx",
    "import re",
    "def sysplugin__connect( request:pyvgx.PluginRequest, headers:dict, graph:str, initial:str, terminal:str, relationship:str=\"__related__\", modifier:str=\"M_FLT\", value:float=0.0, lifespan:int=-1, timeout:int=5000 ):",
    "    \"\"\"",
    "    Connect two vertices",
    "    \"\"\"",
    "    g, close = sysplugin__GetGraphObject( graph )",
    "    try:",
    "        mod = getattr(pyvgx, modifier)",
    "        r = g.Connect( initial=initial, arc=(relationship,mod,value), terminal=terminal, lifespan=lifespan, timeout=timeout )",
    "        action = \"connected\" if r > 0 else \"updated\"",
    "        return { 'initial':initial, 'terminal':terminal, 'action':action }",
    "    finally:",
    "        if close:",
    "            g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__connect )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_createvertex[] = {
    "# BUILTIN_createvertex"
    "import pyvgx",
    "import re",
    "import json",
    "def sysplugin__createvertex( request:pyvgx.PluginRequest, headers:dict, graph:str, id:str, type:str=\"\", lifespan:int=-1, properties:json={} ):",
    "    \"\"\"",
    "    Create/update vertex",
    "    \"\"\"",
    "    g, close = sysplugin__GetGraphObject( graph )",
    "    try:",
    "        r = g.CreateVertex( id=id, type=type, lifespan=lifespan, properties=properties )",
    "        action = \"created\" if r > 0 else \"updated\"",
    "        return { 'id':id, 'action':action }",
    "    finally:",
    "        if close:",
    "            g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__createvertex )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_deletevertex[] = {
    "# BUILTIN_deletevertex"
    "import pyvgx",
    "import re",
    "def sysplugin__deletevertex( request:pyvgx.PluginRequest, headers:dict, graph:str, id:str ):",
    "    \"\"\"",
    "    Delete vertex",
    "    \"\"\"",
    "    g, close = sysplugin__GetGraphObject( graph )",
    "    try:",
    "        r = g.DeleteVertex( id )",
    "        action = \"deleted\" if r > 0 else None",
    "        return { 'id':id, 'action':action }",
    "    finally:",
    "        if close:",
    "            g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__deletevertex )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_disconnect[] = {
    "# BUILTIN_disconnect"
    "import pyvgx",
    "import re",
    "def sysplugin__disconnect( request:pyvgx.PluginRequest, headers:dict, graph:str, id:str, neighbor:str=\"*\", relationship:str=\"*\", direction:str=\"D_OUT\", modifier:str=\"M_ANY\", condition:str=\"V_ANY\", value:float=0.0, timeout:int=5000 ):",
    "    \"\"\"",
    "    Disconnect initial from terminal(s)",
    "    \"\"\"",
    "    g, close = sysplugin__GetGraphObject( graph )",
    "    try:",
    "        dir = getattr(pyvgx,direction)",
    "        mod = getattr(pyvgx,modifier)",
    "        if mod == pyvgx.M_ANY:",
    "            arc = (relationship, dir)",
    "        else:",
    "            vcond = getattr(pyvgx,condition)",
    "            val = getattr(pyvgx,value)",
    "            arc = (relationship, dir, mod, vcond, val)",
    "        r = g.Disconnect( id=id, arc=arc, neighbor=neighbor, timeout=timeout )",
    "        action = \"disconnected\" if r > 0 else None",
    "        return { 'id':id, 'action':action, 'arcs':r }",
    "    finally:",
    "        if close:",
    "            g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__disconnect )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_echo[] = {
    "# BUILTIN_echo"
    "import pyvgx",
    "def sysplugin__echo( request:pyvgx.PluginRequest, headers:dict, method:str, content:bytes ):",
    "    \"\"\"",
    "    Server echo",
    "    \"\"\"",
    "    http = {}",
    "    echo = { 'HTTP': http }",
    "    http['method'] = method",
    "    http['request'] = request.params",
    "    H = {}",
    "    for k,v in sorted( headers.items() ):",
    "        try:",
    "            H[k] = v.decode()",
    "        except:",
    "            H[k] = repr(v)",
    "    http['headers'] = H",
    "    try:",
    "        http['content'] = content.decode()",
    "    except:",
    "        http['content'] = repr( content )",
    "    return echo",
    "pyvgx.system.AddPlugin( plugin=sysplugin__echo )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_evaluate[] = {
    "# BUILTIN_evaluate"
    "import pyvgx",
    "def sysplugin__evaluate( request:pyvgx.PluginRequest, content:str, graph:str, expression:str=\"\", tail:str=\"\", arc:str=\"\", head:str=\"\", memory:int=128, memresult:int=0, sharedmem:int=0 ):",
    "    \"\"\"",
    "    Expression evaluator",
    "    \"\"\"",
    "    g, close = sysplugin__GetGraphObject( graph )",
    "    try:",
    "        M = sysplugin__GetGraphMemory( g, memory, sharedmem )",
    "        params = { 'memory': M }",
    "        if content:",
    "            params['expression'] = content",
    "        elif expression:",
    "            params['expression'] = expression",
    "        if tail:",
    "            params['tail'] = tail",
    "        if arc:",
    "            params['arc'] = sysplugin__VALIDATOR.SafeEval( arc )",
    "        if head:",
    "            params['head'] = head",
    "        if 'tail' in params:",
    "            params['tail'] = g.OpenVertex( params['tail'], mode='r', timeout=5000 )",
    "        if 'head' in params:",
    "            params['head'] = g.OpenVertex( params['head'], mode='r', timeout=5000 )",
    "        R = g.Evaluate( **params )",
    "        if memresult:",
    "            L = M.AsList()",
    "        else:",
    "            L = []",
    "        response = { 'result': repr(R), 'memory': L }",
    "        return response",
    "    finally:",
    "        try:",
    "            if 'tail' in params:",
    "                g.CloseVertex( params['tail'] )",
    "            if 'head' in params:",
    "                g.CloseVertex( params['head'] )",
    "        finally:",
    "            if close:",
    "                g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__evaluate )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_eventbacklog[] = {
    "# BUILTIN_eventbacklog"
    "import pyvgx",
    "def sysplugin__eventbacklog( request:pyvgx.PluginRequest, graph:str ):",
    "    \"\"\"",
    "    Event processor backlog",
    "    \"\"\"",
    "    g, close = sysplugin__GetGraphObject( graph )",
    "    try:",
    "        return g.EventBacklog()",
    "    except:",
    "        if close:",
    "            g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__eventbacklog )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_graphinfo[] = {
    "# BUILTIN_graphinfo"
    "import pyvgx",
    "def sysplugin__graphinfo( request:pyvgx.PluginRequest, headers:dict, content:str, graph:str, simple:int=0 ):",
    "    \"\"\"",
    "    Graph status information",
    "    \"\"\"",
    "    g, close = sysplugin__GetGraphObject( graph )",
    "    try:",
    "        return g.Status( None, simple )",
    "    finally:",
    "        if close:",
    "            g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__graphinfo )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_init[] = {
    "# BUILTIN_init"
    "import pyvgx",
    "def sysplugin__init( request:pyvgx.PluginRequest ):",
    "    \"\"\"",
    "    Server init",
    "    \"\"\"",
    "    sysplugin__OnServerStartup()",
    "    return { \"init\": \"ok\" }",
    "pyvgx.system.AddPlugin( plugin=sysplugin__init )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_matrix[] = {
    "# BUILTIN_matrix"
    "import pyvgx",
    "def sysplugin__matrix__engine_objects( request:pyvgx.PluginRequest ) -> pyvgx.PluginResponse:",
    "    \"\"\"",
    "    Engine object count",
    "    \"\"\"",
    "    OBJ = {}",
    "    for name in pyvgx.system.Registry():",
    "        try:",
    "            g = pyvgx.Graph(name)",
    "        except:",
    "            try:",
    "                g = pyvgx.system.GetGraph(name)",
    "            except:",
    "                continue",
    "        for key, val in g.objcnt.items():",
    "            if key not in OBJ:",
    "                OBJ[key] = 0",
    "            OBJ[key] += val",
    "    response = pyvgx.PluginResponse()",
    "    response.Append( OBJ )",
    "    return response",
    "def sysplugin__matrix__pre_objects( request:pyvgx.PluginRequest ) -> pyvgx.PluginRequest:",
    "    \"\"\"",
    "    Dispatcher object count pre processor",
    "    \"\"\"",
    "    request.primary = 1",
    "    return request",
    "def sysplugin__matrix__post_objects( response:pyvgx.PluginResponse ):",
    "    \"\"\"",
    "    Dispatcher object count post processor",
    "    \"\"\"",
    "    AGGR = {}",
    "    for pos, OBJ in response:",
    "        for key, val in OBJ.items():",
    "            if key not in AGGR:",
    "                AGGR[key] = 0",
    "            AGGR[key] += val",
    "    if response.toplevel:",
    "        aggr_response = {",
    "            'level' : response.level,",
    "            'objects' : AGGR",
    "        }",
    "    else:",
    "        aggr_response = pyvgx.PluginResponse()",
    "        aggr_response.Append( AGGR )",
    "    return aggr_response",
    "def sysplugin__matrix__engine_identify( request:pyvgx.PluginRequest ) -> pyvgx.PluginResponse:",
    "    \"\"\"",
    "    Engine identify",
    "    \"\"\"",
    "    response = pyvgx.PluginResponse()",
    "    host = pyvgx.system.ServerHost()",
    "    port = pyvgx.system.ServerPorts().get('base')",
    "    identity = {",
    "        'ident'     : str(request.ident),",
    "        'address'   : \"{}:{}\".format( host.get('ip'), port ),",
    "        'hostname'  : host.get('host'),",
    "        'registry'  : pyvgx.system.Registry()",
    "    }",
    "    response.Append( request.partition, identity )",
    "    return response",
    "def sysplugin__matrix__pre_identify( request:pyvgx.PluginRequest ) -> pyvgx.PluginRequest:",
    "    \"\"\"",
    "    Dispatcher identify pre processor",
    "    \"\"\"",
    "    request.primary = 1",
    "    return request",
    "def sysplugin__matrix__post_identify( response:pyvgx.PluginResponse ):",
    "    \"\"\"",
    "    Dispatcher identify post processor",
    "    \"\"\"",
    "    host = pyvgx.system.ServerHost()",
    "    port = pyvgx.system.ServerPorts().get('base')",
    "    identity = {",
    "        'ident'     : str(response.ident),",
    "        'address'   : \"{}:{}\".format( host.get('ip'), port ),",
    "        'hostname'  : host.get('host'),",
    "        'matrix'    : response.entries",
    "    }",
    "    if response.toplevel:",
    "        return identity",
    "    else:",
    "        dispatcher = pyvgx.PluginResponse()",
    "        dispatcher.Append( response.partition, identity )",
    "        return dispatcher",
    "def __matrix__AddDispatcherPlugins():",
    "    pyvgx.system.AddPlugin( name = \"sysplugin__MatrixObjects\", pre=sysplugin__matrix__pre_objects,  post=sysplugin__matrix__post_objects )",
    "    pyvgx.system.AddPlugin( name = \"sysplugin__Identify\",      pre=sysplugin__matrix__pre_identify, post=sysplugin__matrix__post_identify )",
    "def __matrix__AddEnginePlugins():",
    "    pyvgx.system.AddPlugin( name = \"sysplugin__MatrixObjects\", plugin=sysplugin__matrix__engine_objects )",
    "    pyvgx.system.AddPlugin( name = \"sysplugin__Identify\",      plugin=sysplugin__matrix__engine_identify )",
    "def __matrix__RemovePlugins():",
    "    plugins = [",
    "        \"sysplugin__MatrixObjects\",",
    "        \"sysplugin__Identify\"",
    "    ]",
    "    for plugin in plugins:",
    "        try:",
    "            pyvgx.system.RemovePlugin( plugin )",
    "        except:",
    "            pass",
    "pyvgx.__matrix__AddDispatcherPlugins = __matrix__AddDispatcherPlugins",
    "pyvgx.__matrix__AddEnginePlugins = __matrix__AddEnginePlugins",
    "pyvgx.__matrix__RemovePlugins = __matrix__RemovePlugins",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_matrixplugins[] = {
    "# BUILTIN_matrixplugins"
    "import pyvgx",
    "def __id_plug( path, plug, typ, level ):",
    "    id = \"{} [{:04x}]\".format( path, 0xff - level )",
    "    P = {}",
    "    P[\"matrix\"] = {",
    "        \"location\": typ,",
    "        \"level\": level",
    "    }",
    "    for k,v in plug.items():",
    "        P[k] = v",
    "    return id, P",
    "def sysplugin__matrixplugins_pre( request:pyvgx.PluginRequest ):",
    "    \"\"\"",
    "    Deep plugin listing",
    "    \"\"\"",
    "    if request.port != request.baseport:",
    "        raise Exception( \"Server base port {} required for this request, port {} was used\".format( request.baseport, request.port ) )",
    "    if pyvgx.system.DispatcherConfig() is not None:",
    "        return request",
    "    response = pyvgx.PluginResponse( sortby=pyvgx.S_ID )",
    "    if request.partition != 0:",
    "        return response # empty if not first part",
    "    level = 0",
    "    engine_plugs = [(p['path'],p) for p in pyvgx.system.GetPlugins()]",
    "    for path, plug in sorted( engine_plugs ):",
    "        id, plug = __id_plug( path, plug, \"engine\", 0 )",
    "        response.Append( id, plug )",
    "    return response",
    "def sysplugin__matrixplugins_post( response:pyvgx.PluginResponse ):",
    "    \"\"\"",
    "    Deep plugin listing",
    "    \"\"\"",
    "    if pyvgx.system.DispatcherConfig() is None:",
    "        return response # ?",
    "    if response.partition != 0:",
    "        return response",
    "    level = response.level",
    "    dplugs = {}",
    "    dispatch_plugs = [(p['path'],p) for p in pyvgx.system.GetPlugins()]",
    "    for path, plug in dispatch_plugs:",
    "        dtype = \"top-dispatch\" if response.toplevel else \"dispatch\"",
    "        id, plug = __id_plug( path, plug, dtype, level )",
    "        dplugs[id] = plug",
    "    for id, plug in response.entries:",
    "        dplugs[id] = plug",
    "    matrix_plugs = dplugs.items()",
    "    if response.toplevel:",
    "        top_response = []",
    "        for id, plug in sorted( matrix_plugs ):",
    "            top_response.append( plug )",
    "        return top_response",
    "    else:",
    "        dispatch_response = pyvgx.PluginResponse( sortby=pyvgx.S_ID )",
    "        for id, plug in sorted( matrix_plugs ):",
    "            dispatch_response.Append( id, plug )",
    "        return dispatch_response",
    "pyvgx.system.AddPlugin( name=\"sysplugin__matrixplugins\", pre=sysplugin__matrixplugins_pre, post=sysplugin__matrixplugins_post )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_memory[] = {
    "# BUILTIN_memory"
    "import pyvgx",
    "def sysplugin__memory( request:pyvgx.PluginRequest, headers:dict, content:str, graph:str ):",
    "    \"\"\"",
    "    Memory usage for graph",
    "    \"\"\"",
    "    if graph == \"*\":",
    "        response = {}",
    "        for name in pyvgx.system.Registry():",
    "            response[name] = sysplugin__memory( request, headers, content, name )",
    "        return response",
    "    else:",
    "        g, close = sysplugin__GetGraphObject( graph )",
    "    try:",
    "        return g.GetMemoryUsage()",
    "    finally:",
    "        if close:",
    "            g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__memory )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_metrics[] = {
    "# BUILTIN_metrics"
    "import pyvgx",
    "import json",
    "def sysplugin__metrics( request:pyvgx.PluginRequest, headers:dict, content:str, latency:json=[80,90,95,99] ):",
    "    \"\"\"",
    "    HTTP Server Metrics",
    "    \"\"\"",
    "    return pyvgx.system.ServerMetrics( latency )",
    "pyvgx.system.AddPlugin( plugin=sysplugin__metrics )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_neighbor[] = {
    "# BUILTIN_neighbor"
    "import pyvgx",
    "import re",
    "sysplugin__neighbor_EXCLUDE = set([\"headers\", \"content\", \"graph\", \"id\", \"hits\", \"query\", \"sharedmem\"])",
    "def sysplugin__neighbor( request:pyvgx.PluginRequest, headers:dict, content:str, graph:str, id:str=\"\", hits:int=25, query:str=\"\", sharedmem:int=0 ):",
    "    \"\"\"",
    "    Neighborhood query",
    "    \"\"\"",
    "    g, close = sysplugin__GetGraphObject( graph )",
    "    try:",
    "        Q = {",
    "          'timeout': 5000,",
    "          'hits'   : hits,",
    "          'fields' : pyvgx.F_AARC",
    "        }",
    "        if id:",
    "            Q['id'] = id",
    "        for k,v in request.params.items():",
    "            if k not in sysplugin__neighbor_EXCLUDE:",
    "                Q[k] = v",
    "        sysplugin__UpdateQueryDict( Q, query, content )",
    "        if 'memory' in Q:",
    "            Q['memory'] = sysplugin__GetGraphMemory( g, Q['memory'], sharedmem )",
    "        M = Q.get( 'memory' )",
    "        R = g.Neighborhood( **Q )",
    "        if M is not None:",
    "            if type(R) is not dict:",
    "                R = {'neighborhood':R}",
    "            R['memory'] = M.AsList()",
    "        return R",
    "    finally:",
    "        if close:",
    "            g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__neighbor )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_ping[] = {
    "# BUILTIN_ping"
    "import pyvgx",
    "def sysplugin__ping( request:pyvgx.PluginRequest ):",
    "    \"\"\"",
    "    Server ping",
    "    \"\"\"",
    "    return True",
    "pyvgx.system.AddPlugin( plugin=sysplugin__ping )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_properties[] = {
    "# BUILTIN_properties"
    "import pyvgx",
    "def sysplugin__properties( request:pyvgx.PluginRequest ):",
    "    \"\"\"",
    "    System properties",
    "    \"\"\"",
    "    return pyvgx.system.GetProperties()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__properties )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_system_counts[] = {
    "# BUILTIN_system_counts"
    "import pyvgx",
    "def sysplugin__system_counts( request:pyvgx.PluginRequest, headers:dict, idlist:str=\"\" ):",
    "    \"\"\"",
    "    Multi-node system object counts",
    "    \"\"\"",
    "    R = []",
    "    result = {",
    "        \"instances\": R,",
    "        \"message\": None",
    "    }",
    "    try:",
    "        D = sysplugin__GetSystemDescriptor()",
    "    except Exception as err:",
    "        result[\"message\"] = \"{}\".format( err )",
    "        result[\"error\"] = True",
    "        return result",
    "    try:",
    "        instances = D.get(\"instances\",{})",
    "        idlist = idlist.replace(\" \",\"\")",
    "        include = [(x,instances[x]) for x in idlist.split(\",\") if x in instances]",
    "        for id, instance in include:",
    "            host = instance.get(\"host\")",
    "            aport = instance.get(\"hport\",-1) + 1",
    "            if host and aport:",
    "                try:",
    "                    sysplugin__SendAdminRequest( host, aport, path=\"/vgx/hc\", timeout=0.2 )",
    "                    objcnt, headers = sysplugin__SendAdminRequest( host, aport, path=\"/vgx/objcnt\", timeout=2.0 )",
    "                except:",
    "                    objcnt = None",
    "            R.append({",
    "                \"id\": id,",
    "                \"hostname\": host,",
    "                \"adminport\": aport,",
    "                \"objcnt\": objcnt",
    "            })",
    "    except Exception as err:",
    "        result[\"message\"] = \"{}\".format( err )",
    "        result[\"error\"] = True",
    "    return result",
    "pyvgx.system.AddPlugin( plugin=sysplugin__system_counts )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_system_descriptor[] = {
    "# BUILTIN_system_descriptor"
    "import pyvgx",
    "def sysplugin__system_descriptor( request:pyvgx.PluginRequest ):",
    "    \"\"\"",
    "    System descriptor",
    "    \"\"\"",
    "    return sysplugin__GetSystemDescriptor()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__system_descriptor )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_system_overview[] = {
    "# BUILTIN_system_overview"
    "import pyvgx",
    "import json",
    "def sysplugin__system_overview( request:pyvgx.PluginRequest, headers:dict ):",
    "    \"\"\"",
    "    Multi-node system status",
    "    \"\"\"",
    "    def VGXInstanceMetrics( host, port, nodetype ):",
    "        \"\"\"",
    "        Return aggregate info from vgx node",
    "        \"\"\"",
    "        hc, headers = sysplugin__SendAdminRequest( host, port, path=\"/vgx/hc\", timeout=0.25 )",
    "        info = {",
    "            \"nodestat\"  : {}",
    "        }",
    "        if nodetype == \"dispatch\":",
    "            info[ \"matrix\" ] = {}",
    "        for page in list(info.keys()):",
    "            endpoint = \"/vgx/{}\".format( page )",
    "            try:",
    "                data, headers = sysplugin__SendAdminRequest( host, port, path=endpoint, timeout=2.0 )",
    "                info[page] = data.decode() if type(data) is bytes else data",
    "            except:",
    "                pass",
    "        info[\"hc\"] = hc.decode()",
    "        return info",
    "    def GetNodeInfo( id, instance ):",
    "        entry = {",
    "            \"id\"        : id,",
    "            \"hostname\"  : None,",
    "            \"adminport\" : None,",
    "            \"nodetype\"  : None,",
    "            \"message\"   : None,",
    "            \"group\"     : instance.get('group',-1),",
    "            \"partition\" : instance.get('partition',-1)",
    "        }",
    "        if entry['group'] is None:",
    "            raise Exception( \"In GetNodeInfo instance.get('group',-1) returned None!\" )",
    "        if entry['group'] < 0:",
    "            entry['group'] = instance.get('partition',\"1000.0001\")",
    "        try:",
    "            entry['hostname'] = instance.get('host')",
    "            entry['adminport'] = int(instance.get('hport')) + 1",
    "            entry['nodetype'] = instance.get('type')",
    "        except Exception as ex:",
    "            entry['message'] = \"Bad system descriptor entry: {}\".format( instance )",
    "            entry['error'] = True",
    "            return entry",
    "        try:",
    "            metrics = VGXInstanceMetrics( entry['hostname'], entry['adminport'], entry['nodetype'] )",
    "            entry.update( metrics )",
    "        except Exception as ex:",
    "            entry['message'] = \"Failed to get VGX Instance Metrics: {}\".format( ex )",
    "            entry['error'] = True",
    "        return entry",
    "    def NodestatDict( instance ):",
    "        nodestat = instance.get( \"nodestat\" )",
    "        return nodestat if type(nodestat) is dict else {}",
    "    def ResolveDispatcherInfo( instances ):",
    "        def x_key( ip=None, aport=None, hport=None ):",
    "            if ip is None or (aport is None and hport is None):",
    "                return None",
    "            if hport is not None:",
    "                aport = hport + 1",
    "            key = \"{}:{}\".format( ip, aport )",
    "            return key",
    "        def instance_key( instance ):",
    "            nodestat = NodestatDict( instance )",
    "            return x_key( ip=nodestat.get(\"ip\"), aport=nodestat.get(\"adminport\") )",
    "        def matrix_key( mx_entry ):",
    "            return x_key( ip=mx_entry.get(\"ip\"), hport=mx_entry.get(\"port\") )",
    "        instance_map = {}",
    "        for instance in instances:",
    "            if instance.get( \"id\" ) is None:",
    "                continue",
    "            key = instance_key( instance )",
    "            if key is None:",
    "                continue",
    "            nodestat = NodestatDict( instance )",
    "            instance_map[ key ] = {",
    "                \"id\": instance.get( \"id\" ),",
    "                \"nodetype\": instance.get( \"nodetype\" ),",
    "                \"idle-ms\": nodestat.get( \"idle-ms\", 0 ),",
    "                \"digest\": nodestat.get( \"digest\" ),",
    "                \"consistent\": True,",
    "                \"complete\": True,",
    "                \"degraded\": False,",
    "                \"s-in\": instance.get( \"hc\" ) == \"VGX/3\"",
    "            }",
    "        for instance in instances:",
    "            if instance.get( \"nodetype\" ) == \"dispatch\":",
    "                matrix = instance.get( \"matrix\" )",
    "                if matrix is None:",
    "                    continue",
    "                consistent = True",
    "                complete = len(matrix) > 0",
    "                degraded = False",
    "                for partition in matrix:",
    "                    digest = None",
    "                    idle_ms = 0",
    "                    s_in_count = 0",
    "                    for replica in partition:",
    "                        replica_engine = instance_map.get( matrix_key( replica ), {} )",
    "                        replica[\"id\"] = replica_engine.get( \"id\", None )",
    "                        replica[\"nodetype\"] = replica_engine.get( \"nodetype\", None )",
    "                        if replica_engine.get(\"s-in\") is not True:",
    "                            replica[\"serving\"] = False",
    "                            degraded = True",
    "                        else:",
    "                            s_in_count += 1",
    "                            replica[\"serving\"] = True",
    "                        if replica[\"nodetype\"] != \"dispatch\":",
    "                            replica_digest = replica_engine.get( \"digest\", 0 )",
    "                            replica_idle_ms = replica_engine.get( \"idle-ms\", 0 )",
    "                            replica[\"digest\"] = replica_digest",
    "                            if digest is None:",
    "                                digest = replica_digest",
    "                            elif digest != replica_digest and replica_idle_ms > 30000:",
    "                                consistent = False",
    "                    if s_in_count == 0:",
    "                        complete = False",
    "                key = instance_key( instance )",
    "                instance_map.get( key, {} )[\"consistent\"] = consistent",
    "                instance_map.get( key, {} )[\"complete\"] = complete",
    "                instance_map.get( key, {} )[\"degraded\"] = degraded",
    "        for instance in instances:",
    "            matrix = instance.get( \"matrix\" )",
    "            if matrix is None:",
    "                continue",
    "            entry = instance_map.get( instance_key( instance ), {} )",
    "            consistent = entry.get( \"consistent\", False )",
    "            complete = entry.get( \"complete\", False )",
    "            degraded = entry.get( \"degraded\", True )",
    "            for partition in matrix:",
    "                for replica in partition:",
    "                    if replica.get( \"nodetype\" ) == \"dispatch\":",
    "                        dispatcher = instance_map.get( matrix_key( replica ) )",
    "                        if dispatcher is None:",
    "                            continue",
    "                        if not dispatcher[\"consistent\"]:",
    "                            consistent = False",
    "                        if not dispatcher[\"complete\"]:",
    "                            complete = False",
    "                        if dispatcher[\"degraded\"]:",
    "                            degraded = True",
    "            instance[\"matrix-consistent\"] = consistent",
    "            instance[\"matrix-complete\"] = complete",
    "            instance[\"matrix-degraded\"] = degraded",
    "    def sortkey(x):",
    "        try:",
    "            p = float(x.get('group'))",
    "        except:",
    "            p = 0.0",
    "        t = {'admin':0, 'dispatch':1, 'builder':2, 'txproxy':3, 'search':4}.get(x.get('nodetype'),5)",
    "        i = x.get('id')",
    "        return \"{:08.3f}_{}_{}\".format(p,t,i)",
    "    result = {",
    "        \"version\": pyvgx.version(1),",
    "        \"id\": None,",
    "        \"descriptor\": None,",
    "        \"instances\": [],",
    "        \"message\": None,",
    "        \"error\": False",
    "    }",
    "    try:",
    "        result[\"descriptor\"] = sysplugin__GetSystemDescriptor()",
    "    except Exception as err:",
    "        result[\"message\"] = \"{}\".format( err )",
    "        result[\"error\"] = True",
    "        return result",
    "    try:",
    "        instances = set()",
    "        for id, node in sysplugin__GetTransactionTopologyInstances():",
    "            if id not in instances:",
    "                instances.add(id)",
    "                instance_info = GetNodeInfo( id, node )",
    "                result[\"instances\"].append( instance_info )",
    "        for id, node in sysplugin__GetDispatchTopologyInstances():",
    "            if id not in instances:",
    "                instances.add(id)",
    "                instance_info = GetNodeInfo( id, node )",
    "                result[\"instances\"].append( instance_info )",
    "        ResolveDispatcherInfo( result[\"instances\"] )",
    "        result[\"instances\"].sort( key=sortkey )",
    "        this_label = pyvgx.system.UniqueLabel()",
    "        for instance_info in result[\"instances\"]:",
    "            id = instance_info.get('id','?')",
    "            nodestat = instance_info.get('nodestat',{})",
    "            if nodestat.get('service-label') == this_label:",
    "                result['id'] = id",
    "                break",
    "    except Exception as err:",
    "        result[\"message\"] = \"{}\".format( err )",
    "        result[\"error\"] = True",
    "    return result",
    "pyvgx.system.AddPlugin( plugin=sysplugin__system_overview )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_system_rates[] = {
    "# BUILTIN_system_rates"
    "import pyvgx",
    "def sysplugin__system_rates( request:pyvgx.PluginRequest, headers:dict, idlist:str=\"\" ):",
    "    \"\"\"",
    "    Multi-node system service rates",
    "    \"\"\"",
    "    R = []",
    "    result = {",
    "        \"instances\": R,",
    "        \"message\": None",
    "    }",
    "    try:",
    "        D = sysplugin__GetSystemDescriptor()",
    "    except Exception as err:",
    "        result[\"message\"] = \"{}\".format( err )",
    "        result[\"error\"] = True",
    "        return result",
    "    try:",
    "        instances = D.get(\"instances\",{})",
    "        idlist = idlist.replace(\" \",\"\")",
    "        include = [(x,instances[x]) for x in idlist.split(\",\") if x in instances]",
    "        for id, instance in include:",
    "            host = instance.get(\"host\")",
    "            aport = instance.get(\"hport\",-1) + 1",
    "            if host and aport:",
    "                try:",
    "                    sysplugin__SendAdminRequest( host, aport, path=\"/vgx/hc\", timeout=0.2 )",
    "                    status, headers = sysplugin__SendAdminRequest( host, aport, path=\"/vgx/status\", timeout=2.0 )",
    "                    rates = status[\"response_ms\"]",
    "                    rates[\"rate\"] = status[\"request\"][\"rate\"]",
    "                    clients = {}",
    "                    clients[\"connected\"] = status[\"connected_clients\"]",
    "                    matrix = {}",
    "                    matrix[\"active-channels\"] = status[\"dispatcher\"][\"matrix-active-channels\"];",
    "                    matrix[\"total-channels\"] = status[\"dispatcher\"][\"matrix-total-channels\"];",
    "                except:",
    "                    rates = None",
    "                    clients = None",
    "                    matrix = None",
    "            R.append({",
    "                \"id\": id,",
    "                \"hostname\": host,",
    "                \"adminport\": aport,",
    "                \"rates\": rates,",
    "                \"clients\": clients,",
    "                \"matrix\": matrix",
    "            })",
    "    except Exception as err:",
    "        result[\"message\"] = \"{}\".format( err )",
    "        result[\"error\"] = True",
    "    return result",
    "pyvgx.system.AddPlugin( plugin=sysplugin__system_rates )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_vertex[] = {
    "# BUILTIN_vertex"
    "import pyvgx",
    "def sysplugin__vertex( request:pyvgx.PluginRequest, graph:str, id:str, maxarcs:int=3 ):",
    "    \"\"\"",
    "    Get vertex information",
    "    \"\"\"",
    "    g, close = sysplugin__GetGraphObject( graph )",
    "    V = None",
    "    try:",
    "        V = g.OpenVertex( id, mode='r', timeout=5000 )",
    "        ident = 'Vertex( %s )' % id",
    "        data = {}",
    "        result = { ident: data }",
    "        for arcdir, key in [(pyvgx.D_OUT,'outarcs'), (pyvgx.D_IN,'inarcs')]:",
    "            top = g.Neighborhood( V, arc=arcdir, sortby=pyvgx.S_VAL, fields=pyvgx.F_AARC, hits=maxarcs, result=pyvgx.R_STR|pyvgx.R_COUNTS, timeout=5000 )",
    "            c = top.get('counts',{}).get('arcs',0)",
    "            N = top.get( 'neighborhood', [] )",
    "            h = len( N )",
    "            if h < c:",
    "                N.append( '(%d more...)' % (c-h) )",
    "            data[ key ] = N",
    "        V_dict = V.AsDict()",
    "        V_dict.pop( 'id', None )",
    "        data[ 'properties' ] = V_dict.pop( 'properties', {} )",
    "        data[ 'attributes' ] = V_dict",
    "        return result",
    "    finally:",
    "        try:",
    "            if V is not None:",
    "                V.Close()",
    "        finally:",
    "            if close:",
    "                g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__vertex )",
    0
};



static const char *PYVGX_BUILTIN__BUILTIN_vertices[] = {
    "# BUILTIN_vertices"
    "import pyvgx",
    "import re",
    "sysplugin__vertices_EXCLUDE = set([\"headers\", \"content\", \"graph\", \"hits\", \"query\", \"sharedmem\"])",
    "def sysplugin__vertices( request:pyvgx.PluginRequest, headers:dict, content:str, graph:str, hits:int=25, query:str=\"\", sharedmem:int=0 ):",
    "    \"\"\"",
    "    Global vertices query",
    "    \"\"\"",
    "    g, close = sysplugin__GetGraphObject( graph )",
    "    try:",
    "        Q = {",
    "          'timeout': 5000,",
    "          'hits'   : hits,",
    "          'fields' : pyvgx.F_NAMES",
    "        }",
    "        for k,v in request.params.items():",
    "            if k not in sysplugin__vertices_EXCLUDE:",
    "                Q[k] = v",
    "        sysplugin__UpdateQueryDict( Q, query, content )",
    "        if 'memory' in Q:",
    "            Q['memory'] = sysplugin__GetGraphMemory( g, Q['memory'], sharedmem )",
    "        M = Q.get( 'memory' )",
    "        R = g.Vertices( **Q )",
    "        if M is not None:",
    "            if type(R) is not dict:",
    "                R = {'vertices': R}",
    "            R['memory'] = M.AsList()",
    "        return R",
    "    finally:",
    "        if close:",
    "            g.Close()",
    "pyvgx.system.AddPlugin( plugin=sysplugin__vertices )",
    0
};



static const char *PYVGX_BUILTIN__INTERNAL_admin[] = {
    "# INTERNAL_admin"
    "import pyvgx",
    "import ast",
    "import re",
    "import json",
    "import time",
    "import random",
    "import inspect",
    "import urllib.request",
    "import threading",
    "import http.client",
    "import socket",
    "__ADMIN_DISABLE_AUTH_PROP = \"ADMIN_DisableAuth\"",
    "__SYSTEM_DESCRIPTOR_PROP = \"SYSTEM_Descriptor\"",
    "__SYSTEM_DESCRIPTOR_IDENT_PROP = \"SYSTEM_DescriptorIdent\"",
    "__SHARED_EVAL_MEMORY = {}",
    "__ADMIN_AUTH_TOKENS = {}",
    "__ADMIN_IN_PROGRESS_TOKEN = None",
    "__ADMIN_IN_PROGRESS_RECURSION = 0",
    "__PREVIOUS_AUTH_TOKENS = []",
    "__HTTP_CONNECTIONS = {}",
    "__ADMIN_LOCK = threading.RLock()",
    "def sysplugin__OnServerStartup():",
    "    D = pyvgx.system.GetProperty( __SYSTEM_DESCRIPTOR_PROP, None )",
    "    ident = pyvgx.system.GetProperty( __SYSTEM_DESCRIPTOR_IDENT_PROP, None )",
    "    sysplugin__TransformLegacyDescriptor( D )",
    "    default_name = \"System Default ({})\".format(pyvgx.system.Root())",
    "    default_ident = \"G1\"",
    "    if D is None or D.get(\"name\") == default_name:",
    "        hostname = socket.gethostname()",
    "        try:",
    "            ip = socket.gethostbyname( hostname )",
    "        except Exception as ex:",
    "            pyvgx.LogError( \"Failed to resolve IP for {} ({})\".format( hostname, ex ) )",
    "            ip = socket.gethostbyname( \"127.0.0.1\" )",
    "            pyvgx.LogWarning( \"Using fallback IP: {}\".format( ip ) )",
    "        ports = pyvgx.system.ServerPorts()",
    "        bound = pyvgx.op.Bound()",
    "        D = {",
    "            \"name\": default_name,",
    "            \"graphs\": [],",
    "            \"instances\": {",
    "                default_ident: {",
    "                    \"graph\":        None,",
    "                    \"group\":        1.1,",
    "                    \"type\":         \"generic\",",
    "                    \"host\":         ip,",
    "                    \"hport\":        ports.get(\"base\",0),",
    "                    \"tport\":        bound[0],",
    "                    \"durable\":      bound[1],",
    "                    \"description\":  \"Generic VGX instance\"",
    "                }",
    "            },",
    "            \"topology\": {",
    "                \"transaction\": {",
    "                    default_ident: {}",
    "                },",
    "                \"dispatch\": {",
    "                    default_ident: {}",
    "                }",
    "            }",
    "        }",
    "        pyvgx.system.SetProperty( __SYSTEM_DESCRIPTOR_PROP, D )",
    "        pyvgx.system.SetProperty( __SYSTEM_DESCRIPTOR_IDENT_PROP, default_ident )",
    "def sysplugin__GetGraphMemory( graph, size, shared=False ):",
    "    if shared:",
    "        key = '%s:%d' % (graph.name, size)",
    "        M = __SHARED_EVAL_MEMORY.get( key )",
    "        if M is None:",
    "            M = graph.Memory( size )",
    "            __SHARED_EVAL_MEMORY[ key ] = M",
    "    else:",
    "        M = graph.Memory( size )",
    "    return M",
    "def sysplugin__GenerateNextAuthToken( client_uri ):",
    "    \"\"\"",
    "    Generate a new admin authtoken for this client",
    "    \"\"\"",
    "    VALID_SECONDS = 300",
    "    host = client_uri.split(':')[1]",
    "    previous = __ADMIN_AUTH_TOKENS.get( host )",
    "    if previous is None:",
    "        X = \"\".join([chr(x) for x in random.sample(  range(33,128), 64 )])",
    "        Y = pyvgx.sha256( X )",
    "        for n in range( 10 ):",
    "            time.sleep( random.random() / 4 )",
    "            t1 = time.time()",
    "            random.seed( t1 )",
    "            X = \"\".join([chr(x) for x in random.sample(  range(33,128), 64 )])",
    "            Y = pyvgx.sha256( \"%s %s %s\" % (X, Y, host) )",
    "        seed = Y",
    "    else:",
    "        seed = previous[0]",
    "    t0 = time.time()",
    "    random.seed( t0 )",
    "    tx = t0 + VALID_SECONDS",
    "    token = pyvgx.sha256( '%s_%.20f_%.20f_%s' % (seed, t0, random.random(), host) )",
    "    __PREVIOUS_AUTH_TOKENS.append( seed )",
    "    while len(__PREVIOUS_AUTH_TOKENS) > 5:",
    "        __PREVIOUS_AUTH_TOKENS.pop(0)",
    "    __ADMIN_AUTH_TOKENS[ host ] = [token, tx]",
    "    for key in list(__ADMIN_AUTH_TOKENS.keys()):",
    "        if t0 > __ADMIN_AUTH_TOKENS[ key ][1]:",
    "            del __ADMIN_AUTH_TOKENS[ key ]",
    "    return (token, t0, tx)",
    "def sysplugin__GetPreviousAuthToken():",
    "    \"\"\"",
    "    Return previous authtoken",
    "    \"\"\"",
    "    if len(__PREVIOUS_AUTH_TOKENS) > 0:",
    "        return __PREVIOUS_AUTH_TOKENS[-1]",
    "    else:",
    "        return None",
    "def sysplugin__ValidateAndConsumeAuthToken( client_uri, token ):",
    "    host = client_uri.split(':')[1]",
    "    current = __ADMIN_AUTH_TOKENS.get( host )",
    "    if current is None:",
    "        raise PermissionError( 'Not authorized' )",
    "    auth = current[0]",
    "    tx = current[1]",
    "    now = time.time()",
    "    if token == auth:",
    "        if now < tx:",
    "            current[1] = 0.0",
    "        else:",
    "            raise PermissionError( 'Expired authtoken' )",
    "    else:",
    "        raise PermissionError( 'Invalid authtoken' )",
    "def sysplugin__LogAdminOperation( headers, opdata=\"unknown\" ):",
    "    K = dict([(k.lower(),k) for k in headers.keys()])",
    "    host = headers.get( K.get(\"host\") )",
    "    if host is None:",
    "        host = headers.get( K.get(\"x-vgx-builtin-client\"), \"unknown\" )",
    "    useragent = headers.get( K.get(\"user-agent\"), \"unknown\" )",
    "    pyvgx.LogInfo( 'ADMIN: op:\"{}\" origin:\"{}\" user-agent:\"{}\"'.format( opdata.replace('\"', r'\\\"'), host, useragent ) )",
    "def sysplugin__AuthorizeAdminOperation( headers, authtoken ):",
    "    if pyvgx.system.GetProperty( __ADMIN_DISABLE_AUTH_PROP, None ) != 1:",
    "        client_uri = headers.get( 'X-Vgx-Builtin-Client' )",
    "        sysplugin__ValidateAndConsumeAuthToken( client_uri, authtoken )",
    "        try:",
    "            caller = inspect.stack()[1].function",
    "            caller = re.sub( \"^sysplugin__\", \"\", caller )",
    "        except:",
    "            caller = \"?\"",
    "        sysplugin__LogAdminOperation( headers, caller )",
    "def sysplugin__BeginAdmin( authtoken ):",
    "    global __ADMIN_IN_PROGRESS_TOKEN",
    "    global __ADMIN_IN_PROGRESS_RECURSION",
    "    if not __ADMIN_LOCK.acquire( timeout=1.0 ):",
    "        raise Exception( \"Internal admin error\" )",
    "    try:",
    "        if __ADMIN_IN_PROGRESS_TOKEN is None:",
    "            __ADMIN_IN_PROGRESS_RECURSION = 0",
    "            __ADMIN_IN_PROGRESS_TOKEN = authtoken",
    "        elif __ADMIN_IN_PROGRESS_TOKEN != authtoken:",
    "            raise Exception( \"Another admin operation is currently in progress\" )",
    "        __ADMIN_IN_PROGRESS_RECURSION += 1",
    "    finally:",
    "        __ADMIN_LOCK.release()",
    "def sysplugin__EndAdmin( authtoken ):",
    "    global __ADMIN_IN_PROGRESS_TOKEN",
    "    global __ADMIN_IN_PROGRESS_RECURSION",
    "    if not __ADMIN_LOCK.acquire( timeout=10.0 ):",
    "        raise Exception( \"Internal admin error (admin deadlock!)\" )",
    "    try:",
    "        if __ADMIN_IN_PROGRESS_TOKEN == authtoken:",
    "            __ADMIN_IN_PROGRESS_RECURSION -= 1",
    "        if __ADMIN_IN_PROGRESS_RECURSION < 1:",
    "            __ADMIN_IN_PROGRESS_TOKEN = None",
    "    finally:",
    "        __ADMIN_LOCK.release()",
    "def sysplugin__CloseHTTPConnection( host, port ):",
    "    key = \"{}:{}:{}\".format( host, port, threading.get_ident() )",
    "    _, conn = __HTTP_CONNECTIONS.pop( key, (None,None) )",
    "    if conn is not None:",
    "        conn.close()",
    "def sysplugin__CleanupHTTPConnections():",
    "    CLEANUP_THRESHOLD = 64",
    "    if len(__HTTP_CONNECTIONS) > CLEANUP_THRESHOLD:",
    "        CLEANUP_COUNT = 16 # Clean up 1/4 of old connections",
    "        for key, entry in sorted( __HTTP_CONNECTIONS.items(), key=lambda x:x[1][0] )[:CLEANUP_COUNT]:",
    "            _, conn = __HTTP_CONNECTIONS.pop( key, (None,None) )",
    "            if conn is not None:",
    "                conn.close()",
    "def sysplugin__NewHTTPConnection( host, port, timeout=4.0 ):",
    "    try:",
    "        sysplugin__CleanupHTTPConnections()",
    "    except Exception as err:",
    "        pyvgx.LogError( \"ADMIN HTTPConnection cleanup failed: {}\".format(err) )",
    "    key = \"{}:{}:{}\".format( host, port, threading.get_ident() )",
    "    _, conn = __HTTP_CONNECTIONS.get( key, (None,None) )",
    "    if conn is None:",
    "        conn = http.client.HTTPConnection( host, port, timeout=timeout )",
    "        __HTTP_CONNECTIONS[key] = time.time(), conn",
    "    return conn",
    "def sysplugin__SendAdminRequest( host, port, path, headers={}, timeout=4.0 ):",
    "    attempts = 3",
    "    while attempts > 0:",
    "        try:",
    "            conn = sysplugin__NewHTTPConnection( host, port, timeout=timeout )",
    "            conn.request( \"GET\", path, headers=headers )",
    "            response = conn.getresponse()",
    "            data = response.read()",
    "            headers = {}",
    "            for k,v in response.getheaders():",
    "                headers[ k.lower() ] = v",
    "            if headers.get(\"content-type\",\"\").startswith(\"application/json;\"):",
    "                data = json.loads( data )",
    "                data = data.get(\"response\",data)",
    "            if response.status != 200:",
    "                conn.close()",
    "            return (data, headers)",
    "        except (http.client.NotConnected, http.client.ImproperConnectionState) as cex:",
    "            conn.close()",
    "            conn.connect()",
    "            attempts -= 1",
    "        except:",
    "            sysplugin__CloseHTTPConnection( host, port )",
    "            raise",
    "        time.sleep(0.25)",
    "def sysplugin__SetSystemDescriptor( descriptor, ident=None ):",
    "    \"\"\"",
    "    Update system descriptor and optionally set current instance identifier",
    "    \"\"\"",
    "    if ident is not None:",
    "        pass",
    "    D = sysplugin__ValidateSystemDescriptor( descriptor )",
    "    descriptor = pyvgx.Descriptor( D )",
    "    if ident is not None:",
    "        instance = descriptor.Get( ident )",
    "        pyvgx.system.SetProperty( __SYSTEM_DESCRIPTOR_IDENT_PROP, ident )",
    "    pyvgx.system.SetProperty( __SYSTEM_DESCRIPTOR_PROP, D )",
    "def sysplugin__GetSystemDescriptor():",
    "    \"\"\"",
    "    Return system descriptor",
    "    \"\"\"",
    "    descriptor = pyvgx.system.GetProperty( __SYSTEM_DESCRIPTOR_PROP, None )",
    "    if descriptor is None:",
    "        raise Exception( \"Missing system descriptor '{}'\".format( __SYSTEM_DESCRIPTOR_PROP ) )",
    "    sysplugin__TransformLegacyDescriptor( descriptor )",
    "    return descriptor",
    "def sysplugin__GetSystemIdent():",
    "    \"\"\"",
    "    Return system descriptor current instance ident",
    "    \"\"\"",
    "    ident = pyvgx.system.GetProperty( __SYSTEM_DESCRIPTOR_IDENT_PROP, None )",
    "    return ident",
    0
};



static const char *PYVGX_BUILTIN__INTERNAL_ast_validator[] = {
    "# INTERNAL_ast_validator"
    "import pyvgx",
    "import ast",
    "class Validator( ast.NodeTransformer ):",
    "    ALLOWED_NODE_CLASSES = set([",
    "        ast.Add,",
    "        ast.And,",
    "        ast.Attribute,",
    "        ast.AugLoad,",
    "        ast.AugStore,",
    "        ast.BinOp,",
    "        ast.BitAnd,",
    "        ast.BitOr,",
    "        ast.BitXor,",
    "        ast.BoolOp,",
    "        ast.Call,",
    "        ast.Compare,",
    "        ast.Constant,",
    "        ast.Dict,",
    "        ast.DictComp,",
    "        ast.Div,",
    "        ast.Eq,",
    "        ast.Expr,",
    "        ast.Expression,",
    "        ast.ExtSlice,",
    "        ast.FloorDiv,",
    "        ast.FormattedValue,",
    "        ast.FunctionType,",
    "        ast.GeneratorExp,",
    "        ast.Global,",
    "        ast.Gt,",
    "        ast.GtE,",
    "        ast.IfExp,",
    "        ast.In,",
    "        ast.Index,",
    "        ast.Invert,",
    "        ast.Is,",
    "        ast.IsNot,",
    "        ast.JoinedStr,",
    "        ast.LShift,",
    "        ast.Lambda,",
    "        ast.List,",
    "        ast.ListComp,",
    "        ast.Load,",
    "        ast.Lt,",
    "        ast.LtE,",
    "        ast.MatMult,",
    "        ast.Mod,",
    "        ast.Mult,",
    "        ast.Name,",
    "        ast.Not,",
    "        ast.NotEq,",
    "        ast.NotIn,",
    "        ast.Or,",
    "        ast.Param,",
    "        ast.Pow,",
    "        ast.RShift,",
    "        ast.Set,",
    "        ast.SetComp,",
    "        ast.Slice,",
    "        ast.Starred,",
    "        ast.Store,",
    "        ast.Sub,",
    "        ast.Subscript,",
    "        ast.Tuple,",
    "        ast.UAdd,",
    "        ast.USub,",
    "        ast.UnaryOp,",
    "        ast.arg,",
    "        ast.arguments,",
    "        ast.comprehension,",
    "        ast.keyword,",
    "        ])",
    "    ALLOWED_BUILTIN_FUNCTIONS = set([",
    "        'abs',",
    "        'all',",
    "        'any',",
    "        'ascii',",
    "        'bin',",
    "        'bool',",
    "        'bytearray',",
    "        'bytes',",
    "        'chr',",
    "        'complex',",
    "        'dict',",
    "        'dir',",
    "        'divmod',",
    "        'enumerate',",
    "        'filter',",
    "        'float',",
    "        'format',",
    "        'frozenset',",
    "        'getattr',",
    "        'hasattr',",
    "        'hash',",
    "        'hex',",
    "        'int',",
    "        'isinstance',",
    "        'issubclass',",
    "        'iter',",
    "        'len',",
    "        'list',",
    "        'map',",
    "        'max',",
    "        'min',",
    "        'next',",
    "        'oct',",
    "        'ord',",
    "        'pow',",
    "        'range',",
    "        'repr',",
    "        'reversed',",
    "        'round',",
    "        'set',",
    "        'slice',",
    "        'sorted',",
    "        'str',",
    "        'sum',",
    "        'tuple',",
    "        'type',",
    "        'zip'",
    "    ])",
    "    FORBIDDEN = set([",
    "        '__import__',",
    "        'breakpoint',",
    "        'callable',",
    "        'classmethod',",
    "        'compile',",
    "        'delattr',",
    "        'eval',",
    "        'exec',",
    "        'globals',",
    "        'help',",
    "        'id',",
    "        'input',",
    "        'locals',",
    "        'memoryview',",
    "        'object',",
    "        'open',",
    "        'print',",
    "        'property',",
    "        'setattr',",
    "        'staticmethod',",
    "        'super',",
    "        'vars',",
    "        'AddPlugin'",
    "    ])",
    "    EVAL_GLOBALS = dict( pyvgx=pyvgx )",
    "    def visit_Name( self, node ):",
    "        if node.id in self.FORBIDDEN or node.id.startswith(\"__\"):",
    "            raise SyntaxError( \"Forbidden name: %s\" % node.id )",
    "        try:",
    "            return ast.copy_location( ast.Constant( getattr( pyvgx, node.id ) ), node )",
    "        except Exception as err:",
    "            return node",
    "    def visit_Call( self, node ):",
    "        func = node.func",
    "        if type(func) is ast.Name and func.id in self.ALLOWED_BUILTIN_FUNCTIONS:",
    "            return node",
    "        else:",
    "            obj = func",
    "            while type(obj) in [ast.Attribute, ast.Call]:",
    "                if type(obj) is ast.Call:",
    "                    obj = obj.func",
    "                else:",
    "                    if obj.attr in self.FORBIDDEN:",
    "                        break",
    "                    obj = obj.value",
    "            if type(obj) is ast.Name and obj.id == \"pyvgx\":",
    "                return node",
    "        name = None",
    "        if type(obj) is ast.Name:",
    "            name = obj.id",
    "        elif type(obj) is ast.Attribute:",
    "            name = obj.attr",
    "        raise SyntaxError( \"Forbidden call: %s()\" % (name if name else \"<func>\") )",
    "    def generic_visit( self, node ):",
    "        if node.__class__ not in self.ALLOWED_NODE_CLASSES:",
    "            raise SyntaxError( \"'%s' not allowed\" % type(node).__name__ )",
    "        return ast.NodeTransformer.generic_visit( self, node )",
    "    def SafeEval( self, expr ):",
    "        if type(expr) is str :",
    "            tree = ast.parse( expr, mode='eval' )",
    "            self.visit( tree )",
    "            code = compile( tree, '<AST>', 'eval' )",
    "            return eval( code, self.EVAL_GLOBALS )",
    "        else:",
    "            return expr",
    "sysplugin__VALIDATOR = Validator()",
    "def sysplugin__UpdateQueryDict( Q, http_params=None, http_content=None ):",
    "    data = []",
    "    if http_params:",
    "        data.append( http_params )",
    "    if http_content:",
    "        if type( http_content ) is memoryview:",
    "            http_content = http_content.tobytes()",
    "        if type( http_content ) is bytes:",
    "            http_content = http_content.decode()",
    "        if type( http_content ) is str:",
    "            data.append( http_content )",
    "    for P in data:",
    "        try:",
    "            Q.update( sysplugin__VALIDATOR.SafeEval( P ) )",
    "        except Exception as ex:",
    "            norm = re.sub( r\"\\s+\", \" \", P )",
    "            raise ValueError( 'Bad query: %s (original exception=%s)' % (norm, ex) )",
    "    return Q",
    "def sysplugin__GetGraphObject( graph_name ):",
    "    try:",
    "        return pyvgx.system.GetGraph( graph_name ), False",
    "    except:",
    "        if graph_name in pyvgx.system.Registry():",
    "            return pyvgx.Graph( graph_name ), True",
    "        else:",
    "            raise",
    0
};



static const char *PYVGX_BUILTIN__PYVGX_vgxadmin[] = {
    "# PYVGX_vgxadmin"
    "import pyvgx",
    "import sys",
    "import os",
    "import threading",
    "import http.client",
    "import socket",
    "import json",
    "import time",
    "import random",
    "import re",
    "import getopt",
    "import pprint",
    "from io import StringIO",
    "os.environ[ \"PYVGX_NOBANNER\" ] = \"1\"",
    "DEFAULT_TIMEOUT = 90.0",
    "DISPATCH_DEFAULT_CHANNELS = 32",
    "DISPATCH_DEFAULT_PRIORITY = 2",
    "class vgxadmin__InvalidUsageOrConfig( Exception ): pass",
    "class vgxadmin__ServerError( Exception ): pass",
    "class vgxadmin__OperationIncomplete( Exception ): pass",
    "class vgxadmin__AddressError( Exception ): pass",
    "def sysplugin__TransformLegacyDescriptor( descriptor ):",
    "    \"\"\"",
    "    Transform old style descriptor to new style.",
    "    Best effort only, ingore any syntax problems.",
    "    \"\"\"",
    "    if type(descriptor) is dict:",
    "        T = descriptor.get( \"topology\" )",
    "        if type(T) is dict:",
    "            if \"transaction\" not in T and \"input\" in T:",
    "                T[\"transaction\"] = T.get(\"input\")",
    "                del T[\"input\"]",
    "            if \"dispatch\" not in T and \"search\" in T:",
    "                T[\"dispatch\"] = T.get(\"search\")",
    "                del T[\"search\"]",
    "        I = descriptor.get( \"instances\" )",
    "        G = descriptor.get( \"graphs\" )",
    "        if type(I) is dict and type(G) is list:",
    "            for ident, descr in I.items():",
    "                if type(descr) is not dict:",
    "                    continue",
    "                if \"graph\" not in descr:",
    "                    descr[\"graph\"] = \" \".join(G)",
    "def sysplugin__TransformTransactionTopology( topology ):",
    "    \"\"\"",
    "    {",
    "        \"b1\": {",
    "            \"t1\": [",
    "                \"s1\",",
    "                \"s2\",",
    "                \"s3\"",
    "            ],",
    "            \"t2\": None",
    "        }",
    "    }",
    "    \"\"\"",
    "    T = {}",
    "    items = []",
    "    if topology is None:",
    "        pass",
    "    elif type( topology ) is dict:",
    "        items = topology.items()",
    "    elif type( topology ) is list:",
    "        for item in topology:",
    "            if type( item ) is str:",
    "                items.append( (item, {}) )",
    "            elif type( item ) is list and len( item ) == 2:",
    "                items.append( (item[0], item[1]) )",
    "            else:",
    "                raise ValueError( \"invalid transaction topology\" )",
    "    else:",
    "        raise ValueError( \"invalid transaction topology\" )",
    "    for id, subT in items:",
    "        T[id] = sysplugin__TransformTransactionTopology( subT )",
    "    return T",
    "def sysplugin__ValidateSystemDescriptor( descriptor ):",
    "    \"\"\"",
    "    Validate system descriptor",
    "    \"\"\"",
    "    def valerr( attr, val=\"\", msg=\"\" ):",
    "        raise ValueError( 'System descriptor \"{}\"{} invalid or missing {}'.format( attr, val, msg ) )",
    "    def validate_name( D ):",
    "        if type(D.get(\"name\")) is not str:",
    "            valerr( \"name\" )",
    "    def validate_graphs( D ):",
    "        if \"graphs\" not in D:",
    "            D[\"graphs\"] = []",
    "        G = D.get(\"graphs\")",
    "        if type(G) is not list:",
    "            valerr( \"graphs\" )",
    "        for gname in G:",
    "            if type(gname) is not str:",
    "                valerr( \"graphs\" )",
    "    INSTANCE_NAMES = set()",
    "    def validate_instances( D ):",
    "        builder_groups = {}",
    "        host_ports = {}",
    "        G = D.get(\"graphs\")",
    "        instances = D.get(\"instances\")",
    "        if type(instances) is not dict:",
    "            valerr( \"instances\" )",
    "        for id, params in instances.items():",
    "            if id in INSTANCE_NAMES:",
    "                raise ValueError( \"System descriptor duplicate instance: {}\".format(id) )",
    "            INSTANCE_NAMES.add(id)",
    "            if type(id) is not str:",
    "                valerr( \"instances\", \": {}\".format(id) )",
    "            if type(params) is not dict:",
    "                valerr( \"instances.{}\".format(id), \": {}\" )",
    "            graph = params.get(\"graph\")",
    "            grp = params.get(\"group\")",
    "            tp = params.get(\"type\")",
    "            host = params.get(\"host\")",
    "            hport = params.get(\"hport\")",
    "            prefix = params.get(\"prefix\")",
    "            s_in = params.get(\"s-in\")",
    "            attach = params.get(\"attach\")",
    "            tport = params.get(\"tport\")",
    "            durable = params.get(\"durable\")",
    "            description = params.get(\"description\")",
    "            if graph is not None:",
    "                if type(graph) is not str:",
    "                    valerr( \"instances.{}.graph\".format(id) )",
    "                for gname in graph.split():",
    "                    if gname not in G:",
    "                        valerr( \"instances.{}.graph\".format(id), msg=\"({} is undeclared, must be one of {})\".format(gname, G) )",
    "            valid_types = [\"admin\", \"builder\", \"txproxy\", \"search\", \"dispatch\", \"generic\"]",
    "            if tp not in valid_types:",
    "                valerr( \"instances.{}.type\".format(id), msg=\"(must be one of {})\".format(valid_types) )",
    "            if grp is not None:",
    "                if type(grp) not in [int, float]:",
    "                    valerr( \"instances.{}.group\".format(id), msg=\"(numeric value required)\" )",
    "                if tp == \"builder\" and grp >= 0:",
    "                    if grp in builder_groups:",
    "                        valerr( \"instances.{}.group\".format(id), msg=\"(duplicate builder group {})\".format(grp) )",
    "                    builder_groups[grp] = id",
    "            if type(host) is not str:",
    "                valerr( \"instances.{}.host\".format(id) )",
    "            if host not in host_ports:",
    "                host_ports[host] = set()",
    "            if type(hport) is not int or hport < 1:",
    "                valerr( \"instances.{}.hport\".format(id), msg=\"(positive integer required)\" )",
    "            if hport in host_ports[host]:",
    "                valerr( \"instances.{}.hport\".format(id), msg=\"(duplicate port {} on host {})\".format(hport, host) )",
    "            host_ports[host].add( hport )",
    "            if prefix is not None:",
    "                if type(prefix) is not str:",
    "                    valerr( \"instances.{}.prefix\".format(id), msg=\"(string value required)\" )",
    "                prefix_rex = r\"^[-./0-9=@A-Z_a-z~]+$\"",
    "                if re.match( prefix_rex, prefix ) is None:",
    "                    valerr( \"instances.{}.prefix\".format(id), msg=\"(invalid characters in prefix path)\" )",
    "            if s_in is None:",
    "                params['s-in'] = s_in = False if tp in [\"search\", \"txproxy\"] else True",
    "            if type(s_in) is not bool:",
    "                valerr( \"instances.{}.s-in\".format(id), msg=\"(bool value required)\" )",
    "            if attach is None:",
    "                params['attach'] = attach = False # Never attach by default",
    "            if type(attach) is not bool:",
    "                valerr( \"instances.{}.attach\".format(id), msg=\"(bool value required)\" )",
    "            if attach:",
    "                attachable_types = [\"builder\", \"txproxy\", \"search\"]",
    "                if tp not in attachable_types:",
    "                    valerr( \"instances.{}.attach\".format(id), msg=\"(instance type {} cannot be attached)\".format(tp) )",
    "            if tport is not None and tport != 0:",
    "                if type(tport) is not int:",
    "                    valerr( \"instances.{}.tport\".format(id), msg=\"(integer required)\" )",
    "                if tport in [hport, hport+1]:",
    "                    valerr( \"instances.{}.tport\".format(id), msg=\"(cannot be same as hport or hport+1)\" )",
    "                if tport in host_ports[host]:",
    "                    valerr( \"instances.{}.tport\".format(id), msg=\"(duplicate port {} on host {})\".format(tport, host) )",
    "                host_ports[host].add( tport )",
    "            if durable:",
    "                if type(durable) is not bool:",
    "                    valerr( \"instances.{}.durable\".format(id), msg=\"(bool required)\" )",
    "                if durable is True and tport is None:",
    "                    valerr( \"instances.{}.tport\".format(id), msg=\"(tport required when durable is true)\" )",
    "            if description and type(description) is not str:",
    "                valerr( \"instances.{}.description\".format(id) )",
    "    TOPOLOGY_TRANSACTION = set()",
    "    def validate_transaction_topology( I, T, path=\"topology.transaction\", partition=None ):",
    "        if type(T) is not dict:",
    "            valerr( path )",
    "        engine_part_number = partition if partition is not None else 1",
    "        dispatch_part_number = partition if partition is not None else 1",
    "        other_part_number = partition if partition is not None else 1",
    "        for id, subT in sorted( T.items() ):",
    "            if type(id) is not str:",
    "                valerr( path, \": {}\".format(id) )",
    "            if id not in INSTANCE_NAMES:",
    "                raise ValueError( 'System descriptor topology.transaction instance \"{}\" is undefined'.format(id) )",
    "            if id in TOPOLOGY_TRANSACTION:",
    "                raise ValueError( 'System descriptor topology.transaction duplicate for instance \"{}\"'.format(id) )",
    "            TOPOLOGY_TRANSACTION.add( id )",
    "            instance = I[id]",
    "            tp = instance.get('type')",
    "            if tp == \"admin\":",
    "                prefix = 1",
    "                part = other_part_number",
    "                if partition is None:",
    "                    other_part_number += 1",
    "            elif tp == \"dispatch\":",
    "                prefix = 2",
    "                part = dispatch_part_number",
    "                if partition is None:",
    "                    dispatch_part_number += 1",
    "            elif tp in [\"builder\", \"txproxy\", \"search\"]:",
    "                prefix = 3",
    "                part = engine_part_number",
    "                if partition is None:",
    "                    engine_part_number += 1",
    "                if instance.get(\"attach\") and len(subT) == 0:",
    "                    valerr( \"instances.{}.attach\".format(id), msg=\"(no subscribers)\" )",
    "            else:",
    "                prefix = 1",
    "                part = 1",
    "            sortable_float = 1000*prefix + part/1000",
    "            instance['partition'] = \"{:.3f}\".format( sortable_float )",
    "            validate_transaction_topology( I, subT, path+\".{}\".format(id), part )",
    "    def validate_dispatch_row_params( id, replica, R ):",
    "        channels = R.get('channels', DISPATCH_DEFAULT_CHANNELS)",
    "        priority = R.get('priority', DISPATCH_DEFAULT_PRIORITY)",
    "        primary = R.get('primary', False)",
    "        partitions = R.get('partitions')",
    "        if type(channels) is not int:",
    "            raise TypeError( \"System descriptor topology.dispatch.{} replica {} 'channels' must be int\".format(id, replica) )",
    "        if channels < 1 or channels > 127:",
    "            raise ValueError( \"System descriptor topology.dispatch.{} replica {} 'channels':{} out of range\".format(id, replica, channels) )",
    "        if type(priority) is not int:",
    "            raise TypeError( \"System descriptor topology.dispatch.{} replica {} 'priority' must be int\".format(id, replica) )",
    "        if type(partitions) is list and len(partitions) == 0 and priority < 0:",
    "            pass # ok, means allow-incomplete",
    "        elif priority < 0 or priority > 127:",
    "            raise ValueError( \"System descriptor topology.dispatch.{} replica {} 'priority':{} out of range\".format(id, replica, priority) )",
    "        max_cost = priority * channels",
    "        if max_cost > 127:",
    "            raise ValueError( \"System descriptor topology.dispatch.{} replica {} max cost {} x {} = {} out of range\".format(id, replica, priority, channels, max_cost) )",
    "        if type(primary) not in [bool, int]:",
    "            raise TypeError( \"System descriptor topology.dispatch.{} replica {} 'primary' must be bool or int\".format(id, replica) )",
    "        return channels, priority, primary",
    "    def validate_dispatch_topology( I, T, path=\"topology.dispatch\" ):",
    "        if type(T) is not dict:",
    "            valerr( path )",
    "        dispatcher_number = 0",
    "        for id, cfg in sorted( T.items() ):",
    "            dispatcher_number += 1",
    "            if type(id) is not str:",
    "                valerr( path, \": {}\".format(id) )",
    "            if id not in INSTANCE_NAMES:",
    "                raise ValueError( 'System descriptor topology.dispatch instance \"{}\" is undefined'.format(id) )",
    "            if type(cfg) is dict:",
    "                partitions = set()",
    "                primary_count = 0",
    "                for engine_id, engine_cfg in cfg.items():",
    "                    if engine_id not in INSTANCE_NAMES:",
    "                        raise ValueError( 'System descriptor topology.dispatch.{} instance \"{}\" is undefined'.format(id, engine_id) )",
    "                    if type(engine_cfg) is not dict:",
    "                        raise ValueError( 'System descriptor topology.dispatch.{}.{} config must be dict'.format(id, engine_id) )",
    "                    channels, priority, primary = validate_dispatch_row_params( id, engine_id, engine_cfg )",
    "                    if primary:",
    "                        if primary_count > 0:",
    "                            raise ValueError( 'System descriptor topology.dispatch.{} row {} cannot have multiple primary'.format(id, r) )",
    "                        primary_count += 1",
    "                    engine = I[engine_id]",
    "                    part = engine.get('partition')",
    "                    partitions.add( part )",
    "                if len(partitions) == 1:",
    "                    partition = partitions.pop()",
    "                else:",
    "                    partition = \"{:.3f}\".format( 2000 + dispatcher_number/1000 )",
    "                instance = I[id]",
    "                instance['partition'] = partition",
    "            elif type(cfg) is list:",
    "                r = 0",
    "                primary_count = 0",
    "                for row in cfg:",
    "                    r += 1",
    "                    if type(row) is not dict:",
    "                        raise ValueError( 'System descriptor topology.dispatch.{} row {} config must be dict'.format(id, r) )",
    "                    partitions = row.get(\"partitions\")",
    "                    if partitions is None:",
    "                        raise ValueError( 'System descriptor topology.dispatch.{} row {} partitions missing'.format(id, r) )",
    "                    if type(partitions) is not list:",
    "                        raise ValueError( 'System descriptor topology.dispatch.{} row {} partitions must be list'.format(id, r) )",
    "                    channels, priority, primary = validate_dispatch_row_params( id, r, row )",
    "                    if primary:",
    "                        if primary_count > 0:",
    "                            raise ValueError( 'System descriptor topology.dispatch.{} row {} cannot have multiple primary'.format(id, r) )",
    "                        primary_count += 1",
    "                    for engine_id in partitions:",
    "                        if engine_id not in INSTANCE_NAMES:",
    "                            raise ValueError( 'System descriptor topology.dispatch.{} row {} partitions engine {} is undefined'.format(id, r, engine_id) )",
    "            else:",
    "                raise ValueError( 'System descriptor topology.dispatch instance \"{}\" invalid configuration'.format(id) )",
    "        next = 1",
    "        parts = {}",
    "        for id, cfg in sorted( T.items() ):",
    "            instance = I[id]",
    "            if \"partition\" in instance:",
    "                continue",
    "            if type(cfg) is list and len(cfg) == 1:",
    "                row = cfg[0]",
    "                key = \"\\t\".join(sorted( row['partitions'] ))",
    "            else:",
    "                key = id",
    "            if key not in parts:",
    "                parts[key] = next",
    "                next += 1",
    "            part = parts[key]",
    "            sortable_float = 2000 + part/1000",
    "            instance['partition'] = \"{:.3f}\".format( sortable_float )",
    "    def validate_topology( D ):",
    "        T = D.get(\"topology\")",
    "        if type(T) is not dict:",
    "            valerr( \"topology\" )",
    "        instances = D.get(\"instances\")",
    "        transaction = sysplugin__TransformTransactionTopology( T.get(\"transaction\") )",
    "        dispatch = T.get(\"dispatch\")",
    "        validate_transaction_topology( instances, transaction )",
    "        validate_dispatch_topology( instances, dispatch )",
    "    if type(descriptor) is not dict:",
    "        raise TypeError( \"System descriptor must be dict\" )",
    "    sysplugin__TransformLegacyDescriptor( descriptor )",
    "    validate_name( descriptor )",
    "    validate_graphs( descriptor )",
    "    validate_instances( descriptor )",
    "    validate_topology( descriptor )",
    "    return descriptor",
    "def sysplugin__GetTransactionTopologyInstances( descriptor=None ):",
    "    \"\"\"",
    "    Return list of tuples: [ (id, {'host':..., ...}), (id, {...}), ... ]",
    "    \"\"\"",
    "    def get_children( D, T ):",
    "        C = []",
    "        if type(T) is dict:",
    "            I = D.get(\"instances\",{})",
    "            for id in T:",
    "                instance = I.get(id)",
    "                if instance is None:",
    "                    raise KeyError( \"unknown instance '{}' in topology.transaction\".format(id) )",
    "                C.append( (str(id), instance) )",
    "            for id in T:",
    "                C.extend( get_children( D, T[id] ) )",
    "        return C",
    "    if descriptor is None:",
    "        descriptor = sysplugin__GetSystemDescriptor()",
    "    T = descriptor.get(\"topology\",{}).get(\"transaction\", {})",
    "    TT = sysplugin__TransformTransactionTopology( T )",
    "    return get_children( descriptor, TT )",
    "def sysplugin__GetDispatchTopologyInstances( descriptor=None ):",
    "    \"\"\"",
    "    Return list of tuples: [ (id, {'host':..., ...}), (id, {...}), ... ]",
    "    \"\"\"",
    "    S = set()",
    "    if descriptor is None:",
    "        descriptor = sysplugin__GetSystemDescriptor()",
    "    T = descriptor.get(\"topology\",{}).get(\"dispatch\", {})",
    "    for dispatcher_id, engines in T.items():",
    "        S.add( dispatcher_id )",
    "        if type(engines) is list:",
    "            for row in engines:",
    "                for engine_id in row.get(\"partitions\",[]):",
    "                    S.add( engine_id )",
    "        elif type(engines) is dict:",
    "            for engine_id, params in engines.items():",
    "                S.add( engine_id )",
    "    C = []",
    "    I = descriptor.get(\"instances\",{})",
    "    for id in S:",
    "        instance = I.get(id)",
    "        if instance is None:",
    "            raise KeyError( \"unknown instance '{}' in topology.dispatch\".format(id) )",
    "        C.append( (str(id), instance) )",
    "    return C",
    "class vgxadmin__VGXConsole( object ):",
    "    def __init__( self, use_stdout=True, printf=None ):",
    "        if use_stdout:",
    "            self.ostream = sys.stdout",
    "        else:",
    "            self.ostream = StringIO()",
    "        self.printf = printf",
    "    def Print( self, *obj, **kwds ):",
    "        if callable(self.printf):",
    "            S = []",
    "            if obj:",
    "                S.append( \", \".join( (repr(x) for x in obj) ) )",
    "            if kwds:",
    "                S.append( \", \".join( (\"{}={}\".format(k,v) for k,v in kwds.items()) ) )",
    "            self.printf( \", \".join(S) )",
    "        else:",
    "            print( *obj, **kwds, file=self.ostream )",
    "    def IsStdout( self ):",
    "        return self.ostream == sys.stdout",
    "    def GetStream( self ):",
    "        return self.ostream",
    "    def GetLines( self ):",
    "        if self.IsStdout():",
    "            return []",
    "        self.ostream.seek(0)",
    "        lines = [line.rstrip() for line in self.ostream.readlines()]",
    "        self.ostream.seek(0)",
    "        self.ostream.truncate()",
    "        return lines",
    "class vgxadmin__VGXRemote( object ):",
    "    HTTP_CONNECTIONS = {}",
    "    CLEANUP_THRESHOLD = 64",
    "    CLEANUP_COUNT = 16 # Clean up 1/4 of old connections",
    "    def __init__( self, host, port, name=\"\", description=\"\", console=None ):",
    "        super().__init__()",
    "        self.host = host",
    "        self.port = port",
    "        self.name = name",
    "        self.description = description",
    "        if console is None:",
    "            self.console = vgxadmin__VGXConsole()",
    "        else:",
    "            self.console = console",
    "        self.__endpoint_cache = {}",
    "        self.__nreq = 0",
    "    def __repr__( self ):",
    "        ident = \"{} {}\".format(self.name, self.description)",
    "        return \"{} - {}:{}\".format(ident, self.host, self.port)",
    "    def CleanupHTTPConnection( self, key ):",
    "        _, conn = vgxadmin__VGXRemote.HTTP_CONNECTIONS.pop( key, (None,None) )",
    "        if conn is not None:",
    "            conn.close()",
    "    def CloseHTTPConnection( self ):",
    "        key = \"{}:{}:{}\".format( self.host, self.port, threading.get_ident() )",
    "        self.CleanupHTTPConnection( key )",
    "    def CleanupHTTPConnections( self ):",
    "        if len(vgxadmin__VGXRemote.HTTP_CONNECTIONS) > vgxadmin__VGXRemote.CLEANUP_THRESHOLD:",
    "            for key, entry in sorted( vgxadmin__VGXRemote.HTTP_CONNECTIONS.items(), key=lambda x:x[1][0] )[:vgxadmin__VGXRemote.CLEANUP_COUNT]:",
    "                self.CleanupHTTPConnection( key )",
    "    def NewHTTPConnection( self, timeout=4.0, force_new=False ):",
    "        try:",
    "            self.CleanupHTTPConnections()",
    "        except Exception as err:",
    "            self.console.Print( \"ADMIN HTTPConnection cleanup failed: {}\".format(err) )",
    "        key = \"{}:{}:{:.1f}:{}\".format( self.host, self.port, timeout, threading.get_ident() )",
    "        if force_new:",
    "            self.CleanupHTTPConnection( key )",
    "        _, conn = vgxadmin__VGXRemote.HTTP_CONNECTIONS.get( key, (None,None) )",
    "        if conn is None:",
    "            conn = http.client.HTTPConnection( self.host, self.port, timeout=timeout )",
    "            vgxadmin__VGXRemote.HTTP_CONNECTIONS[key] = time.time(), conn",
    "        return conn",
    "    def SendRequest( self, path, params={}, content=None, headers={}, auto_executor=True, timeout=4.0 ):",
    "        attempts = 3",
    "        force_new = False",
    "        sleep = 0.0",
    "        while attempts > 0:",
    "            try:",
    "                conn = self.NewHTTPConnection( timeout=timeout, force_new=force_new )",
    "                if content is None:",
    "                    method = \"GET\"",
    "                else:",
    "                    method = \"POST\"",
    "                P = []",
    "                for k,v in params.items():",
    "                    P.append( \"{}={}\".format(k,v) )",
    "                pstr = \"&\".join( P)",
    "                if not path.startswith(\"/\"):",
    "                    path = \"/{}\".format( path )",
    "                if pstr:",
    "                    url = \"{}?{}\".format( path, pstr )",
    "                else:",
    "                    url = path",
    "                if auto_executor:",
    "                    headers['x-vgx-builtin-min-executor'] = attempts",
    "                conn.request( method, url, body=content, headers=headers )",
    "                response = conn.getresponse()",
    "                data = response.read()",
    "                headers = {}",
    "                for k,v in response.getheaders():",
    "                    headers[ k.lower() ] = v",
    "                if headers.get(\"content-type\",\"\").startswith(\"application/json;\"):",
    "                    data = json.loads( data )",
    "                    data = data.get(\"response\",data)",
    "                if response.status != 200:",
    "                    conn.close()",
    "                return (response.status, response.reason, data, headers)",
    "            except (http.client.NotConnected, http.client.ImproperConnectionState, socket.timeout) as cex:",
    "                attempts -= 1",
    "                timeout += 0.25",
    "                sleep += 0.1",
    "                force_new = True",
    "            except:",
    "                self.CloseHTTPConnection()",
    "                raise",
    "            time.sleep(sleep)",
    "    def RaiseServerError( self, message, exc=None, detail=None ):",
    "        error = \"{}: {} exception: {}\".format(message, self, exc)",
    "        if detail:",
    "            error = \"{} detail: {}\".format( error, detail )",
    "        raise vgxadmin__ServerError( error )",
    "    def GetAuthToken( self, retry=3 ):",
    "        if not self.Ping( retry=retry ):",
    "            raise vgxadmin__ServerError( \"Unreachable: {}\".format(self) )",
    "        response = None",
    "        E = []",
    "        for n in range(retry):",
    "            try:",
    "                response = self.SendRequest( \"/vgx/builtin/ADMIN_GetAuthToken\", headers={'accept': 'application/json'}, timeout=10.0 )",
    "                status, reason, data, headers = response",
    "                if status == 200:",
    "                    return data.get(\"authtoken\")",
    "            except Exception as err:",
    "                E.append(err)",
    "            time.sleep(0.5)",
    "        self.RaiseServerError( \"Failed to get authtoken\", E, response )",
    "    def LogCommand(self, command):",
    "        self.__nreq += 1",
    "        self.console.Print( \"[{} {}]: {}\".format( self.__nreq, self.name, command ) )",
    "    def SendAdminRequest( self, command, params={}, content=None, timeout=10.0, retry=3 ):",
    "        self.LogCommand(command)",
    "        path = \"/vgx/builtin/ADMIN_{}\".format( command )",
    "        response = None",
    "        E = []",
    "        for n in range(retry):",
    "            P = { \"authtoken\": self.GetAuthToken() }",
    "            P.update( params )",
    "            try:",
    "                response = self.SendRequest( path, params=P, content=content, headers={'accept': 'application/json'}, timeout=timeout )",
    "                status, reason, data, headers = response",
    "                if status == 200:",
    "                    return data",
    "                elif status == 500 and type(data) is dict:",
    "                    plugin = data.get(\"message\",{}).get(\"plugin\",{})",
    "                    if \"PermissionError\" in plugin.get(\"exception\",\"\") and plugin.get(\"value\",\"\").startswith(\"Expired\"):",
    "                        continue",
    "            except Exception as err:",
    "                E.append(err)",
    "            time.sleep(0.5)",
    "        self.RaiseServerError( \"Failed to send admin request\", E, response )",
    "    def HC( self, timeout=1.0, retry=1 ):",
    "        for n in range(retry):",
    "            try:",
    "                status, reason, data, headers = self.SendRequest( \"/vgx/hc\", auto_executor=False, timeout=timeout )",
    "                if status == 200 and data.startswith(b\"VGX/3\"):",
    "                    return True",
    "            except:",
    "                pass",
    "            time.sleep(0.5)",
    "        return False",
    "    def Ping( self, timeout=1.0, retry=1 ):",
    "        for n in range(retry):",
    "            try:",
    "                response = self.SendRequest( \"/vgx/ping\", headers={'accept': 'application/json'}, timeout=timeout )",
    "                status, reason, data, headers = response",
    "                if status == 200 and type(data.get(\"host\")) is dict:",
    "                    return True",
    "            except:",
    "                pass",
    "            time.sleep(0.5)",
    "        return False",
    "    def ClearEndpointCache( self ):",
    "        self.__endpoint_cache.clear()",
    "    def GetDataByKey( self, key, data, dflt ):",
    "        if key is None:",
    "            return data",
    "        if type(key) is str:",
    "            return data.get(key,dflt)",
    "        if type(key) in [list,tuple]:",
    "            for k in key:",
    "                if type(data) is not dict:",
    "                    return None",
    "                data = data.get(k,dflt)",
    "            return data",
    "        raise TypeError( key )",
    "    def Endpoint( self, path, key=None, dflt=None, params={}, cache=False, retry=3 ):",
    "        if cache and path in self.__endpoint_cache:",
    "            return self.GetDataByKey( key, self.__endpoint_cache[ path ], dflt )",
    "        response = None",
    "        E = []",
    "        for n in range(retry):",
    "            try:",
    "                response = self.SendRequest( path, params=params, headers={'accept': 'application/json'}, timeout=DEFAULT_TIMEOUT )",
    "                status, reason, data, headers = response",
    "                if status == 200:",
    "                    if cache:",
    "                        self.__endpoint_cache[ path ] = data",
    "                    elif path in self.__endpoint_cache:",
    "                        del self.__endpoint_cache[ path ]",
    "                    return self.GetDataByKey( key, data, dflt )",
    "            except Exception as err:",
    "                E.append(err)",
    "            time.sleep(0.5)",
    "        self.RaiseServerError( \"Endpoint request failed\", E, response )",
    "class vgxadmin__VGXInstance( object ):",
    "    DEFAULT_TYPE = \"generic\"",
    "    DEFAULT_HOST = \"127.0.0.1\"",
    "    def __init__( self, id, data, console=None ):",
    "        if console is None:",
    "            self.console = vgxadmin__VGXConsole()",
    "        else:",
    "            self.console = console",
    "        self.id = id",
    "        self.group = data.get(\"group\",-1)",
    "        self.graph = data.get(\"graph\")",
    "        self.graphs = self.graph.split() if self.graph else []",
    "        self.type = data.get(\"type\", vgxadmin__VGXInstance.DEFAULT_TYPE)",
    "        self.host = data.get(\"host\", vgxadmin__VGXInstance.DEFAULT_HOST)",
    "        self.ip = vgxadmin__VGXInstance.host_is_ip( self.host )",
    "        self.hport = data.get(\"hport\",0)",
    "        self.aport = self.hport + 1 if self.hport > 0 else 0",
    "        self.prefix = data.get(\"prefix\")",
    "        self.s_in = data.get(\"s-in\",False)",
    "        self.attach = data.get(\"attach\",False)",
    "        self.tport = data.get(\"tport\",0)",
    "        self.durable = data.get(\"durable\",False)",
    "        self.description = data.get(\"description\", \"{} {} at {}:{}\".format(self.type.capitalize(), self.id, self.host, self.hport) )",
    "        self.local = True",
    "        self.subscribers = {}",
    "        self.cfdispatcher = None",
    "        self.remote = vgxadmin__VGXRemote( host=self.host, port=self.aport, name=self.id, description=self.description, console=self.console )",
    "    @staticmethod",
    "    def host_is_ip( host ):",
    "        try:",
    "            octets = list( map( int, host.split(\".\") ) )",
    "            assert len( octets ) == 4",
    "            for b in octets:",
    "                assert b >= 0 and b <= 127",
    "        except:",
    "            return None",
    "        return host",
    "    def __repr__( self ):",
    "        return \"{} {}:{}\".format(self.id, self.host, self.hport)",
    "    def IsLocal( self ):",
    "        return self.local",
    "    def ExpectResultAction( self, result, action ):",
    "        if type(result) is not dict:",
    "            raise vgxadmin__OperationIncomplete( \"{}\".format(result) )",
    "        if result.get(\"action\") != action:",
    "            raise vgxadmin__OperationIncomplete( \"expected action {}, got {}\".format(action, result) )",
    "    def AddSubscriber( self, instance ):",
    "        if instance.id not in self.subscribers:",
    "            self.local = False",
    "            instance.local = False",
    "            self.subscribers[ instance.id ] = instance",
    "    def SetDispatcherConfig( self, config ):",
    "        self.cfdispatcher = config",
    "    def GetConfig( self ):",
    "        D = {",
    "            \"graph\": self.graph,",
    "            \"group\": self.group,",
    "            \"id\": self.id,",
    "            \"type\": self.type,",
    "            \"host\": self.host,",
    "            \"ip\": self.ip,",
    "            \"hport\": self.hport,",
    "            \"prefix\": self.prefix,",
    "            \"s-in\": self.s_in,",
    "            \"aport\": self.aport,",
    "            \"tport\": self.tport,",
    "            \"attach\": self.attach,",
    "            \"durable\": self.durable,",
    "            \"description\": self.description,",
    "            \"subscribers\": list(self.subscribers.keys()),",
    "            \"cfdispatcher\": self.cfdispatcher",
    "        }",
    "        return json.dumps(D, indent=4)",
    "    def HC( self, timeout=1.0 ):",
    "        return self.remote.HC( timeout=timeout )",
    "    def Descriptor( self ):",
    "        return self.remote.Endpoint( \"/vgx/builtin/system_descriptor\" )",
    "    def UpdateDescriptor( self, descriptor ):",
    "        J = json.dumps( descriptor.AsDict() )",
    "        return self.remote.SendAdminRequest( \"SystemDescriptor\", content=J )",
    "    def ClearEndpointCache( self ):",
    "        self.remote.ClearEndpointCache()",
    "    def Nodestat( self, key=None, dflt=None, cache=False ):",
    "        return self.remote.Endpoint( \"/vgx/nodestat\", key=key, dflt=dflt, cache=cache )",
    "    def Status( self, key=None, dflt=None, cache=False ):",
    "        return self.remote.Endpoint( \"/vgx/status\", key=key, dflt=dflt, cache=cache )",
    "    def WaitForIdle( self, timeout=30, idle_after_ms=5000 ):",
    "        deadline = time.time() + timeout",
    "        idle_ms = self.Nodestat( \"idle-ms\", 0 )",
    "        while idle_ms < idle_after_ms:",
    "            time.sleep(1)",
    "            idle_ms = self.Nodestat( \"idle-ms\", 0 )",
    "            if time.time() > deadline:",
    "                raise vgxadmin__OperationIncomplete( \"Instance {} is busy\".format(self) )",
    "        return \"idle\"",
    "    def Digest( self ):",
    "        return self.Nodestat( \"digest\" )",
    "    def IsReadonly( self ):",
    "        return self.Nodestat( \"readonly\" )",
    "    def IsServiceIn( self ):",
    "        return self.Nodestat( \"service-in\" ) == 1",
    "    def ServiceIn( self ):",
    "        return self.remote.SendAdminRequest( \"ServiceIn\" )",
    "    def ServiceOut( self ):",
    "        return self.remote.SendAdminRequest( \"ServiceOut\" )",
    "    def Bind( self, durable=None ):",
    "        self.WaitForIdle()",
    "        if not self.tport:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"{} undefined transaction input port\".format( self ) )",
    "        if durable is None:",
    "            durable = self.durable",
    "        result = self.remote.SendAdminRequest( \"Bind\", params={\"port\":self.tport, \"durable\":int(durable)}, timeout=DEFAULT_TIMEOUT )",
    "        self.ExpectResultAction( result, \"bind\" )",
    "        deadline = time.time() + 15",
    "        while self.Nodestat( \"txport\", 0 ) == 0:",
    "            if time.time() > deadline:",
    "                raise vgxadmin__OperationIncomplete( \"{} Bind() failed\".format(self) )",
    "            time.sleep(1)",
    "        return result",
    "    def Unbind( self):",
    "        return self.remote.SendAdminRequest( \"Unbind\", timeout=DEFAULT_TIMEOUT )",
    "    def Attach( self, sync=False, destinations=None ):",
    "        self.WaitForIdle()",
    "        if len( self.subscribers ) == 0:",
    "            return",
    "        addresses = []",
    "        if destinations is None:",
    "            destinations = self.subscribers.values()",
    "        for sub in destinations:",
    "            dest = \"{}:{}\".format( sub.host, sub.aport )",
    "            addresses.append( dest )",
    "        goal = {",
    "            \"control\": {",
    "                \"nosync\": True if sync is False else False",
    "            },",
    "            \"destinations\": addresses",
    "        }",
    "        goalJSON = json.dumps( goal )",
    "        try:",
    "            self.WaitForIdle( timeout=30 )",
    "        except Exception as err:",
    "            raise vgxadmin__OperationIncomplete( \"{}, cannot perform attach at this time\".format(err) )",
    "        return self.remote.SendAdminRequest( \"UpdateSubscribers\", content=goalJSON, timeout=DEFAULT_TIMEOUT )",
    "    def Detach( self ):",
    "        return self.remote.SendAdminRequest( \"DetachAll\", timeout=DEFAULT_TIMEOUT )",
    "    def RestartHTTP( self ):",
    "        return self.remote.SendAdminRequest( \"RestartHTTP\", timeout=DEFAULT_TIMEOUT )",
    "    def Unsubscribe( self ):",
    "        return self.remote.SendAdminRequest( \"Unsubscribe\", timeout=DEFAULT_TIMEOUT )",
    "    def OpDump( self ):",
    "        bound = self.Nodestat( \"txport\", 0 )",
    "        if bound != 0:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"Cannot dump subscriber instance {} (txport {})\".format(self, bound) )",
    "        subs = self.Nodestat( \"subscribers\", [] )",
    "        if len(subs) > 0:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"Cannot dump provider instance {} ({} subscribers)\".format(self, len(subs)) )",
    "        sysroot = self.remote.Endpoint( \"/vgx/storage\" ).get(\"sysroot\")",
    "        if sysroot is None:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"Unknown sysroot for {}\".format(self) )",
    "        ident = \"{}\".format( int(time.time()) )",
    "        uri = \"file:///{}/opdump_{}.tx\".format( sysroot, ident )",
    "        attach_result = self.remote.SendAdminRequest( \"Attach\", params={\"uri\": uri}, timeout=DEFAULT_TIMEOUT )",
    "        self.ExpectResultAction( attach_result, \"attached\" )",
    "        sync_result = self.Sync( \"hard\" )",
    "        if sync_result.get(\"status\") != \"complete\":",
    "            while self.Nodestat( \"synchronizing\", 0 ) == 1:",
    "                time.sleep(1)",
    "            sync_result[\"status\"] = \"complete\"",
    "        self.Detach()",
    "        return (attach_result, sync_result)",
    "    def Sync( self, mode ):",
    "        self.WaitForIdle()",
    "        return self.remote.SendAdminRequest( \"Sync\", params={\"mode\":mode}, timeout=DEFAULT_TIMEOUT )",
    "    def ForceCopy( self, source, destination ):",
    "        ret = None",
    "        result = source.Detach()",
    "        self.ExpectResultAction( result, \"detached\" )",
    "        result = destination.Detach()",
    "        self.ExpectResultAction( result, \"detached\" )",
    "        was_bound = False",
    "        if destination.Nodestat( \"txport\", 0 ) > 0:",
    "            result = destination.Unbind()",
    "            was_bound = True",
    "            self.ExpectResultAction( result, \"unbind\" )",
    "            time.sleep(1)",
    "        try:",
    "            result = destination.Bind( durable=False )",
    "            self.ExpectResultAction( result, \"bind\" )",
    "            uri = \"vgx://{}:{}\".format( destination.host, destination.tport )",
    "            result = source.remote.SendAdminRequest( \"Attach\", params={\"uri\": uri}, timeout=DEFAULT_TIMEOUT )",
    "            self.ExpectResultAction( result, \"attached\" )",
    "            time.sleep(1)",
    "            destination.PauseIn()",
    "            time.sleep(1)",
    "            destination.Truncate()",
    "            destination.ResumeIn()",
    "            time.sleep(1)",
    "            result = source.Sync( mode=\"soft\" )",
    "            self.ExpectResultAction( result, \"sync\" )",
    "            ret = result",
    "            deadline_sync_started = time.time() + 60.0",
    "            deadline_completion = -1",
    "            sync_started = False",
    "            sync_ended = False",
    "            sync_check_attempts = 3",
    "            try:",
    "                while destination.Digest() != source.Digest():",
    "                    time.sleep(3)",
    "                    try:",
    "                        if source.Nodestat( \"synchronizing\", 0 ) == 1:",
    "                            sync_started = True",
    "                            sync_check_attempts = 3",
    "                        elif sync_started and not sync_ended:",
    "                            sync_ended = True",
    "                            deadline_completion = time.time() + 60.0",
    "                    except Exception as err:",
    "                        if sync_started:",
    "                            if sync_check_attempts < 1:",
    "                                raise vgxadmin__OperationIncomplete( \"force copy status unknown\" )",
    "                            sync_check_attempts -= 1",
    "                    if not sync_started and time.time() > deadline_sync_started:",
    "                        if sync_check_attempts < 1:",
    "                            raise vgxadmin__OperationIncomplete( \"unable to start force copy sync\" )",
    "                        sync_check_attempts -= 1",
    "                    if sync_ended and time.time() > deadline_completion:",
    "                        raise vgxadmin__OperationIncomplete( \"force copy sync is incomplete / inconsistent\" )",
    "            except Exception as err:",
    "                self.console.Print( err )",
    "            result = source.Detach()",
    "            self.ExpectResultAction( result, \"detached\" )",
    "            if destination.Digest() != source.Digest():",
    "                raise vgxadmin__OperationIncomplete( \"digest mismatch after force copy sync attempt\" )",
    "        finally:",
    "            if not was_bound:",
    "                try:",
    "                    result = destination.Unbind()",
    "                    self.ExpectResultAction( result, \"unbind\" )",
    "                except Exception as uerr:",
    "                    self.console.Print( \"{} Unbind() error {}\".format(destination, uerr) )",
    "        return ret",
    "    def ReverseSync( self ):",
    "        self.WaitForIdle()",
    "        selected_sub = None",
    "        sn = -1",
    "        for sub in self.subscribers.values():",
    "            sub_sn = int( sub.Nodestat( \"master-serial\", 0 ) )",
    "            if sub_sn > sn:",
    "                selected_sub = sub",
    "                sn = sub_sn",
    "        return self.ForceCopy( source=selected_sub, destination=self )",
    "    def CancelSync( self ):",
    "        return self.remote.SendAdminRequest( \"CancelSync\", timeout=DEFAULT_TIMEOUT )",
    "    def RollingForwardSync( self ):",
    "        \"\"\"",
    "        Perform rolling update of subscribers",
    "        \"\"\"",
    "        ret = {}",
    "        S_IN_PRE = set()",
    "        S_RO = []",
    "        for sub in self.subscribers.values():",
    "            if sub.IsReadonly():",
    "                S_RO.append( sub.id )",
    "            try:",
    "                if sub.HC():",
    "                    S_IN_PRE.add(sub.id)",
    "            except Exception as hcerr:",
    "                self.console.Print( \"{}: {}\".format(sub, hcerr) )",
    "        if len(S_IN_PRE) < 2:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"Too few S-IN destinations for automatic rolling update\" )",
    "        if len(S_RO) > 0:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"Readonly destinations exist: {}\".format( sub ) )",
    "        self.WaitForIdle()",
    "        nodestat = self.Nodestat()",
    "        target_size = nodestat['graph-size']",
    "        target_order = nodestat['graph-order']",
    "        reattach_when_done = True if len( nodestat.get(\"subscribers\") ) > 0 else False",
    "        resume_tx_in_when_done = False if nodestat.get(\"tx-in-halted\") is True else True",
    "        self.PauseIn()",
    "        self.Detach()",
    "        for sub in self.subscribers.values():",
    "            pre_digest = sub.Digest()",
    "            pre_s_in = sub.IsServiceIn()",
    "            try:",
    "                sub.WaitForIdle()",
    "                sub.ServiceOut()",
    "                r = self.ForceCopy( source=self, destination=sub )",
    "                sub_nodestat = sub.Nodestat()",
    "                assert sub_nodestat['graph-size'] == target_size",
    "                assert sub_nodestat['graph-order'] == target_order",
    "                if sub.id in S_IN_PRE:",
    "                    sub.ServiceIn()",
    "                    time.sleep(5) # 1 second is enough, wait longer to be safe",
    "                ret[sub.id] = r",
    "            except Exception as err:",
    "                if pre_s_in:",
    "                    if sub.Digest() == pre_digest:",
    "                        sub.ServiceIn()",
    "                    else:",
    "                        self.console.Print( \"Destination digest changes, unable to restore S-IN\" )",
    "                raise",
    "            finally:",
    "                pass",
    "        if reattach_when_done:",
    "            self.Attach()",
    "        if resume_tx_in_when_done:",
    "            self.ResumeIn()",
    "        return ret",
    "    def Persist( self ):",
    "        return self.remote.SendAdminRequest( \"Persist\", timeout=DEFAULT_TIMEOUT )",
    "    def Truncate( self ):",
    "        return self.remote.SendAdminRequest( \"Truncate\", timeout=DEFAULT_TIMEOUT )",
    "    def PauseIn( self ):",
    "        return self.remote.SendAdminRequest( \"SuspendTxInput\", timeout=DEFAULT_TIMEOUT )",
    "    def ResumeIn( self ):",
    "        return self.remote.SendAdminRequest( \"ResumeTxInput\", timeout=DEFAULT_TIMEOUT )",
    "    def PauseOut( self ):",
    "        return self.remote.SendAdminRequest( \"SuspendTxOutput\", timeout=DEFAULT_TIMEOUT )",
    "    def ResumeOut( self ):",
    "        return self.remote.SendAdminRequest( \"ResumeTxOutput\", timeout=DEFAULT_TIMEOUT )",
    "    def PauseTTL( self ):",
    "        return self.remote.SendAdminRequest( \"SuspendEvents\", timeout=DEFAULT_TIMEOUT )",
    "    def ResumeTTL( self ):",
    "        return self.remote.SendAdminRequest( \"ResumeEvents\", timeout=DEFAULT_TIMEOUT )",
    "    def ReadonlyGraph( self ):",
    "        return self.remote.SendAdminRequest( \"SetReadonly\", timeout=DEFAULT_TIMEOUT )",
    "    def WritableGraph( self ):",
    "        return self.remote.SendAdminRequest( \"ClearReadonly\", timeout=DEFAULT_TIMEOUT )",
    "    def ResetMetrics( self ):",
    "        return self.remote.SendAdminRequest( \"ResetMetrics\", timeout=DEFAULT_TIMEOUT )",
    "    def ReloadPlugins( self, plugins_json=None ):",
    "        if plugins_json is None:",
    "            return self.remote.SendAdminRequest( \"ReloadPlugins\", timeout=DEFAULT_TIMEOUT )",
    "        else:",
    "            return self.remote.SendAdminRequest( \"ReloadPlugins\", content=plugins_json, timeout=DEFAULT_TIMEOUT )",
    "    def Command( self, gr, cmd ):",
    "        return self.remote.SendAdminRequest( \"Console\", params={\"graph\":gr}, content=cmd, timeout=DEFAULT_TIMEOUT )",
    "    def Throttle( self, rate, unit ):",
    "        return self.remote.SendAdminRequest( \"Throttle\", params={\"rate\":float(rate), \"unit\":unit}, timeout=DEFAULT_TIMEOUT )",
    "    def Shutdown( self ):",
    "        params = {",
    "            \"authshutdown\": self.remote.GetAuthToken(),",
    "            \"persist\": int(self.durable)",
    "        }",
    "        return self.remote.SendAdminRequest( \"Shutdown\", params=params )",
    "class vgxadmin__Descriptor( object ):",
    "    \"\"\"",
    "    vgx.cf format (JSON):",
    "    {",
    "        \"name\": <str>,                      // <str> = System name",
    "        \"graphs\": [ <str>, ... ],           // <str> = Name of graph instance",
    "        \"instances\": {",
    "            <id>: {                         // <id> = Unique instance identifier string, e.g. \"S1\" for searcher 1",
    "                \"graph\": <str>,             // <str> = Name of graph for this instance",
    "                \"group\": <float>,           // <float> = Display group number",
    "                \"type\": <str>,              // <str> in \"builder\", \"txproxy\", \"search\", \"dispatch\", \"admin\", \"generic\"",
    "                \"host\": <str>,              // <str> = Host name or IP",
    "                \"hport\": <int>,             // <int> = Instance HTTP main port",
    "                \"tport\": <int>,             // <int> = Instance transaction input port (default: 0)",
    "                \"durable\": <bool>,          // <bool> = true to enable TX-log, false for no TX-log",
    "                \"description\": <str>        // <str> = Optional instance description",
    "            },",
    "            ...                             // ... All instances must be defined",
    "        },",
    "        \"common\" : {",
    "            \"prefix\": <str>,                // <str> = Instance HTTP path prefix",
    "        },",
    "        \"topology\": {",
    "            \"transaction\": {",
    "                <id>: {                     // Transaction interconnect configuration",
    "                    <id>: {                 // can be of any depth, but loops are not allowed",
    "                        <id>: {             // for obvious reasons",
    "                            ...",
    "                        },",
    "                        ...",
    "                    },",
    "                    ...",
    "                }",
    "            },",
    "            \"dispatch\": {",
    "                <id>: {                     // <id> = Instance of type \"dispatch\"",
    "                    <id>: {                 // <id> = Instance of type \"dispatch\" or \"search\"",
    "                        \"channels\": <int>,  // <int> = Number of allowed socket connections into this instance",
    "                        \"priority\": <int>,  // <int> = Lower value receives more traffic than higher value",
    "                        \"primary\": <bool>   // <bool> = true means instance allows data injection",
    "                    },",
    "                    ...",
    "                },",
    "                ...                         // Any number of dispatchers allowed",
    "            }",
    "        }",
    "    }",
    "    EXAMPLE:",
    "    {",
    "        \"name\": \"Test system 1\",",
    "        \"graphs\": [\"g1\"],",
    "        \"instances\": {",
    "            \"d1\": { \"graph\": \"g1\", \"group\": 1, \"type\": \"dispatch\", \"host\": \"10.130.30.102\",  \"hport\": 9910,                                    \"description\": \"Dispatcher 1\" },",
    "            \"b1\": { \"graph\": \"g1\", \"group\": 2, \"type\": \"builder\",  \"host\": \"10.130.30.102\",  \"hport\": 9010,  \"tport\": 10010,                   \"description\": \"Builder 1\" },",
    "            \"t1\": { \"graph\": \"g1\", \"group\": 2, \"type\": \"txproxy\",  \"host\": \"10.130.30.102\",  \"hport\": 9110,  \"tport\": 10110, \"durable\": true,  \"description\": \"TXProxy 1\" },",
    "            \"s1\": { \"graph\": \"g1\", \"group\": 3, \"type\": \"search\",   \"host\": \"10.130.30.102\",  \"hport\": 9210,  \"tport\": 10210,                   \"description\": \"Search 1\" },",
    "            \"s2\": { \"graph\": \"g1\", \"group\": 3, \"type\": \"search\",   \"host\": \"10.130.30.102\",  \"hport\": 9220,  \"tport\": 10220,                   \"description\": \"Search 2\" },",
    "            \"s3\": { \"graph\": \"g1\", \"group\": 3, \"type\": \"search\",   \"host\": \"10.130.30.102\",  \"hport\": 9230,  \"tport\": 10230,                   \"description\": \"Search 3\" }",
    "        },",
    "        \"common\": {",
    "            \"prefix\": \"myservice\"",
    "        },",
    "        \"topology\": {",
    "            \"transaction\": {",
    "                \"b1\": {",
    "                    \"t1\": {",
    "                        \"s1\": {},",
    "                        \"s2\": {},",
    "                        \"s3\": {}",
    "                    }",
    "                }",
    "            },",
    "            \"dispatch\": {",
    "                \"d1\": {",
    "                    \"s1\": { \"channels\": 32, \"priority\": 1 },",
    "                    \"s2\": { \"channels\": 32, \"priority\": 1 },",
    "                    \"s3\": { \"channels\": 32, \"priority\": 1 }",
    "                }",
    "            }",
    "        }",
    "    }",
    "    \"\"\"",
    "    def __init__( self, descriptor, remote=None, console=None, printf=None ):",
    "        if console is None:",
    "            self.console = vgxadmin__VGXConsole( printf=printf )",
    "        else:",
    "            self.console = console",
    "        self.data = \"\"",
    "        self.name = \"\"",
    "        self.instances = {}",
    "        self.transaction_topology = {}",
    "        self.dispatch_topology = {}",
    "        self.graphs = []",
    "        self.remote = remote",
    "        self.Reload( descriptor )",
    "    def AsDict( self ):",
    "        I = {}",
    "        for instance in self.instances.values():",
    "            I[instance.id] = {",
    "                \"group\": instance.group,",
    "                \"type\": instance.type,",
    "                \"host\": instance.host,",
    "                \"hport\": instance.hport,",
    "                \"tport\": instance.tport,",
    "                \"durable\": instance.durable,",
    "                \"description\": instance.description",
    "            }",
    "        D = {",
    "            \"name\": self.name,",
    "            \"instances\": I,",
    "            \"topology\": {",
    "                \"transaction\": self.transaction_topology,",
    "                \"dispatch\": self.dispatch_topology",
    "            },",
    "            \"graphs\": self.graphs",
    "        }",
    "        return D",
    "    def __repr__( self ):",
    "        buffer = StringIO()",
    "        pprint.pprint( self.AsDict(), stream=buffer, indent=2 )",
    "        buffer.seek(0)",
    "        return buffer.getvalue()",
    "    def _process_transaction_topology( self, topology ):",
    "        \"\"\"",
    "        {",
    "            \"b1\": {",
    "                \"t1\": {",
    "                    \"s1\": {},",
    "                    \"s2\": {},",
    "                    \"s3\": {}",
    "                },",
    "                \"t2\": {}",
    "            }",
    "        }",
    "        \"\"\"",
    "        I = []",
    "        for id, T in topology.items():",
    "            instance = self.Get( id )",
    "            I.append( instance )",
    "            for sub_instance in self._process_transaction_topology( T ):",
    "                instance.AddSubscriber( sub_instance )",
    "        return I",
    "    @staticmethod",
    "    def _replicas_append_row_params( replicas, params ):",
    "        entry = {",
    "            \"channels\": int( params.get(\"channels\", DISPATCH_DEFAULT_CHANNELS) ),",
    "            \"priority\": int( params.get(\"priority\", DISPATCH_DEFAULT_PRIORITY) )",
    "        }",
    "        if bool( params.get(\"primary\", False ) ): # i.e. writable",
    "            entry[\"primary\"] = True",
    "        replicas.append( entry )",
    "    def _get_engine_params( self, engine_id ):",
    "        engine = self.Get( engine_id )",
    "        return {",
    "            \"host\": engine.host,",
    "            \"port\": engine.hport",
    "        }",
    "    def _process_dispatch_topology( self, topology ):",
    "        \"\"\"",
    "        Replicas only:",
    "        {",
    "            \"d1\": {",
    "                \"s1\": { \"channels\": 32, \"priority\": 1 },",
    "                \"s2\": { \"channels\": 32, \"priority\": 1 },",
    "                \"s3\": { \"channels\": 32, \"priority\": 1 }",
    "            },",
    "            \"d2\": {",
    "                \"s1\": { \"channels\": 32, \"priority\": 1 },",
    "                \"s2\": { \"channels\": 32, \"priority\": 1 },",
    "                \"s3\": { \"channels\": 32, \"priority\": 1 }",
    "            },",
    "            \"d3\": {",
    "                \"d1\": { \"channels\": 64, \"priority\": 1 },",
    "                \"d2\": { \"channels\": 64, \"priority\": 1 }",
    "            }",
    "        }",
    "        With partitions:",
    "        {",
    "            \"d1\": [",
    "                { \"channels\": 32, \"priority\": 1, \"description\": \"ROW1\",",
    "                  \"partitions\": [\"s1.1\", \"s2.1\", \"s3.1\"]",
    "                },",
    "                { \"channels\": 32, \"priority\": 1, \"description\": \"ROW2\",",
    "                  \"partitions\": [\"s1.2\", \"s2.2\", \"s3.2\"]",
    "                }",
    "            ]",
    "        }",
    "        Configure internal dispatcher config for a single partition,",
    "        from the partition's descriptor.",
    "        \"\"\"",
    "        def get_partition( partitions, p ):",
    "            try:",
    "                return partitions[p]",
    "            except IndexError:",
    "                partition = []",
    "                partitions.append( partition )",
    "                return partition",
    "        for dispatcher_id, T in topology.items():",
    "            dispatcher = self.Get( dispatcher_id )",
    "            options = {}",
    "            replicas = []",
    "            partitions = []",
    "            config = {",
    "                \"options\"   : options,",
    "                \"replicas\"  : replicas,",
    "                \"partitions\": partitions",
    "            }",
    "            if type(T) is list:",
    "                for row in T:",
    "                    partition_ids = row.get( \"partitions\", [] )",
    "                    row_priority = row.get( \"priority\", 0 )",
    "                    if row_priority < 0 and partition_ids == []:",
    "                        options[\"allow-incomplete\"] = True",
    "                        continue",
    "                    vgxadmin__Descriptor._replicas_append_row_params( replicas, row )",
    "                    p = 0",
    "                    for engine_id in partition_ids:",
    "                        engine = self._get_engine_params( engine_id )",
    "                        partition = get_partition( partitions, p )",
    "                        p += 1",
    "                        partition.append( engine )",
    "            elif type(T) is dict:",
    "                partition = get_partition( partitions, 0 )",
    "                for engine_id, engine_params in T.items():",
    "                    vgxadmin__Descriptor._replicas_append_row_params( replicas, engine_params )",
    "                    engine = self._get_engine_params( engine_id )",
    "                    partition.append( engine )",
    "            else:",
    "                raise vgxadmin__InvalidUsageOrConfig( \"bad topology for dispatcher {}\".format( dispatcher_id ) )",
    "            dispatcher.SetDispatcherConfig( config )",
    "    def Reload( self, descriptor ):",
    "        if type(descriptor) is dict:",
    "            self.data = descriptor",
    "        else:",
    "            f = open( descriptor )",
    "            try:",
    "                self.data = json.loads( f.read() )",
    "            finally:",
    "                f.close()",
    "        sysplugin__TransformLegacyDescriptor( self.data )",
    "        name = self.data.get(\"name\")",
    "        graphs = self.data.get(\"graphs\")",
    "        instances = self.data.get(\"instances\")",
    "        common = self.data.get(\"common\", {})",
    "        topology = self.data.get(\"topology\", {})",
    "        if name and type(name) is not str:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"name must be str, got {}\".format(type(name)) )",
    "        if type(graphs) is not list:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"graphs must be list, got {}\".format(type(graphs)) )",
    "        if type(instances) is not dict:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"instances must be dict, got {}\".format(type(instances)) )",
    "        if type(common) is not dict:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"common must be dict, got {}\".format(type(common)) )",
    "        if type(topology) is not dict:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"topology must be dict, got {}\".format(type(topology)) )",
    "        for instance in instances.values():",
    "            if type( instance ) is dict:",
    "                for k,v in common.items():",
    "                    if k not in instance:",
    "                        instance[k] = v",
    "        sysplugin__ValidateSystemDescriptor( self.data )",
    "        self.name = name if name else \"Unspecified {}-node System\".format(len(instances))",
    "        self.graphs = graphs",
    "        TT = sysplugin__GetTransactionTopologyInstances( self.data )",
    "        DT = sysplugin__GetDispatchTopologyInstances( self.data )",
    "        A = set( [id for id,_ in TT] ).union( set( [id for id,_ in DT] ) )",
    "        self.transaction_topology = sysplugin__TransformTransactionTopology( topology.get(\"transaction\",{}) )",
    "        self.dispatch_topology = topology.get(\"dispatch\",{})",
    "        if not instances:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"at least one instance required\" )",
    "        self.instances = {}",
    "        for id, entry in instances.items():",
    "            instance = vgxadmin__VGXInstance( id=id, data=entry, console=self.console )",
    "            self.instances[id] = instance",
    "            if id not in A:",
    "                self.transaction_topology[id] = {}",
    "        self._process_transaction_topology( self.transaction_topology )",
    "        self._process_dispatch_topology( self.dispatch_topology )",
    "    def Get( self, id ):",
    "        instance = None",
    "        if id == \".\" and self.remote:",
    "            for entry in self.instances.values():",
    "                if entry.aport == self.remote.port and entry.host == self.remote.host:",
    "                    instance = entry",
    "        elif \"*\" in id:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"Wildcard not allowed for this operation\" )",
    "        else:",
    "            instance = self.instances.get(id)",
    "        if instance is None:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"Unknown instance id: {}\".format(id) )",
    "        return instance",
    "    def PrintSummary( self, instances, detail=False ):",
    "        def isnum( value ):",
    "            try:",
    "                float(value.replace(\",\",\"\"))",
    "                return True",
    "            except:",
    "                return False",
    "        def prepad( value, pad ):",
    "            return pad if isnum( value ) else \"\"",
    "        def postpad( value, pad ):",
    "            return \"\" if isnum( value ) else pad",
    "        def fmt( value ):",
    "            s = \"{}\".format( value )",
    "            if isnum(s) and not s.isdigit():",
    "                return \"{:.1f}\".format( float(s) )",
    "            else:",
    "                return s",
    "        def fmt_mem_gib( value ):",
    "            return \"{:,}\".format( value//(1<<30) )",
    "        def fmt_mem_mib( value ):",
    "            return \"{:,}\".format( value//(1<<20) )",
    "        def fmt_sin( value ):",
    "            return \"S-IN\" if value > 0 else \"S-OUT\"",
    "        def fmt_dhms( value ):",
    "            s = value",
    "            D = s // 86400",
    "            s -= D*86400",
    "            H = s // 3600",
    "            s -= H*3600",
    "            M = s // 60",
    "            s -= M*60",
    "            return \"{}d {:02d}:{:02d}:{:02d}\".format( D, H, M, s )",
    "        def fmt_flt( value ):",
    "            return \"{:.1f}\".format( float(value) )",
    "        def fmt_int( value ):",
    "            return \"{:,}\".format( value )",
    "        include_level = 1 if detail else 0",
    "        allitems = [",
    "                  (0, \"Id\",        \"Nodestat\", None,                   None),",
    "                  (0, \"Uptime\",    \"Nodestat\", \"uptime\",               fmt_dhms),",
    "                  (0, \"Host\",      \"Nodestat\", \"host\",                 fmt),",
    "                  (0, \"IP\",        \"Nodestat\", \"ip\",                   fmt),",
    "                  (0, \"APort\",     \"Nodestat\", \"adminport\",            fmt),",
    "                  (1, \"TXPort\",    \"Nodestat\", \"txport\",               fmt),",
    "                  (0, \"S\",         \"Status\",   [\"request\",\"serving\"],  fmt_sin),",
    "                  (1, \"RPS\",       \"Status\",   [\"request\",\"rate\"],     fmt_flt),",
    "                  (1, \"95th(ms)\",  \"Status\",   [\"response_ms\",\"95.0\"], fmt_flt),",
    "                  (1, \"CPU\",       \"Nodestat\", \"cpu\",                  fmt),",
    "                  (1, \"Mem(GiB)\",  \"Nodestat\", \"memory-total\",         fmt_mem_gib),",
    "                  (1, \"Use(MiB)\",  \"Nodestat\", \"memory-process\",       fmt_mem_mib),",
    "                  (0, \"Order\",     \"Nodestat\", \"graph-order\",          fmt_int),",
    "                  (0, \"Size\",      \"Nodestat\", \"graph-size\",           fmt_int),",
    "                  (0, \"Service\",   \"Nodestat\", \"service-name\",         fmt)",
    "                ]",
    "        items = []",
    "        for level, label, method, key, render in allitems:",
    "            if level > include_level:",
    "                continue",
    "            items.append( [label, method, key, render] )",
    "        info = {}",
    "        info[None] = [[str(label), \"\"] for label,m,k,r in items]",
    "        N = len( instances )",
    "        for instance in instances:",
    "            N -= 1",
    "            if self.console.IsStdout():",
    "                if N > 0:",
    "                    self.console.Print(\"\\r{:3d} {}\".format(N, instance.id), end=\"\", flush=True )",
    "                else:",
    "                    self.console.Print(\"\\r{:32}\".format(''), flush=True )",
    "            info[instance.id] = []",
    "            try:",
    "                instance.HC( timeout=0.1 )",
    "                running = True",
    "            except:",
    "                running = False",
    "            instance.ClearEndpointCache()",
    "            for label, method, key, render in items:",
    "                if key is None:",
    "                    val = instance.id",
    "                else:",
    "                    if running and render:",
    "                        data = getattr( instance, method )( key, cache=True )",
    "                        val = render( data if data is not None else \"?\" )",
    "                    else:",
    "                        val = \"\"",
    "                info[instance.id].append( [val, \"\"] )",
    "            instance.ClearEndpointCache()",
    "        for pos in range(len(items)):",
    "            maxsz = 0",
    "            for id, data in info.items():",
    "                sz = len(data[pos][0])",
    "                if sz > maxsz:",
    "                    maxsz = sz",
    "            for id, data in info.items():",
    "                sz = len(data[pos][0])",
    "                data[pos][1] = \" \" * (maxsz - sz)",
    "        line = \"  \".join( [ \"-\" * (len(value)+len(pad)) for value, pad in info[None] ] )",
    "        self.console.Print(line)",
    "        for id, data in info.items():",
    "            cols = \"  \".join( [ \"{}{}{}\".format(prepad(value,pad), value, postpad(value,pad)) for value, pad in data ] )",
    "            self.console.Print( cols )",
    "            if id is None:",
    "                self.console.Print(line)",
    "        self.console.Print(line)",
    "    def GetMultiple( self, id=\"*\", ifrunning=True, printsum=False, detail=False, confirm=None ):",
    "        if confirm is not None and not self.console.IsStdout():",
    "            raise Exception( \"Operation not allowed\" )",
    "        if id == \"*\" or id == \"@\":",
    "            I = self.instances.values()",
    "        elif \"*\" in id or \"[\" in id:",
    "            patt = id.replace( \".\", r\"\\.\" ).replace( \"*\", \".*\" )",
    "            rex = re.compile( patt )",
    "            I = []",
    "            for instance in self.instances.values():",
    "                if rex.match( instance.id ):",
    "                    I.append( instance )",
    "        elif id in self.instances:",
    "            I = [self.Get( id )]",
    "        else:",
    "            I = [self.Get(x.strip()) for x in id.split(\",\")]",
    "        running = []",
    "        if ifrunning or confirm:",
    "            for instance in I:",
    "                try:",
    "                    instance.HC( timeout=0.51 )",
    "                    running.append( instance )",
    "                except:",
    "                    self.console.Print( \"Not running: {}\".format( instance.id ) )",
    "        if I:",
    "            if printsum:",
    "                self.PrintSummary( I, detail=detail )",
    "            if confirm and running:",
    "                ids = [instance.id for instance in running]",
    "                answer = input( \"Confirm {}: {} (y/n) \".format(confirm, ids) )",
    "                if answer != 'y':",
    "                    return []",
    "        if ifrunning:",
    "            return running",
    "        else:",
    "            return I",
    "    def Start( self, id=\"*\" ):",
    "        rdname = \"tmp_{}{}\".format( int(time.time()*1000), random.randint( 1<<28, 1<<63 ) )",
    "        f = open( rdname, \"w\" )",
    "        try:",
    "            f.write( json.dumps(self.data), indent=4 )",
    "            f.close()",
    "            f = None",
    "            R = []",
    "            for instance in self.GetMultiple( id, ifrunning=False ):",
    "                try:",
    "                    instance.Nodestat()",
    "                    self.console.Print( \"Already running: {}\".format( instance.id ) )",
    "                    continue",
    "                except:",
    "                    pass",
    "                cmd = \"python -m vgxinstance {} {}\".format( instance.id, rdname )",
    "                self.console.Print( \"Starting: {}\".format( instance.id ) )",
    "                time.sleep(1)",
    "                if sys.platform.startswith(\"win\"):",
    "                    os.system( \"start /MIN {}\".format( cmd ) )",
    "                else:",
    "                    os.system( \"{} &\".format( cmd ) )",
    "                R.append( (instance, \"Start\") )",
    "        finally:",
    "            if f is not None:",
    "                f.close()",
    "    @staticmethod",
    "    def _target( method, instance, console, lock, R, args ):",
    "        try:",
    "            try:",
    "                ret = method( *args )",
    "            except Exception as err:",
    "                if lock.acquire( timeout=2.0 ):",
    "                    try:",
    "                        console.Print(err)",
    "                    finally:",
    "                        lock.release()",
    "                ret = err",
    "            if lock.acquire( timeout=2.0 ):",
    "                try:",
    "                    R.append( (instance, ret) )",
    "                finally:",
    "                    lock.release()",
    "        except:",
    "            pass",
    "    def Concurrent( self, method_name, id=\"*\", args=() ):",
    "        lock = threading.RLock()",
    "        R = []",
    "        W = []",
    "        if type(id) is str:",
    "            instances = self.GetMultiple( id )",
    "        elif type(id) is list:",
    "            instances = []",
    "            for entry in id:",
    "                if type(entry) is str:",
    "                    instances.append( self.Get(entry) )",
    "                elif type(entry) is vgxadmin__VGXInstance:",
    "                    instances.append( entry )",
    "                else:",
    "                    raise vgxadmin__InvalidUsageOrConfig( \"Invalid identifier for concurrent operation: {} {}\".format( type(entry), entry ) )",
    "        else:",
    "            raise vgxadmin__InvalidUsageOrConfig( \"Invalid identifier for concurrent operation: {} {}\".format( type(id), id ) )",
    "        for instance in instances:",
    "            method = getattr( instance, method_name )",
    "            w = threading.Thread( target=self._target, args=(method, instance, self.console, lock, R, args) )",
    "            W.append( w )",
    "        for w in W:",
    "            w.start()",
    "        while len([1 for w in W if w.is_alive()]) > 0:",
    "            time.sleep(0.5)",
    "        for w in W:",
    "            w.join( timeout=1.0 )",
    "        return R",
    "class vgxadmin__VGXAdmin( object ):",
    "    @staticmethod",
    "    def Usage( err=None, program=\"vgxadmin\", console=None ):",
    "        if console is None:",
    "            console = vgxadmin__VGXConsole()",
    "        else:",
    "            console = console",
    "        console.Print()",
    "        console.Print( \"usage: {} [<address|id>] <options>\".format( program ) )",
    "        console.Print( \"-a, --attach <id>[,<sub>[,...]] Attach instance to subscribers\" )",
    "        console.Print( \"-B, --bind <id>                 Bind transaction input port\" )",
    "        console.Print( \"-c, --confirm                   Confirm operation (skip y/n prompt)\" )",
    "        console.Print( \"-C, --command <id>,<gr>,<cmd>   Send console command <cmd> to graph <gr>\" )",
    "        console.Print( \"-d, --detach <id>               Detach instance from subscribers\" )",
    "        console.Print( \"-D, --restarthttp <id>          Restart HTTP server with refreshed config\" )",
    "        console.Print( \"-E, --endpoint <path>           Send request to <address>\" )",
    "        console.Print( \"-f, --cf <file>                 Use this local system descriptor file\" )",
    "        console.Print( \"-g, --readonly <id>             Make graph(s) readonly\" )",
    "        console.Print( \"-G, --writable <id>             Make graph(s) writable\" )",
    "        console.Print( \"-i, --serviceout <id>           Service out\" )",
    "        console.Print( \"-I, --servicein <id>            Service in\" )",
    "        console.Print( \"-J, --show                      Show effective system descriptor\" )",
    "        console.Print( \"-k, --cancelsync <id>           Terminate sync in progress\" )",
    "        console.Print( \"-K, --forcecopy <src>,<dst>     Force hard sync from <src> to <dst>\" )",
    "        console.Print( \"-L, --rollingupdate <id>        Forward sync subscribers one at a time in S-OUT\" )",
    "        console.Print( \"-m, --resetmetrics <id>         Clear performance and error counters\" )",
    "        console.Print( \"-M, --opdump <id>               Dump instance data to output file\" )",
    "        console.Print( \"-n, --nodestat <id>[,<key>]     Nodestat\" )",
    "        console.Print( \"-N, --reloadplugins <id>[,<pd>] Reload or add plugins in <pd> json file\" )",
    "        console.Print( \"-p, --pausein <id>              Pause transaction input\" )",
    "        console.Print( \"-P, --pauseout <id>             Pause transaction output\" )",
    "        console.Print( \"-Q, --instancecfg <id>          Show instance configuration\" )",
    "        console.Print( \"-r, --resumein <id>             Resume transaction input\" )",
    "        console.Print( \"-R, --resumeout <id>            Resume transaction output\" )",
    "        console.Print( \"-s, --start <id>                Start instance on the local host\" )",
    "        console.Print( \"-S, --status <id>               System summary\" )",
    "        console.Print( \"-t, --pausettl <id>             Pause TTL event processor\" )",
    "        console.Print( \"-T, --resumettl <id>            Resume TTL event processor (if enabled)\" )",
    "        console.Print( \"-u, --unsubscribe <id>          Detach instance from provider\" )",
    "        console.Print( \"-U, --unbind <id>               Unbind transaction input port\" )",
    "        console.Print( \"-V, --throttle <id>[,<r>,<u>]   Throttle TX input rate <r>, unit <u>\" )",
    "        console.Print( \"-w, --waitforidle <id>          Wait until instance input is idle\" )",
    "        console.Print( \"-W, --persist <id>              Write instance data to disk\" )",
    "        console.Print( \"-x, --stop <id>                 Stop instance\" )",
    "        console.Print( \"-X, --truncate <id>             Erase instance data\" )",
    "        console.Print( \"-y, --sync <id>[,<mode>]        Sync instance data to attached subscribers\" )",
    "        console.Print( \"                                <mode>: [repair|hard|soft]\" )",
    "        console.Print( \"-Y, --reversesync <id>          Reverse sync instance data from attached subscriber\" )",
    "        console.Print( \"-Z, --descriptor <id>           Update instance system descriptor\" )",
    "        console.Print()",
    "        if err is not None:",
    "            console.Print( \"ERROR: {}\".format(err) )",
    "            console.Print()",
    "    @staticmethod",
    "    def GetArgs( a, dflt ):",
    "        A = [ x.strip() for x in a.split(\",\",len(dflt)-1) ]",
    "        A.extend( dflt[ len(A): ] )",
    "        return A",
    "    @staticmethod",
    "    def Run( arguments, address=None, program=\"vgxadmin\", print_to_stdout=True, default_descriptor_filename=None ):",
    "        if type(arguments) is str:",
    "            arguments = arguments.split()",
    "        console = vgxadmin__VGXConsole( print_to_stdout )",
    "        RESULT = []",
    "        try:",
    "            paramdef = [",
    "                    (\"attach=\",          \"a:\"),",
    "                    (\"bind=\",            \"B:\"),",
    "                    (\"confirm\",          \"c\" ),",
    "                    (\"command=\",         \"C:\"),",
    "                    (\"detach=\",          \"d:\"),",
    "                    (\"restarthttp=\",     \"D:\"),",
    "                    (\"endpoint=\",        \"E:\"),",
    "                    (\"cf=\",              \"f:\"),",
    "                    (\"readonly=\",        \"g:\"),",
    "                    (\"writable=\",        \"G:\"),",
    "                    (\"help\",             \"h\" ),",
    "                    (\"serviceout=\",      \"i:\"),",
    "                    (\"servicein=\",       \"I:\"),",
    "                    (\"show\",             \"J\" ),",
    "                    (\"cancelsync=\",      \"k:\"),",
    "                    (\"forcecopy=\",       \"K:\"),",
    "                    (\"rollingupdate=\",   \"L:\"),",
    "                    (\"resetmetrics=\",    \"m:\"),",
    "                    (\"opdump=\",          \"M:\"),",
    "                    (\"nodestat=\",        \"n:\"),",
    "                    (\"reloadplugins=\",   \"N:\"),",
    "                    (\"pausein=\",         \"p:\"),",
    "                    (\"pauseout=\",        \"P:\"),",
    "                    (\"instancecfg=\",     \"Q:\"),",
    "                    (\"resumein=\",        \"r:\"),",
    "                    (\"resumeout=\",       \"R:\"),",
    "                    (\"start=\",           \"s:\"),",
    "                    (\"status=\",          \"S:\"),",
    "                    (\"pausettl=\",        \"t:\"),",
    "                    (\"resumettl=\",       \"T:\"),",
    "                    (\"unsubscribe=\",     \"u:\"),",
    "                    (\"unbind=\",          \"U:\"),",
    "                    (\"throttle=\",        \"V:\"),",
    "                    (\"waitforidle=\",     \"w:\"),",
    "                    (\"persist=\",         \"W:\"),",
    "                    (\"stop=\",            \"x:\"),",
    "                    (\"truncate=\",        \"X:\"),",
    "                    (\"sync=\",            \"y:\"),",
    "                    (\"reversesync=\",     \"Y:\"),",
    "                    (\"descriptor=\",      \"Z:\")",
    "                ]",
    "            if address:",
    "                long_with_val = set([ \"--{}\".format(x.removesuffix('=')) for x,_ in paramdef if x.endswith('=') ])",
    "                short_with_val = set([ \"-{}\".format(x.removesuffix(':')) for _,x in paramdef if x.endswith(':') ])",
    "                with_val = long_with_val.union( short_with_val )",
    "                modified = []",
    "                sz = len( arguments )",
    "                last_i = sz-1",
    "                for i in range( sz ):",
    "                    arg = arguments[i]",
    "                    modified.append( arg )",
    "                    if arg in with_val:",
    "                        if i < last_i and not arguments[i+1].startswith('-'):",
    "                            continue",
    "                        modified.append('.')",
    "                arguments = modified",
    "            short = \"\".join([ x for _,x in paramdef ])",
    "            long = [x for x,_ in paramdef]",
    "            opts, args = getopt.getopt( arguments, short, long )",
    "            for o, a in opts:",
    "                if o in ( \"-h\", \"--help\" ):",
    "                    raise vgxadmin__InvalidUsageOrConfig()",
    "            descriptor = None",
    "            remote = None",
    "            filename = default_descriptor_filename",
    "            for o, a in opts:",
    "                if o in ( \"-f\", \"--cf\" ):",
    "                    filename = a",
    "            if address:",
    "                m = re.match( r\"^(\\S+):(\\d+)$\", address )",
    "                if m:",
    "                    try:",
    "                        h = m.group(1)",
    "                        p = int( m.group(2) )",
    "                        remote = vgxadmin__VGXRemote( host=h, port=p, console=console )",
    "                        D = remote.Endpoint( \"/vgx/builtin/system_descriptor\" )",
    "                        descriptor = vgxadmin__Descriptor( descriptor=D, remote=remote, console=console )",
    "                    except Exception as ex:",
    "                        raise vgxadmin__AddressError( \"{} -> {}\".format(address, ex) )",
    "            if descriptor is None:",
    "                if filename is not None:",
    "                    descriptor = vgxadmin__Descriptor( descriptor=filename, console=console )",
    "                else:",
    "                    try:",
    "                        if pyvgx.system.IsInitialized():",
    "                            D = sysplugin__GetSystemDescriptor()",
    "                            descriptor = vgxadmin__Descriptor( descriptor=D, console=console )",
    "                    except Exception as descr_ex:",
    "                        raise vgxadmin__InvalidUsageOrConfig( \"No descriptor: {}\".format( descr_ex ) )",
    "            if address:",
    "                if remote is None:",
    "                    remote = descriptor.remote = descriptor.Get( address ).remote",
    "            if remote is not None and len( opts ) == 0:",
    "                try:",
    "                    console.Print( \"{}\\n\".format( pyvgx.version(1).replace('pyvgx', 'vgxadmin') ) )",
    "                    console.Print( \"System    : {}\".format( descriptor.name ) )",
    "                    nodestat = remote.Endpoint( \"/vgx/nodestat\" )",
    "                    ping = remote.Endpoint( \"/vgx/ping\" ).get(\"host\",{})",
    "                    meminfo = remote.Endpoint( \"/vgx/meminfo\" ).get(\"memory\",{})",
    "                    console.Print( \"Service   : {}\".format( nodestat.get(\"service-name\") ) )",
    "                    console.Print( \"Version   : {}\".format( ping.get(\"version\") ) )",
    "                    console.Print( \"Hostname  : {}\".format( ping.get(\"name\") ) )",
    "                    console.Print( \"IP        : {}\".format( ping.get(\"ip\") ) )",
    "                    console.Print( \"Uptime    : {}\".format( ping.get(\"uptime\") ) )",
    "                    console.Print( \"CPU       : {}\".format( ping.get(\"cpu\") ) )",
    "                    memtotal = meminfo.get(\"total\",1)",
    "                    memavail = meminfo.get(\"current\",{}).get(\"available\",0)",
    "                    memvgx = meminfo.get(\"current\",{}).get(\"process\",0)",
    "                    console.Print( \"Memory    : System Total     = {:,} MiB\".format( memtotal >> 20 ) )",
    "                    console.Print( \"            System Available = {:.1f}%\".format( 100.0*memavail/memtotal ) )",
    "                    console.Print( \"            VGX Instance     = {:.1f}%\".format( 100.0*memvgx/memtotal ) )",
    "                except Exception as ex:",
    "                    raise vgxadmin__AddressError( \"{} -> {}\".format(remote, ex) )",
    "            CONFIRMED = False",
    "            for o, a in opts:",
    "                if o in ( \"-c\", \"--confirm\" ):",
    "                    CONFIRMED = True",
    "            for o, a in opts:",
    "                try:",
    "                    R = []",
    "                    if o in ( \"-a\", \"--attach\" ):",
    "                        id, subs = vgxadmin__VGXAdmin.GetArgs( a, [None, None] )",
    "                        if subs is None:",
    "                            for instance in descriptor.GetMultiple( a ):",
    "                                ret = instance.Attach()",
    "                                R.append( (instance, ret) )",
    "                        else:",
    "                            destinations = [descriptor.Get(x.strip()) for x in subs.split(\",\")]",
    "                            instance = descriptor.Get(id)",
    "                            ret = instance.Attach( destinations=destinations )",
    "                            R.append( (instance, ret) )",
    "                    elif o in ( \"-B\", \"--bind\" ):",
    "                        instance = descriptor.Get( a )",
    "                        ret = instance.Bind()",
    "                        R.append( (instance, ret) )",
    "                    elif o in ( \"-C\", \"--command\" ):",
    "                        id, gr, cmd = vgxadmin__VGXAdmin.GetArgs( a, [None, None, None] )",
    "                        R = descriptor.Concurrent( \"Command\", id, (gr, cmd) )",
    "                    elif o in ( \"-d\", \"--detach\" ):",
    "                        for instance in descriptor.GetMultiple( a ):",
    "                            ret = instance.Detach()",
    "                            R.append( (instance, ret) )",
    "                    elif o in ( \"-D\", \"--restarthttp\" ):",
    "                        R = descriptor.Concurrent( \"RestartHTTP\", a )",
    "                    elif o in ( \"-E\", \"--endpoint\" ):",
    "                        if remote is None:",
    "                            raise vgxadmin__InvalidUsageOrConfig( \"Option '{}' requires <address>\".format(o) )",
    "                        console.Print( json.dumps( remote.Endpoint( a ), indent=4 ) )",
    "                    elif o in ( \"-g\", \"--readonly\" ):",
    "                        R = descriptor.Concurrent( \"ReadonlyGraph\", a )",
    "                    elif o in ( \"-G\", \"--writable\" ):",
    "                        R = descriptor.Concurrent( \"WritableGraph\", a )",
    "                    elif o in ( \"-i\", \"--serviceout\" ):",
    "                        R = descriptor.Concurrent( \"ServiceOut\", a )",
    "                    elif o in ( \"-I\", \"--servicein\" ):",
    "                        R = descriptor.Concurrent( \"ServiceIn\", a )",
    "                    elif o in ( \"-J\", \"--show\" ):",
    "                        console.Print( json.dumps( descriptor.AsDict(), indent=4 ) )",
    "                    elif o in ( \"-k\", \"--cancelsync\" ):",
    "                        instance = descriptor.Get( a )",
    "                        ret = instance.CancelSync()",
    "                        R.append( (instance, ret) )",
    "                    elif o in ( \"-K\", \"--forcecopy\" ):",
    "                        src, dest = vgxadmin__VGXAdmin.GetArgs( a, [None, None] )",
    "                        source = descriptor.Get( src )",
    "                        destination = descriptor.Get( dest )",
    "                        ret = source.ForceCopy( source=source, destination=destination )",
    "                        R.append( (source, destination, ret) )",
    "                    elif o in ( \"-L\", \"--rollingupdate\" ):",
    "                        instance = descriptor.Get( a )",
    "                        ret = instance.RollingForwardSync()",
    "                        R.append( (instance, ret) )",
    "                    elif o in ( \"-m\", \"--resetmetrics\" ):",
    "                        R = descriptor.Concurrent( \"ResetMetrics\", a )",
    "                    elif o in ( \"-M\", \"--opdump\" ):",
    "                        instance = descriptor.Get( a )",
    "                        ret = instance.OpDump()",
    "                        R.append( (instance, ret) )",
    "                    elif o in ( \"-n\", \"--nodestat\" ):",
    "                        id, key = vgxadmin__VGXAdmin.GetArgs( a, [None, None] )",
    "                        for instance in descriptor.GetMultiple( id ):",
    "                            if key is None:",
    "                                console.Print( json.dumps( instance.Nodestat(), indent=4 ) )",
    "                            else:",
    "                                console.Print( \"{} {}={}\".format(instance, key, instance.Nodestat(key)) )",
    "                    elif o in ( \"-N\", \"--reloadplugins\" ):",
    "                        id, plugins_json_file = vgxadmin__VGXAdmin.GetArgs( a, [None, None] )",
    "                        if plugins_json_file is not None:",
    "                            f = open( plugins_json_file, \"r\" )",
    "                            plugin_json = f.read()",
    "                            f.close()",
    "                            json.loads( plugin_json ) # verify json loadable",
    "                            R = descriptor.Concurrent( \"ReloadPlugins\", id, (plugin_json,) )",
    "                        else:",
    "                            R = descriptor.Concurrent( \"ReloadPlugins\", id )",
    "                    elif o in ( \"-p\", \"--pausein\" ):",
    "                        R = descriptor.Concurrent( \"PauseIn\", a )",
    "                    elif o in ( \"-P\", \"--pauseout\" ):",
    "                        R = descriptor.Concurrent( \"PauseOut\", a )",
    "                    elif o in ( \"-Q\", \"--instancecfg\" ):",
    "                        instance = descriptor.Get( a )",
    "                        ret = instance.GetConfig()",
    "                        console.Print( ret )",
    "                    elif o in ( \"-r\", \"--resumein\" ):",
    "                        R = descriptor.Concurrent( \"ResumeIn\", a )",
    "                    elif o in ( \"-R\", \"--resumeout\" ):",
    "                        R = descriptor.Concurrent( \"ResumeOut\", a )",
    "                    elif o in ( \"-s\", \"--start\" ):",
    "                        ret = descriptor.Start( a )",
    "                        R.append( ret )",
    "                    elif o in ( \"-S\", \"--status\" ):",
    "                        descriptor.GetMultiple( a, printsum=True, detail=True )",
    "                    elif o in ( \"-t\", \"--pausettl\" ):",
    "                        R = descriptor.Concurrent( \"PauseTTL\", a )",
    "                    elif o in ( \"-T\", \"--resumettl\" ):",
    "                        R = descriptor.Concurrent( \"ResumeTTL\", a )",
    "                    elif o in ( \"-u\", \"--unsubscribe\" ):",
    "                        for instance in descriptor.GetMultiple( a ):",
    "                            ret = instance.Unsubscribe()",
    "                            R.append( (instance, ret) )",
    "                    elif o in ( \"-U\", \"--unbind\" ):",
    "                        instance = descriptor.Get( a )",
    "                        ret = instance.Unbind()",
    "                        R.append( (instance, ret) )",
    "                    elif o in ( \"-V\", \"--throttle\" ):",
    "                        id, rate, unit = vgxadmin__VGXAdmin.GetArgs( a, [None, -1.0, \"bytes\"] )",
    "                        R = descriptor.Concurrent( \"Throttle\", id, (rate, unit) )",
    "                    elif o in ( \"-w\", \"--waitforidle\" ):",
    "                        R = descriptor.Concurrent( \"WaitForIdle\", a )",
    "                    elif o in ( \"-W\", \"--persist\" ):",
    "                        R = descriptor.Concurrent( \"Persist\", a )",
    "                    elif o in ( \"-x\", \"--stop\" ):",
    "                        instances = descriptor.GetMultiple( a, printsum=True, confirm=\"SHUTDOWN\" if not CONFIRMED else None )",
    "                        if instances:",
    "                            R = descriptor.Concurrent( \"Shutdown\", a )",
    "                    elif o in ( \"-X\", \"--truncate\" ):",
    "                        instances = descriptor.GetMultiple( a, printsum=True, confirm=\"DELETE ALL DATA\" if not CONFIRMED else None )",
    "                        if instances:",
    "                            R = descriptor.Concurrent( \"Truncate\", a )",
    "                    elif o in ( \"-y\", \"--sync\" ):",
    "                        id, mode = vgxadmin__VGXAdmin.GetArgs( a, [None, \"repair\"] )",
    "                        for instance in descriptor.GetMultiple( id ):",
    "                            ret = instance.Sync( mode )",
    "                            R.append( (instance, ret) )",
    "                    elif o in ( \"-Y\", \"--reversesync\" ):",
    "                        instance = descriptor.Get( a )",
    "                        ret = instance.ReverseSync()",
    "                        R.append( (instance, ret) )",
    "                    elif o in ( \"-Z\", \"--descriptor\" ):",
    "                        for instance in descriptor.GetMultiple( a ):",
    "                            ret = instance.UpdateDescriptor( descriptor )",
    "                            R.append( (instance, ret) )",
    "                    if R and type(R) is list:",
    "                        i = 0",
    "                        for i in range(len(R)):",
    "                            if type( R[i] ) is tuple:",
    "                                R[i] = list(R[i])",
    "                            if type( R[i] ) is list and type(R[i][0]) is vgxadmin__VGXInstance:",
    "                                R[i][0] = str(R[i][0])",
    "                    RESULT.extend( R )",
    "                except vgxadmin__InvalidUsageOrConfig:",
    "                    raise",
    "                except vgxadmin__ServerError:",
    "                    raise",
    "                except vgxadmin__OperationIncomplete:",
    "                    raise",
    "                except Exception as err:",
    "                    if program is not None:",
    "                        pprint.pprint( err.args, stream=console.GetStream() )",
    "                    raise",
    "        except vgxadmin__AddressError as aerr:",
    "            raise",
    "        except vgxadmin__InvalidUsageOrConfig as uerr:",
    "            if uerr.args:",
    "                RESULT.append( \"{}\".format( uerr ) )",
    "            else:",
    "                vgxadmin__VGXAdmin.Usage( program=program, console=console )",
    "        except vgxadmin__ServerError as serr:",
    "            RESULT.append( str(serr) )",
    "        except vgxadmin__OperationIncomplete as operr:",
    "            RESULT.append( \"Operation incomplete: {}\".format( operr ) )",
    "        except getopt.GetoptError as err:",
    "            RESULT.append( str(err) )",
    "        except Exception as anyerr:",
    "            RESULT.append( str(anyerr) )",
    "        if not console.IsStdout():",
    "            RESULT.insert( 0, {\"trace\": console.GetLines()} )",
    "        return RESULT",
    "import pyvgx",
    "pyvgx.Descriptor = vgxadmin__Descriptor",
    "pyvgx.VGXRemote = vgxadmin__VGXRemote",
    "pyvgx.VGXAdmin = vgxadmin__VGXAdmin",
    0
};



static const char *PYVGX_BUILTIN__PYVGX_vgxinstance[] = {
    "# PYVGX_vgxinstance"
    "import pyvgx",
    "import sys",
    "import os",
    "import json",
    "import importlib",
    "import threading",
    "import time",
    "GRAPHS = []",
    "class vgxinstance__VGXInstance( object ):",
    "    INSTANCE = None",
    "    PLUGIN_MODULES = {}",
    "    RELOADABLE = {}",
    "    @staticmethod",
    "    def get_vgxroot( instance, basedir=\".\" ):",
    "        instance_dir = \"{}_{}\".format(instance.type, instance.id)",
    "        return os.path.join( basedir, instance_dir )",
    "    @staticmethod",
    "    def LoadLocalTestPlugins( instance ):",
    "        try:",
    "            if instance.type in [\"builder\", \"txproxy\", \"search\"]:",
    "                import test_plugin",
    "            if instance.type == \"builder\":",
    "                import test_feedfuncs",
    "            if instance.type == \"dispatch\":",
    "                import test_prepost",
    "        except Exception as err:",
    "            pass",
    "    @staticmethod",
    "    def InitAdmin( instance, root ):",
    "        pyvgx.system.Initialize( root, euclidean=True, events=False )",
    "        for gname in instance.graphs:",
    "            graph = pyvgx.Graph( gname, local=instance.IsLocal() )",
    "            graph.ClearGraphReadonly()",
    "            graph.EventEnable()",
    "            GRAPHS.append(graph)",
    "    @staticmethod",
    "    def InitGeneric( instance, root ):",
    "        pyvgx.system.Initialize( root, euclidean=True )",
    "        for gname in instance.graphs:",
    "            graph = pyvgx.Graph( gname, local=instance.IsLocal() )",
    "            graph.ClearGraphReadonly()",
    "            graph.EventEnable()",
    "            GRAPHS.append(graph)",
    "    @staticmethod",
    "    def InitBuilder( instance, root ):",
    "        pyvgx.system.Initialize( root, euclidean=True, idle=True )",
    "        for gname in instance.graphs:",
    "            graph = pyvgx.Graph( gname, local=instance.IsLocal() )",
    "            graph.ClearGraphReadonly()",
    "            graph.EventEnable()",
    "            GRAPHS.append(graph)",
    "    @staticmethod",
    "    def InitTXProxy( instance, root ):",
    "        pyvgx.system.Initialize( root, euclidean=True, events=False )",
    "        for gname in instance.graphs:",
    "            graph = pyvgx.Graph( gname, local=instance.IsLocal() )",
    "            graph.ClearGraphReadonly()",
    "            GRAPHS.append(graph)",
    "        pyvgx.op.Bind( port=instance.tport, durable=instance.durable, snapshot_threshold=1<<32 )",
    "    @staticmethod",
    "    def InitSearch( instance, root ):",
    "        pyvgx.system.Initialize( root, euclidean=True, events=False )",
    "        for gname in instance.graphs:",
    "            graph = pyvgx.Graph( gname, local=instance.IsLocal() )",
    "            graph.ClearGraphReadonly()",
    "            GRAPHS.append(graph)",
    "        pyvgx.op.Bind( port=instance.tport )",
    "    @staticmethod",
    "    def InitDispatcher( instance, root ):",
    "        pyvgx.system.Initialize( root, euclidean=True )",
    "        for gname in instance.graphs:",
    "            graph = pyvgx.Graph( gname, local=instance.IsLocal() )",
    "            graph.ClearGraphReadonly()",
    "            GRAPHS.append(gname)",
    "    @staticmethod",
    "    def GetDescriptor( descriptor_file=None ):",
    "        \"\"\"",
    "        Get system descriptor",
    "        \"\"\"",
    "        if descriptor_file is None:",
    "            descriptor_file = \"vgx.cf\"",
    "        descriptor = pyvgx.Descriptor( descriptor=descriptor_file )",
    "        return descriptor",
    "    @staticmethod",
    "    def LoadFuncFromModule( plugin_module, func_ref ):",
    "        if type(func_ref) is not str:",
    "            return func_ref",
    "        obj = plugin_module",
    "        for elem in func_ref.split(\".\"):",
    "            obj = getattr( obj, elem )",
    "        return obj",
    "    @staticmethod",
    "    def GetGraph( name, local ):",
    "        try:",
    "            return pyvgx.Graph( name, local=local )",
    "        except Exception as err:",
    "            return pyvgx.system.GetGraph( name )",
    "    @staticmethod",
    "    def LoadPlugins( instance=None, plugins=None ):",
    "        \"\"\"",
    "        Load or reload plugins",
    "        \"\"\"",
    "        if instance is None:",
    "            instance = vgxinstance__VGXInstance.INSTANCE",
    "        else:",
    "            vgxinstance__VGXInstance.INSTANCE = instance",
    "        if plugins is None:",
    "            plugins = vgxinstance__VGXInstance.RELOADABLE.values()",
    "        MODULES = {}",
    "        for plugin_def in plugins:",
    "            plugin_package_name = plugin_def.get( \"package\", \"\" )",
    "            plugin_module_name = plugin_def.get( \"module\" )",
    "            if plugin_module_name is not None:",
    "               key = \"{}{}\".format( plugin_package_name, plugin_module_name )",
    "               if key not in MODULES:",
    "                   MODULES[ key ] = ( plugin_package_name, plugin_module_name )",
    "        for key, value in MODULES.items():",
    "            plugin_package_name, plugin_module_name = value",
    "            plugin_module = vgxinstance__VGXInstance.PLUGIN_MODULES.get( key )",
    "            if plugin_module is None:",
    "                plugin_module = importlib.import_module( plugin_module_name, package=plugin_package_name )",
    "                pyvgx.LogInfo( \"Imported plugin module: {}\".format( plugin_module ) )",
    "            else:",
    "                plugin_module = importlib.reload( plugin_module )",
    "                pyvgx.LogInfo( \"Reloaded plugin module: {}\".format( plugin_module ) )",
    "            vgxinstance__VGXInstance.PLUGIN_MODULES[ key ] = plugin_module",
    "        ADDED = []",
    "        for plugin_def in plugins:",
    "            plugin_name = plugin_def.get( \"name\" )",
    "            plugin_package_name = plugin_def.get( \"package\", \"\" )",
    "            plugin_module_name = plugin_def.get( \"module\" )",
    "            plugin_engine = plugin_def.get( \"engine\" )",
    "            plugin_pre = plugin_def.get( \"pre\" )",
    "            plugin_post = plugin_def.get( \"post\" )",
    "            plugin_graph_name = plugin_def.get( \"graph\" )",
    "            if plugin_module_name is not None:",
    "                key = \"{}{}\".format( plugin_package_name, plugin_module_name )",
    "                plugin_module = vgxinstance__VGXInstance.PLUGIN_MODULES[ key ]",
    "                plugin_engine = vgxinstance__VGXInstance.LoadFuncFromModule( plugin_module, plugin_engine )",
    "                plugin_pre = vgxinstance__VGXInstance.LoadFuncFromModule( plugin_module, plugin_pre )",
    "                plugin_post = vgxinstance__VGXInstance.LoadFuncFromModule( plugin_module, plugin_post )",
    "                if plugin_name not in vgxinstance__VGXInstance.RELOADABLE:",
    "                    vgxinstance__VGXInstance.RELOADABLE[ plugin_name ] = plugin_def",
    "            if type( plugin_name ) is not str:",
    "                raise ValueError( \"Plugin 'name' required, and must be string\" )",
    "            if plugin_graph_name is None:",
    "                graph = None",
    "            elif plugin_graph_name == \"*\":",
    "                if instance.graphs:",
    "                    graph = vgxinstance__VGXInstance.GetGraph( name=instance.graphs[0], local=instance.IsLocal() )",
    "                else:",
    "                    graph = None",
    "            elif plugin_graph_name in instance.graphs:",
    "                graph = vgxinstance__VGXInstance.GetGraph( name=plugin_graph_name, local=instance.IsLocal() )",
    "            else:",
    "                raise ValueError( \"Unknown graph name '{}' in definition of plugin '{}'\".format( plugin_graph_name, plugin_name ) )",
    "            if instance.type == \"dispatch\":",
    "                pre = plugin_pre",
    "                post = plugin_post",
    "                if plugin_pre or plugin_post:",
    "                    if plugin_pre and not callable(plugin_pre):",
    "                        raise ValueError( \"'pre' must be callable for plugin '{}', got {}\".format( plugin_name, type(plugin_pre) ) )",
    "                    if plugin_post and not callable(plugin_post):",
    "                        raise ValueError( \"'post' must be callable for plugin '{}', got {}\".format( plugin_name, type(plugin_post) ) )",
    "                    infos = [\"Dispatcher plugin\"]",
    "                    if plugin_pre is not None:",
    "                        infos.append( \"pre={}.{}\".format( plugin_pre.__module__, plugin_pre.__name__ ) )",
    "                    if plugin_post is not None:",
    "                        infos.append( \"post={}.{}\".format( plugin_post.__module__, plugin_post.__name__ ) )",
    "                    info = \" \".join( infos )",
    "                    ADDED.append( info )",
    "                    pyvgx.LogInfo( info )",
    "                    if graph is None:",
    "                        pyvgx.system.AddPlugin( pre=plugin_pre, post=plugin_post, name=plugin_name )",
    "                    else:",
    "                        pyvgx.system.AddPlugin( pre=plugin_pre, post=plugin_post, name=plugin_name, graph=graph )",
    "            else:",
    "                if plugin_engine:",
    "                    if not callable(plugin_engine):",
    "                        raise ValueError( \"'engine' must be callable for plugin '{}', got {}\".format( plugin_name, type(plugin_engine) ) )",
    "                    info = \"Plugin engine={}.{}\".format( plugin_engine.__module__, plugin_engine.__name__ )",
    "                    ADDED.append( info )",
    "                    pyvgx.LogInfo( info )",
    "                    if graph is None:",
    "                        pyvgx.system.AddPlugin( engine=plugin_engine, name=plugin_name )",
    "                    else:",
    "                        pyvgx.system.AddPlugin( engine=plugin_engine, name=plugin_name, graph=graph )",
    "        return ADDED",
    "    @staticmethod",
    "    def StartInstance( id, descriptor, basedir=\".\", plugins=[] ):",
    "        \"\"\"",
    "        Start VGX instance",
    "        \"\"\"",
    "        if type( descriptor ) is pyvgx.Descriptor:",
    "            pass",
    "        elif type( descriptor ) is str or descriptor is None:",
    "            descriptor = vgxinstance__VGXInstance.GetDescriptor( descriptor )",
    "        elif type( descriptor ) is dict:",
    "            descriptor = pyvgx.Descriptor( descriptor )",
    "        else:",
    "            raise TypeError( \"descriptor must be pyvgx.Descriptor, str, or None\" )",
    "        instance = descriptor.Get(id)",
    "        root = vgxinstance__VGXInstance.get_vgxroot( instance, basedir )",
    "        if instance.type in [\"admin\", \"generic\"]:",
    "            if instance.type == \"admin\":",
    "                vgxinstance__VGXInstance.InitAdmin( instance, root )",
    "            else:",
    "                vgxinstance__VGXInstance.InitGeneric( instance, root )",
    "        elif instance.type == \"builder\":",
    "            vgxinstance__VGXInstance.InitBuilder( instance, root )",
    "        elif instance.type == \"txproxy\":",
    "            vgxinstance__VGXInstance.InitTXProxy( instance, root )",
    "        elif instance.type == \"search\":",
    "            vgxinstance__VGXInstance.InitSearch( instance, root )",
    "        elif instance.type == \"dispatch\":",
    "            vgxinstance__VGXInstance.InitDispatcher( instance, root )",
    "        else:",
    "            raise Exception( \"Unknown instance type: {}\".format(instance.type) )",
    "        pyvgx.system.StartHTTP(",
    "            port       = instance.hport,",
    "            ip         = instance.ip,",
    "            prefix     = instance.prefix,",
    "            servicein  = instance.s_in,",
    "            dispatcher = instance.cfdispatcher",
    "        )",
    "        sysplugin__SetSystemDescriptor( descriptor.AsDict(), ident=id )",
    "        vgxinstance__VGXInstance.LoadLocalTestPlugins( instance )",
    "        vgxinstance__VGXInstance.LoadPlugins( instance, plugins )",
    "        if instance.attach:",
    "            attacher = threading.Thread( target=vgxinstance__VGXInstance.TryAttach, args=(instance,) )",
    "            attacher.start()",
    "        return instance",
    "    @staticmethod",
    "    def TryAttach( instance ):",
    "        if not instance.attach:",
    "            return",
    "        try:",
    "            n = 5",
    "            while n > 0:",
    "                try:",
    "                    instance.Attach()",
    "                    break",
    "                except Exception:",
    "                    time.sleep(1.0)",
    "                    n -= 1",
    "        except Exception:",
    "            pass",
    "import pyvgx",
    "pyvgx.VGXInstance = vgxinstance__VGXInstance",
    0
};



const char **PYVGX_PLUGIN_BUILTINS[] = {
    PYVGX_BUILTIN__ADMIN_Attach,
    PYVGX_BUILTIN__ADMIN_Bind,
    PYVGX_BUILTIN__ADMIN_CancelSync,
    PYVGX_BUILTIN__ADMIN_ClearReadonly,
    PYVGX_BUILTIN__ADMIN_Console,
    PYVGX_BUILTIN__ADMIN_Detach,
    PYVGX_BUILTIN__ADMIN_DetachAll,
    PYVGX_BUILTIN__ADMIN_GetAuthToken,
    PYVGX_BUILTIN__ADMIN_Persist,
    PYVGX_BUILTIN__ADMIN_ReloadPlugins,
    PYVGX_BUILTIN__ADMIN_ResetMetrics,
    PYVGX_BUILTIN__ADMIN_RestartHTTP,
    PYVGX_BUILTIN__ADMIN_ResumeEvents,
    PYVGX_BUILTIN__ADMIN_ResumeTxInput,
    PYVGX_BUILTIN__ADMIN_ResumeTxOutput,
    PYVGX_BUILTIN__ADMIN_ServiceIn,
    PYVGX_BUILTIN__ADMIN_ServiceOut,
    PYVGX_BUILTIN__ADMIN_SetReadonly,
    PYVGX_BUILTIN__ADMIN_Shutdown,
    PYVGX_BUILTIN__ADMIN_Subscribe,
    PYVGX_BUILTIN__ADMIN_SuspendEvents,
    PYVGX_BUILTIN__ADMIN_SuspendTxInput,
    PYVGX_BUILTIN__ADMIN_SuspendTxOutput,
    PYVGX_BUILTIN__ADMIN_Sync,
    PYVGX_BUILTIN__ADMIN_SystemDescriptor,
    PYVGX_BUILTIN__ADMIN_Throttle,
    PYVGX_BUILTIN__ADMIN_Truncate,
    PYVGX_BUILTIN__ADMIN_Unbind,
    PYVGX_BUILTIN__ADMIN_Unsubscribe,
    PYVGX_BUILTIN__ADMIN_UpdateSubscribers,
    PYVGX_BUILTIN__BUILTIN_arcs,
    PYVGX_BUILTIN__BUILTIN_connect,
    PYVGX_BUILTIN__BUILTIN_createvertex,
    PYVGX_BUILTIN__BUILTIN_deletevertex,
    PYVGX_BUILTIN__BUILTIN_disconnect,
    PYVGX_BUILTIN__BUILTIN_echo,
    PYVGX_BUILTIN__BUILTIN_evaluate,
    PYVGX_BUILTIN__BUILTIN_eventbacklog,
    PYVGX_BUILTIN__BUILTIN_graphinfo,
    PYVGX_BUILTIN__BUILTIN_init,
    PYVGX_BUILTIN__BUILTIN_matrix,
    PYVGX_BUILTIN__BUILTIN_matrixplugins,
    PYVGX_BUILTIN__BUILTIN_memory,
    PYVGX_BUILTIN__BUILTIN_metrics,
    PYVGX_BUILTIN__BUILTIN_neighbor,
    PYVGX_BUILTIN__BUILTIN_ping,
    PYVGX_BUILTIN__BUILTIN_properties,
    PYVGX_BUILTIN__BUILTIN_system_counts,
    PYVGX_BUILTIN__BUILTIN_system_descriptor,
    PYVGX_BUILTIN__BUILTIN_system_overview,
    PYVGX_BUILTIN__BUILTIN_system_rates,
    PYVGX_BUILTIN__BUILTIN_vertex,
    PYVGX_BUILTIN__BUILTIN_vertices,
    PYVGX_BUILTIN__INTERNAL_admin,
    PYVGX_BUILTIN__INTERNAL_ast_validator,
    PYVGX_BUILTIN__PYVGX_vgxadmin,
    PYVGX_BUILTIN__PYVGX_vgxinstance,
    0
};



#endif
